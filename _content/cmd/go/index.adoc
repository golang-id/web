=  Perintah go
:toc:

Go adalah sebuah perkakas untuk mengatur sumber kode Go.

Penggunaan:

----
go <perintah> [argumen]
----

Perintah-perintahnya adalah:

----
bug         jalankan pelaporan bug
build       kompilasi paket dan dependensi
clean       hapus berkas hasil build dan cache
doc         tampilkan dokumentasi dari paket atau simbol
env         cetak informasi lingkungan dari Go
fix         ubah paket untuk menggunakan API yang baru
fmt         gofmt (format ulang) sumber paket
generate    buat berkas Go dengan memproses sumber
get         tambah dan pasang dependensi ke modul yang sekarang
install     kompilasi dan pasang paket dan dependensi
list        cetak daftar paket atau modul
mod         pemeliharaan modul
run         kompilasi dan jalankan program Go
test        tes paket
tool        jalankan perkakas go tertentu
version     cetak versi Go
vet         laporkan kemungkinan kesalahan dalam paket
----

Gunakan "go help <perintah>" untuk informasi tentang perintah.

Beberapa topik bantuan tambahan:

----
buildconstraint batasan-batasan dari build
buildmode       mode-mode dari build
c               pemanggilan antara Go dan C
cache           cache pada pembangunan dan tes
environment     variabel-variabel lingkungan
filetype        tipe-tipe berkas
go.mod          berkas go.mod
gopath          variabel lingkungan GOPATH
gopath-get      legasi GOPATH menggunakan go get
goproxy         protokol proxy pada modul
importpath      sintaksis untuk path impor
modules         modul, versi modul, dan banyak lagi
module-get      go get dengan menggunakan modul
module-auth     autentikasi modul menggunakan go.sum
module-private  konfigurasi modul untuk modul yang tidak publik
packages        daftar dan pola paket
testflag        opsi-opsi untuk tes
testfunc        fungsi-fungsi untuk tes
----

Gunakan "go help <topik>" untuk informasi lanjut tentang topik tersebut.

[#hdr-Start_a_bug_report]
==  Jalankan pelaporan bug

Penggunaan:

----
go bug
----

Perintah `bug` membuka peramban dan menjalankan laporan _bug_ yang baru.
Laporan tersebut mengikutkan informasi sistem.


[#hdr-Compile_packages_and_dependencies]
==  Kompilasi paket-paket dan dependensi

Penggunaan:

----
go build [-o output] [-i] [flag build] [paket]
----

Perintah `build` kompilasi paket-paket berdasarkan nama dari path import,
bersama dengan dependensinya, namun tidak memasang hasilnya.

Jika argumennya adalah daftar berkas .go dari sebuah direktori, maka `build`
menganggapnya sebagai daftar berkas sumber dari paket yang sama.

Saat mengompilasi paket, `build` mengindahkan berkas yang berakhiran
`_test.go`.

Saat mengompilasi paket main, `build` menulis hasil program ke sebuah berkas
yang namanya diambil dari berkas sumber pertama (`go build ed.go rx.go`
menulis `ed` atau `ed.exe`) atau direktori sumber kode
(`go build unix/sam` menulis `sam` atau `sam.exe`).
Akhiran '.exe' ditambahkan bila menulis program untuk Windows.

Saat mengompilasi beberapa paket atau paket yang bukan `main`, `build`
mengompilasi paket-paket tersebut namun mengindahkan objek hasilnya,
cara ini untuk memeriksa bahwa paket dapat dibangun.

Opsi "-o" memaksa `build` untuk menulis hasil program atau objek dengan nama
atau direktori yang diberikan, bukan dengan perilaku seperti yang dijelaskan
pada dua paragraf sebelumnya.
Jika nama keluaran adalah direktori yang sudah ada, maka hasil program akan
ditulis di dalam direktori tersebut.

Opsi "-i" memasang paket-paket dependensi dari target.

Opsi-opsi dari `build` berikut dapat digunakan pada perintah `clean`, `get`,
`install`, `list`, `run`, dan `test`:

----
-a
	buat ulang semua paket bahkan yang sudah terbarukan.
-n
	cetak perintah-perintah tetapi jangan jalankan.
-p n
	jumlah program, seperti perintah build atau test, yang dapat berjalan
	secara paralel.
	Nilai baku dari n yaitu jumlah CPU yang tersedia.
-race
	izinkan deteksi data race.
	Hanya didukung pada linux/amd64, freebsd/amd64, darwin/amd64,
	windows/amd64, linux/ppc64le, dan linux/arm64 (hanya untuk 48-bit
	VMA).
-msan
	izinkan operasi dengan pembersih memory.
	Hanya didukung pada linux/amd64, linux/arm64 dan hanya lewat
	Clang/LLVM sebagai compiler C.
	Pada linux/arm64, mode build "pie" akan digunakan.
-v
	cetak nama-nama paket saat mereka dikompilasi.
-work
	cetak nama dari direktori sementara dan jangan hapus saat selesai.
-x
	cetak perintah-perintah.

-asmflags '[pattern=]arg list'
	argumen yang dikirim ke setiap pemanggilan `go tool asm`.
-buildmode mode
	mode pembangunan yang akan digunakan.  Lihat 'go help buildmode' untuk
	lebih lanjut.
-compiler name
	nama compiler yang akan digunakan, seperti dalam runtime.Compiler
	(gccgo atau gc).
-gccgoflags '[pattern=]arg list'
	argumen yang akan dikirim setiap pemanggilan compiler/linker gccgo.
-gcflags '[pattern=]arg list'
	argumen yang akan dikirim setiap pemanggilan "go tool compile"
-installsuffix suffix
	Sufiks yang digunakan sebagai nama direktori pemasangan paket, dengan
	tujuan untuk menjaga keluaran terpisah dengan pembangunan biasa.
	Jika menggunakan opsi -race, maka akhiran pada pemasangan secara
	otomatis di set ke race atau, jika di set secara eksplisit, akan
	ditambahkan _race.
	Hal yang sama juga berlaku pada opsi -msan.
	Menggunakan opsi -buildmode yang membutuhkan opsi-opsi yang tidak
	biasa akan mendapatkan efek yang sama.
-ldflags '[pattern=]arg list'
	argumen yang akan dikirim ke setiap pemanggilan "go tool link"
-linkshared
	link dengan pustaka yang dibuat sebelumnya dengan -buildmode=shared.
-mod mode
	mode pengunduhan modul yang digunakan: readonly atau vendor.
	Lihat 'go help modules' untuk lebih lanjut.
-modcacherw
	direktori yang baru dibuat dalam modul _cache_ akan di set read-write
	bukan read-only
.-pkgdir dir
	pasang dan muat semua paket dari "dir" sebagai ganti dari lokasi
	biasa.
	Contohnya, saat membangun dengan konfigurasi non-standar, gunakan
	-pkgdir untuk menghasilkan paket di lokasi yang berbeda.
-tags tag,list
	daftar tag dari build yang terpisah dengan koma yang akan dipenuhi
	selama pembangunan.
	Untuk informasi lebih lanjut tentang build tag, lihat deskripsi dari
	batasan-batasan build dalam dokumentasi untuk paket go/build.
	(Versi dahulu dari Go menggunakan daftar yang terpisah dengan spasi,
	dan bentuk tersebut sudah tidak digunakan lagi namun masih tetap
	dikenali.
-trimpath
	hapus semua path-path sistem dari hasil program.
	Nama berkas yang tercatat akan dimulai dengan "go" (untuk pustaka
	standar), atau modul path@version (bila menggunakan modul), atau path
	import biasa (bila menggunakan GOPATH).
-toolexec 'cmd args'
	program yang digunakan untuk memanggil program toolchain seperti vet
	dan asm.
	Misalnya, alih-alih menjalankan asm, perintah go akan menjalankan
	'cmd args /path/to/asm <argumen untuk asm>'.
----

Opsi -asmflags, -gccgoflags, -gcflags, dan -ldflags menerima daftar argumen
yang dipisahkan oleh spasi untuk dikirim ke perkakas yang dijalankan
dibelakangnya selama pembangunan.
Untuk menambah spasi dalam elemen dalam daftar tersebut, kurung dengan tanda
kutip tunggal atau ganda.
Daftar argumen bisa diawali dengan sebuah pola paket dan tanda sama dengan
("="), yang membatasi penggunaan dari daftar argumen tersebut ke pembangunan
paket-paket yang cocok dengan pola (lihat 'go help packages' untuk deskripsi
dari pola paket).
Tanpa pola, daftar argumen hanya berlaku untuk paket yang diberikan pada
perintah baris.
Opsi-opsi tersebut bisa berulang dengan pola yang berbeda dengan tujuan untuk
menentukan argumen yang berbeda untuk sekumpulan paket.
Jika sebuah pola pencocokan paket diberikan dalam beberapa opsi, kecocokan
yang terakhir akan digunakan.
Sebagai contohnya, 'go build -gcflags=-S fmt' mencetak _disassembly_ hanya
untuk paket fmt, sementara 'go build -gcflags=all=-S fmt' mencetak
_disassembly_ untuk fmt dan semua dependensinya.

Untuk lebih tahu tentang cara menspesifikasikan paket, lihat 'go help
packages'.
Untuk mengetahui lebih lanjut tentang di mana paket dan program dipasang,
jalankan 'go help gopath'.
Untuk mengetahui lebih lanjut tentang pemanggilan antara Go dan C/C++,
jalankan 'go help c'.

Catatan: Perintah `build` mengikuti beberapa konvensi seperti yang dijelaskan
oleh 'go help gopath'.
Tidak semua proyek dapat mengikuti konvensi tersebut.
Pemasangan yang memiliki konvensinya sendiri atau yang menggunakan sistem
pembangunan perangkat lunak yang terpisah bisa memilih untuk menggunakan
pemanggilan tingkat-rendah seperti 'go tool compile' dan 'go tool link' untuk
menghindari beberapa beban dan rancangan dari perkakas build.

Lihat juga: go install, go get, go clean.


[#hdr-Remove_object_files_and_cached_files]
==  Hapus berkas-berkas objek dan _cache_

Penggunaan:

----
go clean [clean flags] [build flags] [packages]
----

Perintah `clean` menghapus berkas objek dari direktori sumber paket.
Perintah go menulis objek dalam sebuah direktori sementara, sehingga
'go clean' biasanya berguna untuk berkas objek sisa dari perkakas lain atau
dari pemanggilan manual dari go build.

Jika argumen sebuah paket diberikan atau opsi -i atau -r di set, `clean`
menghapus berkas-berkas berikut dari setiap direktori sumber yang
berkorespondensi dengan path impor:

----
_obj/            direktori objek yang lama, sisa dari Makefiles
_test/           direktori tes yang lama, sisa dari Makefiles
_testmain.go     berkas gotest lama, sisa dari Makefiles
test.out         log tes lama, sisa dari Makefiles
build.out        log tes lama, sisa dari Makefiles
*.[568ao]        berkas object, sisa dari Makefiles

DIR(.exe)        dari go build
DIR.test(.exe)   dari go test -c
MAINFILE(.exe)   dari go build MAINFILE.go
*.so             dari SWIG
----

Dalam daftar tersebut, DIR merepresentasikan elemen path terakhir dari
direktori, dan MAINFILE adalah nama dasar dari sumber kode Go dalam direktori
tersebut yang tidak diikutkan saat membangun paket.

Opsi -i membuat perintah `clean` untuk menghapus arsip dan binary yang
terpasang (yang dibuat oleh 'go install').

Opsi -n membuat perintah `clean` untuk mencetak perintah penghapusan yang
akan dieksekusi, namun tidak menjalankannya.

Opsi -r membuat perintah `clean` menerapkan secara rekursif ke semua
dependensi dari paket dari path impor.

Opsi -x membuat perintah `clean` mencetak perintah penghapus saat ia
dieksekusi.

Opsi -cache membuat `clean` menghapus semua _cache_ dari go build.

Opsi -testcache menyuruh supaya `clean` untuk kedaluwarsa semua hasil tes
dalam _cache_ go build.

Opsi -modcache menyebabkan `clean` menghapus semua _cache_ unduhan modul
termasuk sumber kode dari dependensi yang memiliki versi.

Untuk lebih lanjut tentang opsi build, lihat 'go help build'.

Untuk lebih lanjut tentang menentukan paket, lihat 'go help packages'.


[#hdr-Show_documentation_for_package_or_symbol]
==  Tampilkan dokumentasi dari paket atau simbol

Penggunaan:

----
go doc [-u] [-c] [package|[package.]symbol[.methodOrField]]
----

Perintah `doc` mencetak komentar dokumentasi yang berasosiasi dengan item yang
diidentifikasi lewat argumen-argumen (sebuah paket, const, func, type, var,
method, atau field dari struct) diikuti dengan sebuah ringkasan satu-baris
dari setiap item tingkat-pertama "di bawah" item tersebut (deklarasi
tingkat-paket untuk sebuah paket, method untuk sebuah tipe, dan seterusnya.).

Perintah `doc` menerima argumen kosong, satu, atau dua.

Bila argumen tidak ada, yaitu, bila dijalankan seperti

----
go doc
----

ia akan mencetak dokumentasi paket dalam direktori yang sekarang.
Jika paket adalah sebuah program (package main), simbol-simbol yang diekspor
oleh paket tidak ditampilkan kecuali bila opsi -cmd diberikan.

Bila dijalankan dengan satu argumen, maka argumen tersebut dianggap sebagai
representasi mirip sintaksis Go dari item yang didokumentasikan.
Apa yang argumen pilih bergantung pada apa yang dipasang dalam GOROOT dan
GOPATH, sebagaimana juga bentuk dari argumen, yang secara semantik adalah satu
dari hal berikut:

----
go doc <pkg>
go doc <sym>[.<methodOrField>]
go doc [<pkg>.]<sym>[.<methodOrField>]
go doc [<pkg>.][<sym>.]<methodOrField>
----

Item pertama dalam daftar di atas yang sesuai dengan argumen akan dicetak
dokumentasinya.
(Lihat contoh di bawah).
Namun jika argumen dimulai dengan huruf besar maka diasumsikan sebagai simbol
atau method dari direktori yang sekarang.

Untuk paket, urutan pencarian ditentukan secara leksikal dengan cara
_breadth-first order_.
Yaitu, paket yang ditampilkan adalah yang cocok dengan pencarian dan terdekat
dengan root dan yang pertama secara leksikal di tingkat hirarkinya.
Pohon GOROOT selalu dicari pertama kali sebelum GOPATH.

Jika tidak ada paket yang diberikan atau cocok, maka paket di direktori
sekarang yang dipilih, sehingga "go doc Foo" memperlihatkan dokumentasi untuk
simbol Foo dalam paket yang sekarang.

Path dari paket bisa secara penuh atau cukup sufiks dari path saja.
Mekanisme umum dari go tool tidak berlaku: elemen path paket seperti . dan ...
tidak diimplementasikan oleh `go doc`.

Bila dijalankan dengan dua argumen, yang pertama haruslah path penuh dari
paket (tidak hanya sufiks saja), dan yang kedua adalah simbol, atau simbol
dengan method atau field struct.
Hal ini sama dengan sintaksis yang diterima oleh godoc:

----
go doc <pkg> <sym>[.<methodOrField>]
----

Dalam semua bentuk, saat mencocokan simbol, huruf kecil dalam argumen
menyesuaikan dengan huruf kecil atau besar namun huruf besar dicocokan persis.
Hal ini berarti akan ada beberapa kecocokan dari argumen dengan huruf kecil
dalam sebuah paket jika simbol yang berbeda memiliki huruf yang berbeda.
Jika hal ini terjadi, dokumentasi untuk semua kecocokan dicetak.

Contoh:

----
go doc
	Tampilkan dokumentasi dari paket yang sekarang.
go doc Foo
	Tampilkan dokumentasi dari Foo dalam paket sekarang.
	(Foo dimulai dengan huruf besar sehingga tidak sesuai dengan path
	paket.)
go doc encoding/json
	Tampilkan dokumentasi dari paket encoding/json.
go doc json
	Cara cepat untuk encoding/json.
go doc json.Number (or go doc json.number)
	Tampilkan dokumentasi dan ringkasan method untuk json.Number.
go doc json.Number.Int64 (or go doc json.number.int64)
	Tampilkan dokumentasi untuk method json.Number Int64.
go doc cmd/doc
	Tampilkan dokumentasi paket untuk perintah doc.
go doc -cmd cmd/doc
	Tampilkan dokumentasi dan simbol-simbol yang diekspor dalam perintah
	doc.
go doc template.new
	Tampilkan dokumentasi untuk fungsi html/template New.
	(html/template secara leksikal sebelum text/template).
go doc text/template.new # Satu argumen
	Tampilkan dokumentasi untuk fungsi text/template New.
go doc text/template new # Dua argumen
	Tampilkan dokumentasi untuk fungsi text/template New.

Paling tidak, pemanggilan berikut mencetak dokumentasi untuk method
json.Decoder Decode:

go doc json.Decoder.Decode
go doc json.decoder.decode
go doc json.decode
cd go/src/encoding/json; go doc decode
----

Opsi-opsi:

----
-all
	Tampilkan semua dokumentasi dari paket.
-c
	Perhatikan huruf besar/kecil saat mencari simbol.
-cmd
	Perlakukan sebuah perintah (paket main) seperti paket biasa.
	Sebaliknya simbol-simbol yang diekspor paket main disembunyikan saat
	menampilkan dokumentasi paket tingkat-atas.
-short
	Tampilkan satu-baris representasi untuk setiap simbol.
-src
	Tampilkan keseluruhan sumber kode dari simbol.  Cara ini
	memperlihatkan seluruh sumber Go dari deklarasi dan definisi, seperti
	sebuah definisi fungsi (termasuk badannya), deklarasi tipe atau blok
	const.  Keluarannya bisa mengikutkan rincian yang tidak diekspor.
-u
	Tampilkan dokumentasi untuk simbol, method, field yang tidak diekspor
	dan yang diekspor.
----


[#hdr-Print_Go_environment_information]
==  Cetak informasi lingkungan dari Go

Penggunaan:

----
go env [-json] [-u] [-w] [var ...]
----

Perintah `env` mencetak informasi lingkungan Go.

Secara baku env mencetak informasi sebagai skrip _shell_ (pada Windows, sebuah
berkas _batch_).
Jika satu atau lebih variabel diberikan sebagai argumen, env mencetak nilai
dari setiap variabel per baris.

Opsi -json mencetak nilai variabel dalam format JSON.

Opsi -u membutuhkan satu atau lebih argumen dan akan menghapus pengaturan baku
dari variabel lingkungan tersebut, jika sebelumnya telah diset dengan
'go env -w'.

Opsi -w membutuhkan satu atau lebih argumen dengan bentuk NAME=VALUE dan
mengubah pengaturan baku dari variabel lingkungan yang diberikan sesuai dengan
nilainya.

Untuk lebih lanjut tentang variabel lingkungan, lihat 'go help environment'.


[#hdr-Update_packages_to_use_new_APIs]
==  Ubah paket untuk menggunakan API yang baru

Penggunaan:

----
go fix [packages]
----

Perintah `fix` menjalankan perintah perbaikan Go terhadap nama paket-paket
yang diberikan lewat path impor.

Untuk lebih lanjut tentang fix, lihat 'go doc cmd/fix'.
Untuk lebih lanjut tentang argumen paket, lihat 'go help packages'.

Untuk menjalankan fix dengan opsi-opsi tertentu, jalankan 'go tool fix'.

Lihat juga: go fmt, go vet.


[#hdr-Gofmt__reformat__package_sources]
==  Gofmt (format ulang) sumber-sumber paket

Penggunaan:

----
go fmt [-n] [-x] [packages]
----

Fmt menjalankan program 'gofmt -l -w' pada paket-paket berdasarkan nama dari
path import.
Ia akan mencetak nama berkas yang diubah.

Untuk informasi lebih lanjut tentang gofmt, lihat 'go doc cmd/gofmt'.
Untuk informasi tentang menentukan paket, lihat 'go help packages'.

Opsi -n mencetak perintah yang akan dieksekusi.
Opsi -x mencetak perintah saat dieksekusi.

Opsi -mod menset mode unduhan yang akan digunakan: baca-saja atau vendor.
Lihat 'go help modules' untuk lebih lanjut.

Untuk menjalankan gofmt dengan opsi tertentu, jalankan gofmt itu sendiri.

Lihat juga: go fix, go vet.


[#hdr-Generate_Go_files_by_processing_source]
==  Buat berkas Go dengan memproses sumber

Penggunaan:

----
go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
----

Generate menjalankan perintah yang dijelaskan oleh petunjuk dalam berkas.
Perintah tersebut dapat menjalankan proses apa saja namun tujuannya yaitu
membuat atau memperbarui sumber berkas Go.

Go generate tidak pernah dijalankan secara otomatis oleh go build, go get, go
test, and seterusnya.
Ia harus dijalankan secara eksplisit.

Go generate memindai petunjuk dalam berkas, yang berupa baris dalam bentuk,

----
//go:generate perintah argumen...
----

(catatan: tidak ada spasi awal dan spasi dalam "//go") yang mana "perintah"
adalah generator yang akan dijalankan, yang berkorespondensi dengan nama
berkas program yang dapat dijalankan di lokal.
Program tersebut harus ada dalam PATH dari _shell_, path penuh
(/usr/you/bin/mytool), atau sebuah alias dari perintah, yang dijelaskan di
bawah.

Untuk memberitahu ke manusia atau mesin bahwa kode tersebut hasil generate,
sumber hasil generate seharusnya memiliki baris yang sesuai dengan _regular
expression_ (dalam sintaksis Go):

----
^// Code generated .* DO NOT EDIT\.$
----

Baris tersebut bisa muncul di mana pun dalam berkas Go, namun biasanya berada
di awal supaya mudah dicari.

Ingat bahwa go generate tidak mem-_parse_ berkas, sehingga baris-baris yang
mirip dengan _directive_ dalam komentar atau string akan dianggap sebagai
_directive_.

Argumen dari _directive_ adalah token yang dipisahkan oleh koma atau string
dengan kutip ganda yang dikirim sebagai sebuah argumen saat ia dijalankan.

String dengan tanda kutip menggunakan sintaksis Go dan dievaluasi sebelum
dieksekusi;
String dengan tanda kutip dianggap sebagai sebuah argumen oleh _generator_.

Go generate men-set beberapa variabel saat ia berjalan:

----
$GOARCH
	Arsitektur dari eksekusi (arm, amd64, dll.)
$GOOS
	Sistem operasi dari eksekusi (linux, windows, dll.)
$GOFILE
	Nama dari berkas.
$GOLINE
	Nomor baris dari directive dalam sumber kode
$GOPACKAGE
	Nama dari paket dari bekas yang berisi directive.
$DOLLAR
	Karaketer dolar.
----

Selain penggantian variabel dan evaluasi string berkutip, tidak ada lagi
pemrosesan khusus yang dilakukan, seperti "globbing", dalam baris perintah.

Sebagai langkah terakhir sebelum menjalankan perintah, pemanggilan variabel
lingkungan apa pun dengan nama alfa-numerik, seperti $GOFILE atau $HOME, akan
diganti lewat baris perintah.
Sintaksis dari penggatian variabel yaitu $NAME pada semua sistem operasi.
Dikarenakan urutan evaluasi, variabel diganti bahkan di dalam string berkutip.
Jika variabel NAME tidak diset, $NAME akan akan diganti dengan string kosong.

Sebuah _directive_ dengan bentuk,

----
//go:generate -command xxx args...
----

menspesifikasikan, untuk berkas itu saja, bahwa string xxx merepresentasikan
perintah yang diidentifikasi oleh argumennya.
Hal ini bisa digunakan untuk membuat alias atau menangani generator dengan
banyak kata.
Sebagai contohnya,

----
//go:generate -command foo go tool foo
----

menentukan bahwa perintah "foo" merepresentasikan "go tool foo".

Perintah generate memproses paket-paket dengan urutan sesuai dengan yang
diberikan pada baris perintah, satu per satu.
Jika baris perintah berisi berkas .go dari sebuah direktori, mereka akan
diperlakukan sebagai satu paket.
Dalam sebuah paket, generate memproses sumber berkas dalam paket berurutan
sesuai nama, satu per satu.
Dalam sebuah berkas, generate menjalankan generator dengan urutan kemunculan
dalam berkas, satu per satu.
Perkakas "go generate" juga men-set tag build "generate" sehingga
berkas-berkas bisa diperiksa oleh "go generate" namun diindahkan selama
pembangunan.

Jika salah satu generator berhenti karena eror, "go generate" melewati semua
pemrosesan selanjutnya untuk paket tersebut.

Si generator berjalan dalam sumber direktori paket.

Go generate menerima satu opsi khusus:

----
-run=""
	Jika tidak kosong, menspesifikasikan regular expression untuk memilih
	directive yang keseluruhan teksnya (kecuali spasi dan baris baru)
	cocok dengan ekspresi.
----

Go generate juga dapat menerima opsi "build" termasuk -v, -n, dan -x.
Opsi -v mencetak nama-nama paket dan berkas saat proses berjalan.
Opsi -n mencetak perintah yang akan dieksekusi.
Opsi -x mencetak perintah saat dieksekusi.

Untuk lebih lanjut tentang opsi "build", lihat 'go help build'.

Untuk lebih lanjut tentang cara menspesifikasikan paket, lihat 'go help
packages'.


[#hdr-Add_dependencies_to_current_module_and_install_them]
==  Tambah dan pasang dependensi ke modul yang sekarang

Penggunaan:

----
go get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]
----

Perintah "get" menambahkan dependensi ke modul pengembangan yang sekarang dan
kemudian membangun dan memasangnya.

Langkah pertama yaitu menyelesaikan dependensi apa yang ditambahkan.

Untuk setiap paket atau pola paket, "get" harus memutuskan versi mana dari
modul yang akan digunakan.
Secara baku, "get" mencari _tag_ dari versi rilis _tag_ yang terakhir, seperti
v0.4.5 atau v1.2.3.
Jika versi rilis tidak memiliki _tag_, "get" mencari versi _tag_ pra-rilis
yang terakhir, seperti v0.0.1-pre1.
Jika tidak ada versi _tag_ sama sekali, "get" mencari _commit_ terakhir.
Jika modul belum dibutuhkan (misalnya, pra-rilis lebih baru dan rilis
terakhir), "get" akan menggunakan versi yang dicarinya.
Selain itu, "get" akan menggunakan versi yang sekarang dibutuhkan.

Pemilihan versi ini dapat ditimpa dengan menambahkan sufiks @version pada
argumen paket, seperti 'go get golang.org/x/text@v0.3.0'.
Versi tersebut bisa berupa prefiks: @v1 berarti versi terakhir yang tersedia
mulai dari v1.
Lihat 'go help modules' pada 'Module queries' untuk sintaks keseluruhan.

Untuk modul yang disimpan dalam repositori dengan _version control system_
(sistem kontrol versi, atau disingkat VCS), sufiks di versi bisa berupa _hash_
dari _commit_, nama _branch_, atau sintaks lainnya yang dikenal oleh VCS
tersebut, seperti 'go get golang.org/x/text@master'.
Ingat bahwa nama _branch_ yang sama dengan sintaks _query_ modul tidak dapat
dipilih secara eksplisit.
Contohnya, sufiks @v2 artinya versi terakhir mulai dari v2, bukan _branch_
yang bernama v2.

Jika sebuah modul yang diinginkan sudah menjadi dependensi dari modul
pengembangan sekarang, maka "get" akan memperbarui versi yang dibutuhkan.
Menspesifikasikan sebuah versi yang lebih awal dari versi yang dibutuhkan
sekarang adalah valid dan akan men-_downgrade_ dependensi.
Versi dengan sufiks @none mengindikasikan bahwa dependensi harus dihapus
sepenuhnya, di-_downgrade_ atau menghapus modul yang bergantung kepadanya.

Versi dengan sufiks @latest secara eksplisit meminta rilis minor terakhir dari
modul yang diberikan pada path argumen.
Sufiks @upgrade seperti @latest namun tidak akan men-_downgrade_ modul jika ia
sudah dibutuhkan pada versi tertentu atau versi pra-rilis lebih baru dari pada
versi rilis terbaru.
Sufiks @patch meminta rilis _patch_ terbaru: versi rilis terbaru dengan angka
mayor dan minor yang sama dengan yang dibutuhkan sekarang.
Seperti halnya dengan @upgrade, @path tidak akan men-_downgrade_ sebuah modul
yang sudah dibutuhkan pada versi terbaru.
Jika path tertentu belum diperlukan, @upgrade dan @path sama dengan @latest.

Walaupun "get" secara bawaan menggunakan versi terakhir dari modul yang beris
nama paket, ia tidak menggunakan versi terakhir dari dependensi modul.
Namun ia menggunakan versi dependensi tertentu yang diminta oleh modul
tersebut.
Misalnya, jika A butuh modul B v1.2.3, sementara B v1.2.4 dan v1.3.1 juga
tersedia, maka 'go get A' akan menggunakan versi A yang terakhir namun
menggunakan B v1.2.3, seperti yang diminta oleh A.
(Jika ada kebutuhan yang saling bersaing untuk sebuah modul tertentu, 'go
get' menyelesaikan kebutuhan mereka dengan memilih versi maksimum yang
diminta.)

Opsi -t menyuruh 'get' supaya mengunduh modul-modul yang dibutuhkan untuk
pengujian paket yang dispesifikasikan pada baris perintah.

Opsi -u menyuruh 'get' untuk memperbarui modul-modul sebagai dependensi dari
nama paket pada baris perintah supaya menggunakan rilis minor atau patch
terbaru bila ada.
Melanjutkan contoh sebelumnya, 'go get -u A' akan menggunakan versi A yang
terakhir dengan B v1.3.1 (bukan B v1.2.3).
Jika B membutuhkan modul C, namun C tidak menyediakan paket apa pun yang
dibutuhkan untuk membangun paket di A, maka C tidak akan diperbarui.

Opsi -u=patch (bukan '-u patch') juga menyuruh 'get' untuk memperbarui
dependensi, namun dengan menggunakan rilis patch saja.
Melanjutkan contoh sebelumnya, 'go get -u=patch A@latest' akan menggunakan
versi A yang terakhir dengan B v1.2.4 (bukan B v1.2.3), namun untuk
'go get -u=patch A' akan menggunakan rilis patch dari A.

Bila opsi -t dan -u digunakan bersamaan, 'get' akan memperbarui dependensi tes
juga.

Pada umumnya, menambahkan dependensi baru membutuhkan pembaruan dependensi
yang ada supaya pembangunan dapat berjalan, dan 'go get' akan melakukan hal
ini secara otomatis.
Hal yang sama, menurunkan versi salah satu dependensi bisa jadi menurunkan
dependensi yang lain, dan 'go get' juga menangani ini secara otomatis.

Opsi -insecure membolehkan pengambilan dari repositori yang menggunakan skema
tidak aman seperti HTTP.
Gunakan dengan hati-hati.

Langkah kedua yaitu mengunduh (bila perlu), membangun, dan memasang paket yang
diminta.

Jika argumen berupa modul bukan paket (karena tidak ada sumber kode Go dalam
direktori akar dari modul), maka langkah pemasangan dilewati, bukan
menyebabkan gagal pembangunan.
Misalnya, 'go get golang.org/x/perf' akan sukses walaupun tidak ada kode di
dalam path impor tersebut.

Ingat bahwa pola paket dibolehkan dan dikembangkan setelah versi modul
diselesaikan.
Misalnya, 'go get golang.org/x/perf/cmd/...' menambahkan versi
'golang.org/x/perf' yang terakhir dan kemudian memasang perintah-perintah pada
versi yang terakhir juga.

Opsi -d membuat 'get' mengunduh kode yang dibutuhkan untuk membangun paket,
termasuk mengunduh dependensi yang dibutuhkan, namun tidak membangun dan
memasang mereka.

Tanpa ada argumen, 'go get' berlaku terhadap paket Go di direktori yang
sekarang, jika ada.
Terutama, 'go get -u' dan 'go get -u=patch' memperbarui semua dependensi dari
paket tersebut.
Jika tidak ada argumen paket dan juga tanpa -u, 'go get' hampir sama dengan
'go install', dan 'go get -d' hampir sama dengan 'go list'.

Untuk lebih tentang modul, lihat 'go help modules'.

Untuk lebih lanjut tentang argumen paket, lihat 'go help packages'.

Tulisan ini menjelaskan perilaku dari 'get' pada modul untuk mengatur kode dan
dependensi.
Jika perintah 'go' berjalan dalam mode GOPATH, opsi dari 'get' berubah,
sebagaimana juga 'go help get'.
Lihat 'go help modules' dan 'go help gopath-get'.

Lihat juga: go build, go install, go clean, go mod.


[##hdr-Compile_and_install_packages_and_dependencies]
==  Kompilasi dan pasang paket dan dependensi

Penggunaan:

----
go install [-i] [build flags] [packages]
----

Perintah 'install' mengompilasi dan memasang paket berdasarkan path impor.

Program _executable_ dipasang dalam direktori GOBIN dari variabel lingkungan,
yang bila kosong akan diset ke $GOPATH/bin atau $HOME/go/bin.
Program dalam $GOROOT dipasang di $GOROOT/bin atau $GOTOOLDIR bukan $GOBIN.

Jika mode modul tidak aktif, paket-paket lain dipasang dalam direktori
$GOPATH/pkg/$GOOS_$GOARCH.
Jika mode modul aktif, paket-paket dibangun dan di-_cache_ tapi tidak
dipasang.

Opsi -i memasang dependensi dari paket juga.

Untuk informasi lebih lanjut tentang opsi pembangunan, lihat 'go help build'.
Untuk informasi lebih lanjut tentang penamaan paket, lihat 'go help packages'.

Lihat juga: go build, go get, go clean.


[#hdr-List_packages_or_modules]
==  Cetak daftar paket atau modul

Penggunaan:

----
go list [-f format] [-json] [-m] [list flags] [build flags] [packages]
----

Perintah 'list' mencetak nama paket, per baris.
Opsi yang sering digunakan yaitu -f dan -json, yang mengatur pencetakan dari
setiap paket.
Opsi 'list' lainnya, mengontrol detail yang lebih khusus.

Keluaran bakunya mencetak path impor dari paket:

----
bytes
encoding/json
github.com/gorilla/mux
golang.org/x/net/html
----

Opsi -f menentukan format alternatif dari daftar tersebut, menggunakan
sintaksis dari templat paket.
Keluaran bakunya sama dengan -f '{{.ImportPath}}'.
Struct yang dikirim ke templat yaitu:

----
type Package struct {
    Dir           string   // direktori yang berisi sumber paket
    ImportPath    string   // path impor dari paket dalam direktori
    ImportComment string   // path dalam komentar impor di perintah 'package'
    Name          string   // nama paket
    Doc           string   // dokumentasi paket
    Target        string   // path pemasangan
    Shlib         string   // pustaka yang berisi paket ini (hanya di set saat -linkshared)
    Goroot        bool     // apakah paket ini ada di Go root?
    Standard      bool     // apakah paket ini bagian dari pustaka standar Go?
    Stale         bool     // apakah 'go install' melakukan sesuatu pada paket ini?
    StaleReason   string   // penjelasan untuk Stale==true
    Root          string   // direktori Go root atau Go path yang berisi paket ini
    ConflictDir   string   // direktori ini menutup direktori dalam $GOPATH
    BinaryOnly    bool     // paket yang binari saja (tidak lagi didukung)
    ForTest       string   // paket hanya digunakan pada tes
    Export        string   // berkas berisi data ekspor (saat menggunakan -export)
    Module        *Module  // info tentang paket berisi modul, jika ada (bisa nil)
    Match         []string // pola baris-perintah yang sesuai dengan paket ini
    DepOnly       bool     // paket ini hanya lah dependensi, tidak terdaftar secara eksplisit

    // Berkas-berkas sumber
    GoFiles         []string // berkas-berkas .go (kecuali CgoFiles, TestGoFiles, XTestGoFiles)
    CgoFiles        []string // berkas-berkas .go yang mengimpor "C"
    CompiledGoFiles []string // berkas-berkas .go yang diberikan ke compiler (bila menggunakan -compiled)
    IgnoredGoFiles  []string // berkas-berkas .go yang diindahkan karena batasan pembangunan
    CFiles          []string // berkas-berkas .c
    CXXFiles        []string // berkas-berkas .cc, .cxx and .cpp
    MFiles          []string // berkas-berkas .m
    HFiles          []string // berkas-berkas .h, .hh, .hpp and .hxx
    FFiles          []string // berkas-berkas .f, .F, .for dan .f90 Fortran
    SFiles          []string // berkas-berkas .s
    SwigFiles       []string // berkas-berkas .swig
    SwigCXXFiles    []string // berkas-berkas .swigcxx
    SysoFiles       []string // berkas-berkas objek .syso yang ditambahkan ke arsip
    TestGoFiles     []string // berkas-berkas _test.go dalam paket
    XTestGoFiles    []string // berkas-berkas _test.go di luar paket

    // Cgo directives
    CgoCFLAGS    []string // cgo: opsi untuk C compiler
    CgoCPPFLAGS  []string // cgo: opsi untuk C preprocessor
    CgoCXXFLAGS  []string // cgo: opsi untuk C++ compiler
    CgoFFLAGS    []string // cgo: opsi untuk Fortran compiler
    CgoLDFLAGS   []string // cgo: opsi untuk linker
    CgoPkgConfig []string // cgo: nama-nama pkg-config

    // Dependency information
    Imports      []string          // path impor yang digunakan oleh paket ini
    ImportMap    map[string]string // map dari impor ke ImportPath (identitas dihilangkan)
    Deps         []string          // semua (rekursif) dependensi yang diimpor
    TestImports  []string          // impor dari TestGoFiles
    XTestImports []string          // impor dari XTestGoFiles

    // Error information
    Incomplete bool            // paket ini atau dependensinya memiliki eror
    Error      *PackageError   // eror pada pemuatan paket
    DepsErrors []*PackageError // eror pada pemuatan dependensi
}
----

Paket yang disimpan dalam direktori vendor melaporkan ImportPath yang
mengikutkan path ke direktori vendor (misalnya, "d/vendor/p" bukan "p"),
sehingga ImportPath secara unik mengidentifikasi salinan dari sebuah paket.
Daftar pada Imports, Deps, TestImports, dan XTestImports juga berisi path
impor yang diperluas ini.
Lihat golang.org/s/go15vendor untuk lebih lanjut tentang "vendor".

Informasi eror, jika ada, yaitu

----
type PackageError struct {
    ImportStack   []string // path terpendek dari nama paket pada baris-perintah ke paket yang sekarang
    Pos           string   // posisi eror (jika ada, berkas:baris:kolom)
    Err           string   // eror itu sendiri
}
----

Informasi modul yaitu struct Module, didefinisikan dalam diskusi dari daftar
-m di bawah.

Fungsi templat "join" memanggil strings.Join.

Fungsi templat "context" mengembalikan context pembangunan, didefinisikan
sebagai:

----
type Context struct {
    GOARCH        string   // target arsitektur
    GOOS          string   // target sistem operasi
    GOROOT        string   // Go root
    GOPATH        string   // Go path
    CgoEnabled    bool     // apakah cgo dapat digunakan
    UseAllFiles   bool     // gunakan berkas, mengindahkan baris +build lines, nama berkas
    Compiler      string   // compiler yang digunakan untuk path target
    BuildTags     []string // batasan build sesuai baris +build
    ReleaseTags   []string // rilis yang sekarang tidak kompatibel
    InstallSuffix string   // sufiks yang digunakan dalam direktori pemasangan
}
----

Untuk informasi lebih lanjut tentang makna dari field-field tersebut lihat
dokumentasi paket go/build untuk tipe Context.

Opsi -json menyebabkan data paket dicetak dalam format JSON bukan menggunakan
format templat.

Opsi -compiled men-set CompiledGoFiles dengan berkas sumber Go yang diberikan
kepada _compiler_.
Biasanya hal ini berisi berkas dalam GoFiles dan juga menambahkan kode Go yang
dihasilkan dari pemrosesan CgoFiles dan SwigFiles.
Daftar impor berisi gabungan dari semua impor GoFiles dan CompiledGoFiles.

Opsi `-deps` membuat perintah "list" melakukan iterasi tidak hanya pada paket
tetapi juga semua dependensinya.
Semua dependensi dikunjungi secara _depth-first post-order_, sehingga paket
dicetak setelah semua dependensinya.
Paket-paket yang secara eksplisit tidak dicantumkan pada baris perintah akan
memiliki field `DepOnly` bernilai `true`.

Opsi `-e` mengubah penanganan paket-paket yang eror, yaitu paket yang tidak
bisa ditemukan atau salah format.
Secara baku, perintah "list" mencetak kesalahan untuk setiap paket dan
mengindahkan paket yang eror tersebut.
Dengan opsi `-e`, perintah "list" tidak akan mencetak kesalahan namun
memproses paket yang eror tersebut.
Paket yang eror akan memiliki isi pada field `ImportPath` dan `Error`;
informasi lainnya bisa saja kosong.

Opsi `-export` membuat field `Export` di-set dengan nama berkas yang berisi
informasi ekspor terbaru dari paket yang diberikan.

Opsi `-find` membuat perintah "list" mengidentifikasi paket tetapi tidak
mencari dependensinya: field `Imports` dan `Deps` akan kosong.

Opsi `-test` melaporkan tidak hanya nama paket namun juga program pengujiannya
(untuk paket-paket dengan tes), supaya perkakas analisis sumber kode tahu
bagaimana program test dibangun.
Path impor yang dilaporkan untuk sebuah program tes yaitu path import dari
paket diikuti oleh sufiks ".test", seperti "math/rand.test".
Saat membangun sebuah tes, terkadang perlu membangun ulang beberapa dependensi
khusus untuk tes (umumnya paket tes itu sendiri).
Path impor yang dilaporkan dari sebuah paket yang dikompilasi ulang untuk
sebuah program tes tertentu yaitu diikuti dengan sebuah spasi dan nama dari
program tes dalam tanda kurung siku, seperti "math/rand [math/rand.test]"
atau "regexp [sort.test]".
Field `ForTest` diisi dengan nama dari paket yang di tes ("math/rand" atau
"sort" pada contoh sebelumnya).

Path berkas pada `Dir`, `Target`, `Shlib`, `Root`, `ConflictDir`, dan `Export`
adalah path absolut.

Secara baku, daftar dalam `GoFiles`, `CgoFiles`, dan seterusnya berisi
nama-nama berkas dalam `Dir` (yaitu path yang relatif terhadap `Dir`, bukan
path absolut).
Berkas-berkas yang ditambah saat menggunakan opsi `-compiled` dan `-test`
adalah berupa path absolut yang mengacu ke salinan dari berkas sumber Go.
Walaupun mereka adalah sumber berkas Go, path mereka sendiri bisa saja tidak
diakhiri dengan ".go".

Opsi `-m` mencetak daftar modul bukan paket-paket.

Saat mencetak modul, opsi `-f` menentukan format templat yang diterapkan pada
sebuah Go struct, yaitu Module struct:

----
type Module struct {
    Path      string       // path modul
    Version   string       // versi modul
    Versions  []string     // versi modul yang tersedia (dengan -versions)
    Replace   *Module      // ditimpa oleh modul ini
    Time      *time.Time   // waktu saat versi dibuat
    Update    *Module      // update yang tersedia, jika ada (dengan -u)
    Main      bool         // apakah ini modul utama?
    Indirect  bool         // apakah modul ini dependensi tidak langsung dari
                           // modul utama?
    Dir       string       // direktori tempat modul berada, jika ada
    GoMod     string       // path ke berkas go.mod dari modul ini, jika ada
    GoVersion string       // versi Go yang digunakan oleh modul
    Error     *ModuleError // kesalahan yang terjadi saat memuat modul
}

type ModuleError struct {
    Err string // eror itu sendiri
}
----

Keluaran baku yaitu mencetak path modul dan informasi tentang versi dan
penggantinya jika ada.
Contohnya, 'go list -m all' mencetak:

----
my/main/module
golang.org/x/text v0.3.0 => /tmp/text
rsc.io/pdf v0.1.1
----

Struct `Module` memiliki method String yang membuat format baris keluaran di
atas, sehingga format baku sama dengan `-f '{{.String}}'`.

Ingatlah bahwa saat sebuah modul telah ditimpa, field `Replace` menjelaskan
modul yang menggantinya, dan field `Dir` diisi dengan sumber kode pengganti,
jika ada.
(Jika `Replace` tidak kosong, maka `Dir` diisi dengan `Replace.Dir`, tanpa
akses ke sumber kode yang menggantinya.)

Opsi `-u` menambahkan informasi tambahan tentang adanya pembaruan.
Bila versi terakhir dari sebuah modul lebih baru dari yang sekarang, opsi `-u`
men-set field `Update` dengan informasi tentang modul terbaru.
Method `String` pada `Module` mengindikasikan adanya pembaruan dengan mencetak
versi terbaru dalam tanda kurung siku setelah versi yang sekarang.
Misalnya, 'go list -m -u all' bisa mencetak:

----
my/main/module
golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text
rsc.io/pdf v0.1.1 [v0.1.2]
----

(Untuk perkakas luar, 'go list -m -u -json all' mungkin lebih mudah untuk
diurai.)

Opsi `-versions` men-set field `Version` pada `Module` dengan daftar semua
versi dari modul tersebut, diurut berdasarkan versi semantik, dari yang lama
ke yang terbaru.
Opsi ini mengubah format keluaran baku dengan menampilkan path modul diikuti
daftar versi yang dipisahkan oleh spasi.
Misalnya,
----
$ go list -m -versions github.com/shuLhan/share
go: finding versions for github.com/shuLhan/share
github.com/shuLhan/share v0.1.0 v0.2.0 v0.3.0 v0.4.0 v0.5.0 v0.6.0 v0.6.1
$
----

Argumen yang diberikan ke `-m` adalah daftar modul, bukan paket.
Modul utama yaitu modul yang berisi direktori sekarang.
Modul aktif adalah modul utama dan dependensinya.
Tanpa argumen, 'list -m' mencetak modul utama.
Dengan argumen, 'list -m' mencetak modul yang diberikan pada argumen.
Modul-modul yang aktif dapat dispesifikasikan dengan path modul mereka.
Pola khusus seperti "all" menentukan semua modul aktif, pertama modul utama
dan kemudian dependensinya diurut berdasarkan path modul.
Pola yang berisi "..." menentukan modul aktif yang path modul-nya cocok dengan
pola tersebut.
Kueri dengan format "path@version" menentukan hasil dari pencarian
tersebut, yang tidak dibatasi oleh modul aktif.
Lihat 'go help modules' untuk lebih tentang kueri modul.

Fungsi templat "module" menerima argumen sebuah string yang harus berupa path
modul atau kueri dan mengembalikan modul tertentu sebagai struct `Module`.
Jika terjadi kesalahan, hasilnya berupa struct `Module` dengan field `Error`
yang berisi.

Untuk lebih lanjut tentang opsi "build", lihat 'go help build'.

Untuk lebih lanjut tentang penentuan paket, lihat 'go help packages'.

Untuk lebih lanjut tentang modul, lihat 'go help modules'.

[#hdr-Module_maintenance]
==  Pemeliharaan modul

Perintah 'go mod' menyediakan akses terhadap operasi-operasi pada modul.

Ingatlah bahwa dukungan untuk modul tertanam pada semua perintah go, tidak
hanya 'go mod'.
Misalnya, penambahan, penghapusan, pembaruan, dan pemunduran dari dependensi
seharusnya dilakukan lewat 'go get'.
Lihat 'go help modules' untuk gambaran dari fungsionalitas modul.

Penggunaan:

----
go mod <command> [arguments]
----

Argumen "command" adalah:

----
download    unduh modul ke lokal cache
edit        sunting go.mod dengan perkakas atau skrip
graph       cetak dependensi modul
init        inisiasi modul baru di direktori sekarang
tidy        tambah modul yang hilang atau hapus modul yang tidak digunakan
vendor      salin semua dependensi ke direktori vendor
verify      verifikasi dependensi sesuai dengan yang diharapkan
why         jelaskan kenapa paket atau modul dibutuhkan
----

Gunakan "go help mod <command>" untuk informasi lebih lanjut tentang
perintah-perintah tersebut.


[#hdr-Download_modules_to_local_cache]
===  Unduh modul ke lokal _cache_

Penggunaan:

----
go mod download [-x] [-json] [modules]
----

Perintah "download" mengunduh modul sesuai argumen yang diberikan, yang bisa
dalam bentuk pola yang memilih dependensi dari modul utama atau kueri dalam
bentuk "path@version".
Jika argumen kosong, perintah "download" berlaku untuk semua dependensi dari
modul utama (sama dengan 'go mod download all').

Perintah go secara otomatis mengunduh modul yang dibutuhkan selama eksekusi.
Perintah "go mod download" biasa berguna untuk mengisi _cache_ di lokal atau
untuk mencari jawaban dari Go modul _proxy_

Secara bawaan, "download" tidak menulis apa pun ke layar.
Ia mungkin mencetak pesan kesalahan atau progres ke _standard error_.

Opsi `-json` membuat perintah "download" mencetak seurutan objek JSON ke
_standard output_, mendeskripsikan setiap modul yang diunduh (atau yang
gagal), sesuai dengan struct Go berikut

----
type Module struct {
	Path     string // path ke modul
	Version  string // versi modul
	Error    string // eror pemuatan modul
	Info     string // path absolut ke berkas .info dalam cache
	GoMod    string // path absolut ke berkas .mod dalam cache
	Zip      string // path absolut ke berkas .zip dalam cache
	Dir      string // path absolut ke direktori sumber dalam cache
	Sum      string // checksum untuk path, versi (seperti dalam go.sum)
	GoModSum string // checksum untuk go.mod (seperti dalam go.sum)
}
----

Opsi `-x` menyebabkan "download" mencetak perintah pengunduhan yang
dieksekusi.

Lihat `go help modules` untuk mengetahui lebih lanjut tentang pencarian modul.


[#hdr-Edit_go_mod_from_tools_or_scripts]
===  Sunting go.mod dengan perkakas atau skrip

Penggunaan:

----
go mod edit [editing flags] [go.mod]
----

Perintah "edit" menyediakan antarmuka baris-perintah untuk menyunting go.mod,
umumnya digunakan oleh perkakas atau skrip.
Ia hanya membaca go.mod;
tidak membaca informasi tentang dependensi modul-modul.
Secara bawaan, "edit" membaca dan menulis berkas "go.mod" dari modul utama,
namun berkas tujuan yang berbeda dapat diberikan sebagai argumen "edit".

Opsi-opsi pada "edit" menentukan seurutan operasi penyuntingan.

Opsi -fmt memformat ulang berkas go.mod tanpa membuat perubahan.
Pemformatan ulang ini biasanya dilakukan setelah melakukan perubahan yang
mengubah berkas go.mod.
Satu-satunya opsi ini diperlukan yaitu bila tidak ada lagi flag lain yang
diberikan, seperti 'go mod edit -fmt'.

Opsi -module mengubah path dari modul utama (baris "module" pada berkas
go.mod).

Opsi -require=path@version dan -droprequire=path menambah dan menghapus
dependensi dari modul dan versi yang diberikan.
Opsi -require akan menimpa dependensi yang sudah ada sesuai dengan path yang
diberikan.
Opsi ini umumnya untuk perkakas yang mengerti grafik modul.
Pengguna biasa seharusnya menggunakan 'go get path@version' atau
'go get path@none', yang membuat penyesuaian go.mod lainnya bila diperlukan
untuk memenuhi batasan-batasan yang diberikan oleh modul lainnya.

Opsi -exclude=path@version dan -dropexclude=path@version menambah dan
menghapus pengecualian dari path dan versi modul yang diberikan.
Opsi -exclude=path@version tidak melakukan operasi apa pun bila pengecualian
telah tercatat sebelumnya.

Opsi -replace=old[@v]=new[@v] menambah sebuah pengganti dari pasangan modul path dan
versi yang diberikan.
Jika @v dalam old@v tidak ada, penggantian tanpa versi pada bagian kiri
ditambahkan, yang berlaku untuk semua versi dari path modul old.
Jika @v dalam new@v tidak ada, path yang baru berarti direktori lokal dari
modul, bukan path dari modul.
Ingatlah bahwa -replace menimpa penggantian yang redundan untuk old[@v],
sehingga tanpa @v akan menghapus penggantian yang ada untuk versi tertentu.

Opsi -dropreplace=old[@v] menghapus sebuah penggantian dari pasangan path dan
versi modul yang diberikan.
Jika @v tidak ada, sebuah penggantian tanpa versi di bagian kiri akan dihapus.

Opsi -require, -droprequire, -exclude, -dropexclude, -replace, dan
-dropreplace bisa berulang, dan perubahan diterapkan sesuai dengan urutan yang
diberikan.

Opsi -go=version menset versi bahasa Go yang diinginkan.

Opsi -print mencetak berkas akhir dari go.mod dalam format teks bukan menulis
ke berkas.

Opsi -json mencetak berkas akhir dari go.mod dalam format JSON bukan menulis
ke berkas.
Keluaran dari JSON sesuai dengan tipe-tipe Go berikut:

----
type Module struct {
	Path string
	Version string
}

type GoMod struct {
	Module  Module
	Go      string
	Require []Require
	Exclude []Module
	Replace []Replace
}

type Require struct {
	Path string
	Version string
	Indirect bool
}

type Replace struct {
	Old Module
	New Module
}
----

Ingatlah bahwa ia hanya menjelaskan berkas go.mod itu sendiri, bukan
modul-modul lain yang diacu secara tidak langsung.
Untuk melihat seluruh modul yang digunakan pada saat "build", gunakan
'go list -m -json all'.

Sebagai contoh, sebuah perkakas bisa mengambil isi go.mod sebagai struktur
data dengan mengurai keluaran dari 'go mod edit -json' dan kemudian dapat
mengubahnya dengan memanggil 'go mod edit' dengan opsi -require, -exclude, dan
seterusnya.

[#hdr-Print_module_requirement_graph]
===   Cetak dependensi modul

Penggunaan:

----
go mod graph
----

Perintah "graph" mencetak grafik kebutuhan modul (dengan menerapkan
penggantian) dalam bentuk teks.
Setiap baris dari keluaran berisi dua kolom yang dibatasi dengan dua spasi:
nama modul dan satu atau lebih dependensinya.
Setiap modul diidentifikasi sebagai sebuah string dalam bentuk path@version,
kecuali untuk modul utama, tidak memiliki sufiks @version.

[#hdr-Initialize_new_module_in_current_directory]
===  Inisiasi modul baru di direktori sekarang

Penggunaan:

----
go mod init [module]
----

Perintah `init` menginisiasi dan menulis sebuah "go.mod" yang baru di
direktori yang sekarang, efeknya adalah sebuah modul baru dibuat di direktori
yang sama.
Berkas "go.mod" harus tidak ada sebelumnya.
Jika memungkinkan, `init` akan men-set path dari modul berdasarkan komentar
impor (lihat 'go help importpath') atau dari konfigurasi Version Control
System (VCS).
Untuk menimpa path modul, tambahkan path modul sebagai argumen pertama.

#hdr-Add_missing_and_remove_unused_modules
===  Tambah modul yang hilang atau hapus modul yang tidak digunakan

Penggunaan:

----
go mod tidy [-v]
----

Perintah `tidy` memastikan isi dari berkas go.mod sesuai dengan sumber kode
dalam modul.
Ia akan mencatat modul dependensi yang dibutuhkan supaya dapat membangun
paket-paket di dalam modul yang sekarang, dan menghapus dependensi modul yang
tidak digunakan.
Ia juga menambahkan catatan ke go.sum dan menghapus yang tidak dipergunakan
lagi.

Opsi -v menyebabkan `tidy` mencetak informasi tentang modul yang dihapus ke
__standard error__.


[#hdr-Make_vendored_copy_of_dependencies]
===   Salin semua dependensi ke direktori vendor

Penggunaan:

----
go mod vendor [-v]
----

Perintah `vendor` me-reset direktori "vendor" pada modul utama supaya
mengikutkan semua paket yang dibutuhkan untuk membangun dan menguji semua
paket-paket di modul utama.
Ia tidak mengikutkan berkas-berkas pengujian dari paket-paket yang
di-vendor-kan.

Opsi "-v" menyebabkan perintah "vendor" mencetak nama-nama dari modul dan
paket yang di-vendor-kan ke __standard error__.


[#hdr-Verify_dependencies_have_expected_content]
===  Verifikasi dependensi sesuai dengan yang diharapkan

Penggunaan:

----
go mod verify
----

Perintah `verify` memeriksa dependensi dari modul, yang disimpan dalam _cache_
di lokal, belum pernah dimodifikasi sejak diunduh.
Jika semua modul tidak pernah dimodifikasi, perintah `verify` mencetak
"all modules verified.", selain itu ia akan melaporkan modul-modul yang telah
berubah dan menyebabkan perintah 'go mod' keluar dengan status selain 0.


[##hdr-Explain_why_packages_or_modules_are_needed]
===  Jelaskan kenapa paket atau modul dibutuhkan

Penggunaan:

----
go mod why [-m] [-vendor] packages...
----

Perintah "why" memperlihatkan path terpendek dalam rangkaian impor dari modul
utama ke setiap paket pada parameter.
Jika opsi "-m" diberikan, perintah "why" menganggap argumen sebagai daftar
modul dan mencari sebuah path ke paket mana pun dalam setiap modul.

Secara baku, "why" mencari paket yang cocok dengan "go list all", yang
mengikutkan paket pengujian.
Opsi "-vendor" menyebabkan "why" mengindahkan dependensi pengujian.

Keluaran dari perintah ini yaitu seurutan stanza, setiap baris berisi nama
paket atau modul dari parameter yang diberikan pada baris perintah.
Setiap stanza dimulai dengan baris komentar "# paket" atau "# modul" sesuai
dengan target paket atau modul.
Baris selanjutnya mencetak sebuah path dari grafik impor, satu paket satu
baris.
Jika paket atau modul tidak diacu dari modul utama, maka stanza tersebut akan
menampilkan catatan dalam tanda kurung yang menyatakan alasannya.

Sebagai contohnya,

----
$ go mod why golang.org/x/text/language golang.org/x/text/encoding
# golang.org/x/text/language
rsc.io/quote
rsc.io/sampler
golang.org/x/text/language

# golang.org/x/text/encoding
(main module does not need package golang.org/x/text/encoding)
$
----


[#hdr-Compile_and_run_Go_program]
==   Kompilasi dan jalankan program Go

Penggunaan:

----
go run [build flags] [-exec xprog] package [arguments...]
----

Perintah "run" mengompilasi dan menjalankan paket Go bernama "main".
Biasanya paket tersebut ditentukan sebagai daftar berkas sumber .go dari
sebuah direktori, tetapi bisa juga dalam bentuk path impor, path dalam sistem
berkas, atau pola yang sesuai dengan sebuah paket, seperti 'go run .' atau
'go run my/cmd'.

Secara bawaan, 'go run' secara langsung menjalankan berkas binari hasil
kompilasi: 'a.out argumen...'.
Jika opsi "-exec" diberikan, 'go run' menjalankan berkas binari menggunakan
program "xprog":

----
'xprog a.out arguments...'.
----

Jika opsi "-exec" tidak diberikan, GOOS atau GOARCH berbeda dengan bawaan
sistem, dan sebuah program bernama go_$GOOS_$GOARCH_exec ditemukan ditemukan
dalam system PATH, 'go run' memanggil berkas binari menggunakan program
tersebut, misalnya 'go_js_wasm_exec a.out argumen...'.
Hal ini membolehkan eksekusi dari program yang dikompilasi silang
(__cross-compiled__) saat sebuah simulator atau metode eksekusi lain
tersedia.

Status keluaran dari perintah `run` bukanlah status keluaran dari berkas
binary hasil kompilasi.

Untuk informasi lebih lanjut tentang opsi-opsi pembangunan, lihat 'go help
build'.
Untuk informasi lebih lanjut tentang cara menspesifikasikan paket, lihat 'go
help packages'.

Lihat juga: go build.


[#hdr-Test_packages]
==  Menguji paket-paket

Penggunaan:

----
go test [build/test flags] [packages] [build/test flags & test binary flags]
----

Perintah 'go test' men- otomatisasi pengujian paket-paket berdasarkan nama
path impor.
Ia mencetak ringkasan dari hasil pengujian dalam format:

----
ok   archive/tar   0.011s
FAIL archive/zip   0.022s
ok   compress/gzip 0.033s
...
----

diikuti dengan rincian untuk setiap paket yang gagal (`FAIL`).

Perintah 'go test' meng-ompilasi ulang setiap paket bersama dengan semua
berkas yang sesuai dengan pola berkas "*_test.go".
Berkas-berkas tambahan ini bisa berisi fungsi-fungsi pengujian, __benchmark__,
dan contoh.
Lihat 'go help testfunc' untuk lebih lanjut.
Setiap paket yang didaftarkan menyebabkan eksekusi pengujian yang berbeda.
Nama berkas yang dimulai dengan "_" (termasuk "_test.go") atau "." akan
diindahkan.

Berkas-berkas uji yang memiliki nama paket dengan sufiks "_test" akan
dikompilasi sebagai paket yang terpisah, dan kemudian dihubungkan dan
dijalankan bersamaan dengan binari pengujian utama.

Perkakas go akan mengindahkan sebuah direktori bernama "testdata", membuatnya
tersedia sebagai tempat penyimpanan data yang dibutuhkan oleh pengujian.

Sebagai bagian dari pembangunan sebuah binari pengujian, 'go test' menjalankan
'go vet' terhadap paket yang diberikan dan berkas sumber ujinya untuk
mengidentifikasi permasalahan yang signifikan.
Jika 'go vet' menemukan masalah, 'go test' melaporkannya dan tidak akan
menjalankan binari pengujian.
Hanya sebagian dari perkakas 'go vet' yang digunakan, yaitu: 'atomic', 'bool',
'buildtags', 'errorsas', 'ifaceassert', 'nilfunc', 'printf', dan
'stringintconv'.
Anda bisa membaca dokumentasi dari setiap perkakas tersebut lewat "go doc
cmd/vet".
Untuk meniadakan eksekusi 'go vet', gunakan opsi "-vet=off".

Semua baris keluaran dan ringkasan pengujian dicetak ke __standard output__,
bahkan bila fungsi pengujian mencetaknya ke __standard error__-nya sendiri.
(__standard error__ dari perintah go disediakan hanya untuk mencetak eror saat
membangun binari pengujian.)

Perintah 'go test' berjalan dalam dua mode berbeda:

Yang pertama, disebut mode direktori lokal, terjadi saat 'go test' dipanggil
tanpa argumen paket (misalnya, 'go test' atau 'go test -v').
Dalam mode ini, 'go test' mengompilasi sumber kode dan tes paket yang
ditemukan dalam direktori yang sekarang dan kemudian menjalankan binari tes.
Dalam mode ini, tembolok (didiskusikan di bawah) di non-aktifkan.
Setelah pengujian paket selesai, "go test" mencetak baris ringkasan
memperlihatkan status pengujian ('ok' atau 'FAIL'), nama paket, dan waktu yang
dihabiskan.

Yang kedua, disebut mode daftar paket, terjadi saat "go test" dipanggil dengan
argumen paket (misalnya 'go test math', 'go test ./...', dan bahkan 'go test
.').
Dalam mode ini, "go test" mengompilasi dan menguji setiap paket yang diberikan
pada baris perintah.
Jika sebuah pengujian paket berhasil, "go test" hanya mencetak baris ringkasan
'ok'.
Jika pengujian paket gagal, "go test" mencetak semua keluaran pengujian.
Jika dipanggil dengan opsi "-bench" atau "-v", "go test" mencetak semua
keluaran bahkan untuk pengujian paket yang berhasil, dengan tujuan menampilkan
hasil __benchmark__ atau pencatatan.
Setelah pengujian semua paket selesai, dan hasilnya dicetak, "go test"
menampilkan status 'FAIL' jika salah satu pengujian paket gagal.

Pada mode daftar paket, "go test" menyimpan hasil pengujian paket yang
berhasil dalam sebuah tembolok untuk menghindari pengulangan pengujian yang
tidak penting.
Bila hasil dari sebuah pengujian dapat dipulihkan dari tembolok, "go test"
akan menampilkan ulang keluaran sebelumnya bukan menjalankan binari pengujian
kembali.
Bila ini terjadi, "go test" mencetak '(cached)' sebagai pengganti waktu pada
baris ringkasan.

Aturan dari penggunaan tembolok yaitu pengujian dijalankan mengikutkan binari
pengujian yang sama dan opsi-opsi pada baris perintah menggunakan sekumpulan
opsi yang dapat di-__cache__, yaitu -cpu, -list, -parallel, -run, -short, dan
-v.
Jika "go test" dijalankan dengan opsi selain dari sekumpulan opsi tersebut,
maka hasilnya tidak akan di-__cache__.
Untuk menonaktifkan __caching__ pengujian, gunakan opsi pengujian atau argumen
selain opsi-opsi yang dapat di-__cache__.
Cara idiomatis untuk menonaktifkan __cache__ pengujian secara eksplisit yaitu
menggunakan -count=1.
Tes-test yang membuka berkas dalam sumber paket (biasanya $GOPATH) atau yang
membaca variabel lingkungan akan selalu berjalan sama selama berkas dan
variabel lingkungan tidak berubah.
Sebuah hasil pengujian yang di-__cache__ dianggap dieksekusi tanpa memakan
waktu sama sekali, sehingga sebuah hasil tes yang sukses akan di-__cache__ dan
digunakan ulang dengan mengindahkan pengaturan -timeout.

Selain opsi-opsi "build", opsi-opsi yang ditangani oleh 'go test' itu sendiri
diantaranya:

----
-args
    Kirim sisa baris perintah (semua argumen setelah -args) ke binari tes,
    tanpa diinterpretasi dan tidak diubah.
    Secara opsi ini mengonsumsi sisa dari baris perintah, daftar paket (jika
    ada) harus muncul sebelum opsi ini.

-c
    Kompilasi binari tes ke "pkg.test" namun jangan jalankan (yang mana "pkg"
    adalah elemen terakhir dari path impor paket).
    Nama berkas dapat diubah lewat opsi -o.

-exec xprog
    Jalankan binari tes menggunakan xprog.  Perilaku ini sama dengan 'go run'.
    Lihat 'go help run' untuk lebih jelas.

-i
    Pasang paket-paket dependensi dari tes.
    Jangan jalankan tes.

-json
    Konversi hasil tes ke JSON yang cocok untuk pemrosesan otomatis.
    Lihat 'go doc test2json' untuk rincian format.

-o berkas
    Kompilasi binari tes ke berkas.
    Tes masih tetap dijalankan (kecuali -c atau -i diberikan).
----

Binari tes juga menerima opsi yang mengontrol eksekusi dari tes; opsi-opsi
tersebut juga dapat diakses oleh 'go test'.  Lihat 'go help testflag' untuk
lebih rinci.

Untuk lebih lanjut tentang opsi "build", lihat 'go help build'.
Untuk lebih lanjut tentang cara menspesifikasikan paket, lihat 'go help
packages'.

Lihat juga: go build, go vet.


[#hdr-Run_specified_go_tool]
==  Jalankan perkakas go tertentu

Penggunaan:

----
go tool [-n] perintah [args...]
----

Perintah 'tool' menjalankan perintah yang diidentifikasi oleh
argumen-argumennya.
Bila argumen tidak diberikan, ia akan mencetak daftar perintah yang dikenal
oleh 'tool'.

Opsi -n menyebabkan 'tool' mencetak perintah yang akan dieksekusi tetapi tidak
mengeksekusinya.

Untuk informasi lebih lanjut tentang setiap perintah pada 'tool', lihat
'go doc cmd/<perintah>'.


[#hdr-Print_Go_version]
==  Cetak versi Go

Penggunaan:

----
go version [-m] [-v] [file ...]
----

Perintah 'version' mencetak informasi pembangunan dari hasil binari Go.

Perintah 'go version' melaporkan versi Go yang digunakan untuk membangun
setiap nama berkas binari yang diberikan pada baris perintah.

Jika tidak ada berkas yang diberikan, 'go version' akan mencetak informasi
versi dirinya sendiri.

Jika sebuah direktori diberikan, 'go version' menelusuri direktori tersebut
secara rekursif, mencari hasil binari-binari Go yang dikenal dan melaporkan
versi mereka masing-masing.
Secara bawaan, 'go version' tidak melaporkan berkas-berkas yang tidak dikenal
yang ditemukan selama pemindaian direktori.
Opsi -v melaporkan berkas-berkas yang tidak dikenal tersebut.

Opsi -m menyebabkan 'go version' mencetak informasi versi modul yang tertanam
dalam binari, bila ada.
Keluarannya yaitu informasi modul yang berisi beberapa baris diikuti oleh
versi, yang dipisahkan oleh karakter tab.

Lihat juga: go doc runtime/debug.BuildInfo.
