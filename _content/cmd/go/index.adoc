=  Perintah go
:toc:
:sectanchors:
:sectlinks:

Go adalah sebuah perkakas untuk mengatur sumber kode Go.

Penggunaan:

----
go <perintah> [argumen]
----

Perintah-perintahnya adalah:

----
bug         jalankan pelaporan bug
build       kompilasi paket dan dependensi
clean       hapus berkas hasil build dan cache
doc         tampilkan dokumentasi dari paket atau simbol
env         cetak informasi lingkungan dari Go
fix         ubah paket untuk menggunakan API yang baru
fmt         gofmt (format ulang) sumber paket
generate    buat berkas Go dengan memproses sumber
get         tambah dan pasang dependensi ke modul yang sekarang
install     kompilasi dan pasang paket dan dependensi
list        cetak daftar paket atau modul
mod         pemeliharaan modul
run         kompilasi dan jalankan program Go
test        tes paket
tool        jalankan perkakas go tertentu
version     cetak versi Go
vet         laporkan kemungkinan kesalahan dalam paket
----

Gunakan "go help <perintah>" untuk informasi tentang perintah.

Beberapa topik bantuan tambahan:

----
buildconstraint batasan-batasan dari build
buildmode       mode-mode dari build
c               pemanggilan antara Go dan C
cache           cache pada pembangunan dan tes
environment     variabel-variabel lingkungan
filetype        tipe-tipe berkas
go.mod          berkas go.mod
gopath          variabel lingkungan GOPATH
gopath-get      legasi GOPATH menggunakan go get
goproxy         protokol proxy pada modul
importpath      sintaksis untuk path impor
modules         modul, versi modul, dan banyak lagi
module-get      go get dengan menggunakan modul
module-auth     autentikasi modul menggunakan go.sum
module-private  konfigurasi modul untuk modul yang tidak publik
packages        daftar dan pola paket
testflag        opsi-opsi untuk tes
testfunc        fungsi-fungsi untuk tes
----

Gunakan "go help <topik>" untuk informasi lanjut tentang topik tersebut.

[#hdr-Start_a_bug_report]
==  Jalankan pelaporan bug

Penggunaan:

----
go bug
----

Perintah `bug` membuka peramban dan menjalankan laporan _bug_ yang baru.
Laporan tersebut mengikutkan informasi sistem.


[#hdr-Compile_packages_and_dependencies]
==  Kompilasi paket-paket dan dependensi

Penggunaan:

----
go build [-o output] [-i] [flag build] [paket]
----

Perintah `build` kompilasi paket-paket berdasarkan nama dari path import,
bersama dengan dependensinya, namun tidak memasang hasilnya.

Jika argumennya adalah daftar berkas .go dari sebuah direktori, maka `build`
menganggapnya sebagai daftar berkas sumber dari paket yang sama.

Saat mengompilasi paket, `build` mengindahkan berkas yang berakhiran
`_test.go`.

Saat mengompilasi paket main, `build` menulis hasil program ke sebuah berkas
yang namanya diambil dari berkas sumber pertama (`go build ed.go rx.go`
menulis `ed` atau `ed.exe`) atau direktori sumber kode
(`go build unix/sam` menulis `sam` atau `sam.exe`).
Akhiran '.exe' ditambahkan bila menulis program untuk Windows.

Saat mengompilasi beberapa paket atau paket yang bukan `main`, `build`
mengompilasi paket-paket tersebut namun mengindahkan objek hasilnya,
cara ini untuk memeriksa bahwa paket dapat dibangun.

Opsi "-o" memaksa `build` untuk menulis hasil program atau objek dengan nama
atau direktori yang diberikan, bukan dengan perilaku seperti yang dijelaskan
pada dua paragraf sebelumnya.
Jika nama keluaran adalah direktori yang sudah ada, maka hasil program akan
ditulis di dalam direktori tersebut.

Opsi "-i" memasang paket-paket dependensi dari target.

Opsi-opsi dari `build` berikut dapat digunakan pada perintah `clean`, `get`,
`install`, `list`, `run`, dan `test`:

----
-a
	buat ulang semua paket bahkan yang sudah terbarukan.
-n
	cetak perintah-perintah tetapi jangan jalankan.
-p n
	jumlah program, seperti perintah build atau test, yang dapat berjalan
	secara paralel.
	Nilai baku dari n yaitu jumlah CPU yang tersedia.
-race
	izinkan deteksi data race.
	Hanya didukung pada linux/amd64, freebsd/amd64, darwin/amd64,
	windows/amd64, linux/ppc64le, dan linux/arm64 (hanya untuk 48-bit
	VMA).
-msan
	izinkan operasi dengan pembersih memory.
	Hanya didukung pada linux/amd64, linux/arm64 dan hanya lewat
	Clang/LLVM sebagai compiler C.
	Pada linux/arm64, mode build "pie" akan digunakan.
-v
	cetak nama-nama paket saat mereka dikompilasi.
-work
	cetak nama dari direktori sementara dan jangan hapus saat selesai.
-x
	cetak perintah-perintah.

-asmflags '[pattern=]arg list'
	argumen yang dikirim ke setiap pemanggilan `go tool asm`.
-buildmode mode
	mode pembangunan yang akan digunakan.  Lihat 'go help buildmode' untuk
	lebih lanjut.
-compiler name
	nama compiler yang akan digunakan, seperti dalam runtime.Compiler
	(gccgo atau gc).
-gccgoflags '[pattern=]arg list'
	argumen yang akan dikirim setiap pemanggilan compiler/linker gccgo.
-gcflags '[pattern=]arg list'
	argumen yang akan dikirim setiap pemanggilan "go tool compile"
-installsuffix suffix
	Sufiks yang digunakan sebagai nama direktori pemasangan paket, dengan
	tujuan untuk menjaga keluaran terpisah dengan pembangunan biasa.
	Jika menggunakan opsi -race, maka akhiran pada pemasangan secara
	otomatis di set ke race atau, jika di set secara eksplisit, akan
	ditambahkan _race.
	Hal yang sama juga berlaku pada opsi -msan.
	Menggunakan opsi -buildmode yang membutuhkan opsi-opsi yang tidak
	biasa akan mendapatkan efek yang sama.
-ldflags '[pattern=]arg list'
	argumen yang akan dikirim ke setiap pemanggilan "go tool link"
-linkshared
	link dengan pustaka yang dibuat sebelumnya dengan -buildmode=shared.
-mod mode
	mode pengunduhan modul yang digunakan: readonly atau vendor.
	Lihat 'go help modules' untuk lebih lanjut.
-modcacherw
	direktori yang baru dibuat dalam modul _cache_ akan di set read-write
	bukan read-only
.-pkgdir dir
	pasang dan muat semua paket dari "dir" sebagai ganti dari lokasi
	biasa.
	Contohnya, saat membangun dengan konfigurasi non-standar, gunakan
	-pkgdir untuk menghasilkan paket di lokasi yang berbeda.
-tags tag,list
	daftar tag dari build yang terpisah dengan koma yang akan dipenuhi
	selama pembangunan.
	Untuk informasi lebih lanjut tentang build tag, lihat deskripsi dari
	batasan-batasan build dalam dokumentasi untuk paket go/build.
	(Versi dahulu dari Go menggunakan daftar yang terpisah dengan spasi,
	dan bentuk tersebut sudah tidak digunakan lagi namun masih tetap
	dikenali.
-trimpath
	hapus semua path-path sistem dari hasil program.
	Nama berkas yang tercatat akan dimulai dengan "go" (untuk pustaka
	standar), atau modul path@version (bila menggunakan modul), atau path
	import biasa (bila menggunakan GOPATH).
-toolexec 'cmd args'
	program yang digunakan untuk memanggil program toolchain seperti vet
	dan asm.
	Misalnya, alih-alih menjalankan asm, perintah go akan menjalankan
	'cmd args /path/to/asm <argumen untuk asm>'.
----

Opsi -asmflags, -gccgoflags, -gcflags, dan -ldflags menerima daftar argumen
yang dipisahkan oleh spasi untuk dikirim ke perkakas yang dijalankan
dibelakangnya selama pembangunan.
Untuk menambah spasi dalam elemen dalam daftar tersebut, kurung dengan tanda
kutip tunggal atau ganda.
Daftar argumen bisa diawali dengan sebuah pola paket dan tanda sama dengan
("="), yang membatasi penggunaan dari daftar argumen tersebut ke pembangunan
paket-paket yang cocok dengan pola (lihat 'go help packages' untuk deskripsi
dari pola paket).
Tanpa pola, daftar argumen hanya berlaku untuk paket yang diberikan pada
perintah baris.
Opsi-opsi tersebut bisa berulang dengan pola yang berbeda dengan tujuan untuk
menentukan argumen yang berbeda untuk sekumpulan paket.
Jika sebuah pola pencocokan paket diberikan dalam beberapa opsi, kecocokan
yang terakhir akan digunakan.
Sebagai contohnya, 'go build -gcflags=-S fmt' mencetak _disassembly_ hanya
untuk paket fmt, sementara 'go build -gcflags=all=-S fmt' mencetak
_disassembly_ untuk fmt dan semua dependensinya.

Untuk lebih tahu tentang cara menspesifikasikan paket, lihat 'go help
packages'.
Untuk mengetahui lebih lanjut tentang di mana paket dan program dipasang,
jalankan 'go help gopath'.
Untuk mengetahui lebih lanjut tentang pemanggilan antara Go dan C/C++,
jalankan 'go help c'.

Catatan: Perintah `build` mengikuti beberapa konvensi seperti yang dijelaskan
oleh 'go help gopath'.
Tidak semua proyek dapat mengikuti konvensi tersebut.
Pemasangan yang memiliki konvensinya sendiri atau yang menggunakan sistem
pembangunan perangkat lunak yang terpisah bisa memilih untuk menggunakan
pemanggilan tingkat-rendah seperti 'go tool compile' dan 'go tool link' untuk
menghindari beberapa beban dan rancangan dari perkakas build.

Lihat juga: go install, go get, go clean.


[#hdr-Remove_object_files_and_cached_files]
==  Hapus berkas-berkas objek dan _cache_

Penggunaan:

----
go clean [clean flags] [build flags] [packages]
----

Perintah `clean` menghapus berkas objek dari direktori sumber paket.
Perintah go menulis objek dalam sebuah direktori sementara, sehingga
'go clean' biasanya berguna untuk berkas objek sisa dari perkakas lain atau
dari pemanggilan manual dari go build.

Jika argumen sebuah paket diberikan atau opsi -i atau -r di set, `clean`
menghapus berkas-berkas berikut dari setiap direktori sumber yang
berkorespondensi dengan path impor:

----
_obj/            direktori objek yang lama, sisa dari Makefiles
_test/           direktori tes yang lama, sisa dari Makefiles
_testmain.go     berkas gotest lama, sisa dari Makefiles
test.out         log tes lama, sisa dari Makefiles
build.out        log tes lama, sisa dari Makefiles
*.[568ao]        berkas object, sisa dari Makefiles

DIR(.exe)        dari go build
DIR.test(.exe)   dari go test -c
MAINFILE(.exe)   dari go build MAINFILE.go
*.so             dari SWIG
----

Dalam daftar tersebut, DIR merepresentasikan elemen path terakhir dari
direktori, dan MAINFILE adalah nama dasar dari sumber kode Go dalam direktori
tersebut yang tidak diikutkan saat membangun paket.

Opsi -i membuat perintah `clean` untuk menghapus arsip dan binary yang
terpasang (yang dibuat oleh 'go install').

Opsi -n membuat perintah `clean` untuk mencetak perintah penghapusan yang
akan dieksekusi, namun tidak menjalankannya.

Opsi -r membuat perintah `clean` menerapkan secara rekursif ke semua
dependensi dari paket dari path impor.

Opsi -x membuat perintah `clean` mencetak perintah penghapus saat ia
dieksekusi.

Opsi -cache membuat `clean` menghapus semua _cache_ dari go build.

Opsi -testcache menyuruh supaya `clean` untuk kedaluwarsa semua hasil tes
dalam _cache_ go build.

Opsi -modcache menyebabkan `clean` menghapus semua _cache_ unduhan modul
termasuk sumber kode dari dependensi yang memiliki versi.

Untuk lebih lanjut tentang opsi build, lihat 'go help build'.

Untuk lebih lanjut tentang menentukan paket, lihat 'go help packages'.


[#hdr-Show_documentation_for_package_or_symbol]
==  Tampilkan dokumentasi dari paket atau simbol

Penggunaan:

----
go doc [-u] [-c] [package|[package.]symbol[.methodOrField]]
----

Perintah `doc` mencetak komentar dokumentasi yang berasosiasi dengan item yang
diidentifikasi lewat argumen-argumen (sebuah paket, const, func, type, var,
method, atau field dari struct) diikuti dengan sebuah ringkasan satu-baris
dari setiap item tingkat-pertama "di bawah" item tersebut (deklarasi
tingkat-paket untuk sebuah paket, method untuk sebuah tipe, dan seterusnya.).

Perintah `doc` menerima argumen kosong, satu, atau dua.

Bila argumen tidak ada, yaitu, bila dijalankan seperti

----
go doc
----

ia akan mencetak dokumentasi paket dalam direktori yang sekarang.
Jika paket adalah sebuah program (package main), simbol-simbol yang diekspor
oleh paket tidak ditampilkan kecuali bila opsi -cmd diberikan.

Bila dijalankan dengan satu argumen, maka argumen tersebut dianggap sebagai
representasi mirip sintaksis Go dari item yang didokumentasikan.
Apa yang argumen pilih bergantung pada apa yang dipasang dalam GOROOT dan
GOPATH, sebagaimana juga bentuk dari argumen, yang secara semantik adalah satu
dari hal berikut:

----
go doc <pkg>
go doc <sym>[.<methodOrField>]
go doc [<pkg>.]<sym>[.<methodOrField>]
go doc [<pkg>.][<sym>.]<methodOrField>
----

Item pertama dalam daftar di atas yang sesuai dengan argumen akan dicetak
dokumentasinya.
(Lihat contoh di bawah).
Namun jika argumen dimulai dengan huruf besar maka diasumsikan sebagai simbol
atau method dari direktori yang sekarang.

Untuk paket, urutan pencarian ditentukan secara leksikal dengan cara
_breadth-first order_.
Yaitu, paket yang ditampilkan adalah yang cocok dengan pencarian dan terdekat
dengan root dan yang pertama secara leksikal di tingkat hirarkinya.
Pohon GOROOT selalu dicari pertama kali sebelum GOPATH.

Jika tidak ada paket yang diberikan atau cocok, maka paket di direktori
sekarang yang dipilih, sehingga "go doc Foo" memperlihatkan dokumentasi untuk
simbol Foo dalam paket yang sekarang.

Path dari paket bisa secara penuh atau cukup sufiks dari path saja.
Mekanisme umum dari go tool tidak berlaku: elemen path paket seperti . dan ...
tidak diimplementasikan oleh `go doc`.

Bila dijalankan dengan dua argumen, yang pertama haruslah path penuh dari
paket (tidak hanya sufiks saja), dan yang kedua adalah simbol, atau simbol
dengan method atau field struct.
Hal ini sama dengan sintaksis yang diterima oleh godoc:

----
go doc <pkg> <sym>[.<methodOrField>]
----

Dalam semua bentuk, saat mencocokan simbol, huruf kecil dalam argumen
menyesuaikan dengan huruf kecil atau besar namun huruf besar dicocokan persis.
Hal ini berarti akan ada beberapa kecocokan dari argumen dengan huruf kecil
dalam sebuah paket jika simbol yang berbeda memiliki huruf yang berbeda.
Jika hal ini terjadi, dokumentasi untuk semua kecocokan dicetak.

Contoh:

----
go doc
	Tampilkan dokumentasi dari paket yang sekarang.
go doc Foo
	Tampilkan dokumentasi dari Foo dalam paket sekarang.
	(Foo dimulai dengan huruf besar sehingga tidak sesuai dengan path
	paket.)
go doc encoding/json
	Tampilkan dokumentasi dari paket encoding/json.
go doc json
	Cara cepat untuk encoding/json.
go doc json.Number (or go doc json.number)
	Tampilkan dokumentasi dan ringkasan method untuk json.Number.
go doc json.Number.Int64 (or go doc json.number.int64)
	Tampilkan dokumentasi untuk method json.Number Int64.
go doc cmd/doc
	Tampilkan dokumentasi paket untuk perintah doc.
go doc -cmd cmd/doc
	Tampilkan dokumentasi dan simbol-simbol yang diekspor dalam perintah
	doc.
go doc template.new
	Tampilkan dokumentasi untuk fungsi html/template New.
	(html/template secara leksikal sebelum text/template).
go doc text/template.new # Satu argumen
	Tampilkan dokumentasi untuk fungsi text/template New.
go doc text/template new # Dua argumen
	Tampilkan dokumentasi untuk fungsi text/template New.

Paling tidak, pemanggilan berikut mencetak dokumentasi untuk method
json.Decoder Decode:

go doc json.Decoder.Decode
go doc json.decoder.decode
go doc json.decode
cd go/src/encoding/json; go doc decode
----

Opsi-opsi:

----
-all
	Tampilkan semua dokumentasi dari paket.
-c
	Perhatikan huruf besar/kecil saat mencari simbol.
-cmd
	Perlakukan sebuah perintah (paket main) seperti paket biasa.
	Sebaliknya simbol-simbol yang diekspor paket main disembunyikan saat
	menampilkan dokumentasi paket tingkat-atas.
-short
	Tampilkan satu-baris representasi untuk setiap simbol.
-src
	Tampilkan keseluruhan sumber kode dari simbol.  Cara ini
	memperlihatkan seluruh sumber Go dari deklarasi dan definisi, seperti
	sebuah definisi fungsi (termasuk badannya), deklarasi tipe atau blok
	const.  Keluarannya bisa mengikutkan detail yang tidak diekspor.
-u
	Tampilkan dokumentasi untuk simbol, method, field yang tidak diekspor
	dan yang diekspor.
----


[#hdr-Print_Go_environment_information]
==  Cetak informasi lingkungan dari Go

Penggunaan:

----
go env [-json] [-u] [-w] [var ...]
----

Perintah `env` mencetak informasi lingkungan Go.

Secara baku env mencetak informasi sebagai skrip _shell_ (pada Windows, sebuah
berkas _batch_).
Jika satu atau lebih variabel diberikan sebagai argumen, env mencetak nilai
dari setiap variabel per baris.

Opsi -json mencetak nilai variabel dalam format JSON.

Opsi -u membutuhkan satu atau lebih argumen dan akan menghapus pengaturan baku
dari variabel lingkungan tersebut, jika sebelumnya telah diset dengan
'go env -w'.

Opsi -w membutuhkan satu atau lebih argumen dengan bentuk NAME=VALUE dan
mengubah pengaturan baku dari variabel lingkungan yang diberikan sesuai dengan
nilainya.

Untuk lebih lanjut tentang variabel lingkungan, lihat 'go help environment'.


[#hdr-Update_packages_to_use_new_APIs]
==  Ubah paket untuk menggunakan API yang baru

Penggunaan:

----
go fix [packages]
----

Perintah `fix` menjalankan perintah perbaikan Go terhadap nama paket-paket
yang diberikan lewat path impor.

Untuk lebih lanjut tentang fix, lihat 'go doc cmd/fix'.
Untuk lebih lanjut tentang argumen paket, lihat 'go help packages'.

Untuk menjalankan fix dengan opsi-opsi tertentu, jalankan 'go tool fix'.

Lihat juga: go fmt, go vet.


[#hdr-Gofmt__reformat__package_sources]
==  Gofmt (format ulang) sumber-sumber paket

Penggunaan:

----
go fmt [-n] [-x] [packages]
----

Fmt menjalankan program 'gofmt -l -w' pada paket-paket berdasarkan nama dari
path import.
Ia akan mencetak nama berkas yang diubah.

Untuk informasi lebih lanjut tentang gofmt, lihat 'go doc cmd/gofmt'.
Untuk informasi tentang menentukan paket, lihat 'go help packages'.

Opsi -n mencetak perintah yang akan dieksekusi.
Opsi -x mencetak perintah saat dieksekusi.

Opsi -mod menset mode unduhan yang akan digunakan: baca-saja atau vendor.
Lihat 'go help modules' untuk lebih lanjut.

Untuk menjalankan gofmt dengan opsi tertentu, jalankan gofmt itu sendiri.

Lihat juga: go fix, go vet.


[#hdr-Generate_Go_files_by_processing_source]
==  Buat berkas Go dengan memproses sumber

Penggunaan:

----
go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
----

Generate menjalankan perintah yang dijelaskan oleh petunjuk dalam berkas.
Perintah tersebut dapat menjalankan proses apa saja namun tujuannya yaitu
membuat atau memperbarui sumber berkas Go.

Go generate tidak pernah dijalankan secara otomatis oleh go build, go get, go
test, and seterusnya.
Ia harus dijalankan secara eksplisit.

Go generate memindai petunjuk dalam berkas, yang berupa baris dalam bentuk,

----
//go:generate perintah argumen...
----

(catatan: tidak ada spasi awal dan spasi dalam "//go") yang mana "perintah"
adalah generator yang akan dijalankan, yang berkorespondensi dengan nama
berkas program yang dapat dijalankan di lokal.
Program tersebut harus ada dalam PATH dari _shell_, path penuh
(/usr/you/bin/mytool), atau sebuah alias dari perintah, yang dijelaskan di
bawah.

Untuk memberitahu ke manusia atau mesin bahwa kode tersebut hasil generate,
sumber hasil generate seharusnya memiliki baris yang sesuai dengan _regular
expression_ (dalam sintaksis Go):

----
^// Code generated .* DO NOT EDIT\.$
----

Baris tersebut bisa muncul di mana pun dalam berkas Go, namun biasanya berada
di awal supaya mudah dicari.

Ingat bahwa go generate tidak mem-_parse_ berkas, sehingga baris-baris yang
mirip dengan _directive_ dalam komentar atau string akan dianggap sebagai
_directive_.

Argumen dari _directive_ adalah token yang dipisahkan oleh koma atau string
dengan kutip ganda yang dikirim sebagai sebuah argumen saat ia dijalankan.

String dengan tanda kutip menggunakan sintaksis Go dan dievaluasi sebelum
dieksekusi;
String dengan tanda kutip dianggap sebagai sebuah argumen oleh _generator_.

Go generate men-set beberapa variabel saat ia berjalan:

----
$GOARCH
	Arsitektur dari eksekusi (arm, amd64, dll.)
$GOOS
	Sistem operasi dari eksekusi (linux, windows, dll.)
$GOFILE
	Nama dari berkas.
$GOLINE
	Nomor baris dari directive dalam sumber kode
$GOPACKAGE
	Nama dari paket dari bekas yang berisi directive.
$DOLLAR
	Karaketer dolar.
----

Selain penggantian variabel dan evaluasi string berkutip, tidak ada lagi
pemrosesan khusus yang dilakukan, seperti "globbing", dalam baris perintah.

Sebagai langkah terakhir sebelum menjalankan perintah, pemanggilan variabel
lingkungan apa pun dengan nama alfa-numerik, seperti $GOFILE atau $HOME, akan
diganti lewat baris perintah.
Sintaksis dari penggatian variabel yaitu $NAME pada semua sistem operasi.
Dikarenakan urutan evaluasi, variabel diganti bahkan di dalam string berkutip.
Jika variabel NAME tidak diset, $NAME akan akan diganti dengan string kosong.

Sebuah _directive_ dengan bentuk,

----
//go:generate -command xxx args...
----

menspesifikasikan, untuk berkas itu saja, bahwa string xxx merepresentasikan
perintah yang diidentifikasi oleh argumennya.
Hal ini bisa digunakan untuk membuat alias atau menangani generator dengan
banyak kata.
Sebagai contohnya,

----
//go:generate -command foo go tool foo
----

menentukan bahwa perintah "foo" merepresentasikan "go tool foo".

Perintah generate memproses paket-paket dengan urutan sesuai dengan yang
diberikan pada baris perintah, satu per satu.
Jika baris perintah berisi berkas .go dari sebuah direktori, mereka akan
diperlakukan sebagai satu paket.
Dalam sebuah paket, generate memproses sumber berkas dalam paket berurutan
sesuai nama, satu per satu.
Dalam sebuah berkas, generate menjalankan generator dengan urutan kemunculan
dalam berkas, satu per satu.
Perkakas "go generate" juga men-set tag build "generate" sehingga
berkas-berkas bisa diperiksa oleh "go generate" namun diindahkan selama
pembangunan.

Jika salah satu generator berhenti karena eror, "go generate" melewati semua
pemrosesan selanjutnya untuk paket tersebut.

Si generator berjalan dalam sumber direktori paket.

Go generate menerima satu opsi khusus:

----
-run=""
	Jika tidak kosong, menspesifikasikan regular expression untuk memilih
	directive yang keseluruhan teksnya (kecuali spasi dan baris baru)
	cocok dengan ekspresi.
----

Go generate juga dapat menerima opsi "build" termasuk -v, -n, dan -x.
Opsi -v mencetak nama-nama paket dan berkas saat proses berjalan.
Opsi -n mencetak perintah yang akan dieksekusi.
Opsi -x mencetak perintah saat dieksekusi.

Untuk lebih lanjut tentang opsi "build", lihat 'go help build'.

Untuk lebih lanjut tentang cara menspesifikasikan paket, lihat 'go help
packages'.


[#hdr-Add_dependencies_to_current_module_and_install_them]
==  Tambah dan pasang dependensi ke modul yang sekarang

Penggunaan:

----
go get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]
----

Perintah "get" menambahkan dependensi ke modul pengembangan yang sekarang dan
kemudian membangun dan memasangnya.

Langkah pertama yaitu menyelesaikan dependensi apa yang ditambahkan.

Untuk setiap paket atau pola paket, "get" harus memutuskan versi mana dari
modul yang akan digunakan.
Secara baku, "get" mencari _tag_ dari versi rilis _tag_ yang terakhir, seperti
v0.4.5 atau v1.2.3.
Jika versi rilis tidak memiliki _tag_, "get" mencari versi _tag_ pra-rilis
yang terakhir, seperti v0.0.1-pre1.
Jika tidak ada versi _tag_ sama sekali, "get" mencari _commit_ terakhir.
Jika modul belum dibutuhkan (misalnya, pra-rilis lebih baru dan rilis
terakhir), "get" akan menggunakan versi yang dicarinya.
Selain itu, "get" akan menggunakan versi yang sekarang dibutuhkan.

Pemilihan versi ini dapat ditimpa dengan menambahkan sufiks @version pada
argumen paket, seperti 'go get golang.org/x/text@v0.3.0'.
Versi tersebut bisa berupa prefiks: @v1 berarti versi terakhir yang tersedia
mulai dari v1.
Lihat 'go help modules' pada 'Module queries' untuk sintaks keseluruhan.

Untuk modul yang disimpan dalam repositori dengan _version control system_
(sistem kontrol versi, atau disingkat VCS), sufiks di versi bisa berupa _hash_
dari _commit_, nama _branch_, atau sintaks lainnya yang dikenal oleh VCS
tersebut, seperti 'go get golang.org/x/text@master'.
Ingat bahwa nama _branch_ yang sama dengan sintaks _query_ modul tidak dapat
dipilih secara eksplisit.
Contohnya, sufiks @v2 artinya versi terakhir mulai dari v2, bukan _branch_
yang bernama v2.

Jika sebuah modul yang diinginkan sudah menjadi dependensi dari modul
pengembangan sekarang, maka "get" akan memperbarui versi yang dibutuhkan.
Menspesifikasikan sebuah versi yang lebih awal dari versi yang dibutuhkan
sekarang adalah valid dan akan men-_downgrade_ dependensi.
Versi dengan sufiks @none mengindikasikan bahwa dependensi harus dihapus
sepenuhnya, di-_downgrade_ atau menghapus modul yang bergantung kepadanya.

Versi dengan sufiks @latest secara eksplisit meminta rilis minor terakhir dari
modul yang diberikan pada path argumen.
Sufiks @upgrade seperti @latest namun tidak akan men-_downgrade_ modul jika ia
sudah dibutuhkan pada versi tertentu atau versi pra-rilis lebih baru dari pada
versi rilis terbaru.
Sufiks @patch meminta rilis _patch_ terbaru: versi rilis terbaru dengan angka
mayor dan minor yang sama dengan yang dibutuhkan sekarang.
Seperti halnya dengan @upgrade, @path tidak akan men-_downgrade_ sebuah modul
yang sudah dibutuhkan pada versi terbaru.
Jika path tertentu belum diperlukan, @upgrade dan @path sama dengan @latest.

Walaupun "get" secara bawaan menggunakan versi terakhir dari modul yang beris
nama paket, ia tidak menggunakan versi terakhir dari dependensi modul.
Namun ia menggunakan versi dependensi tertentu yang diminta oleh modul
tersebut.
Misalnya, jika A butuh modul B v1.2.3, sementara B v1.2.4 dan v1.3.1 juga
tersedia, maka 'go get A' akan menggunakan versi A yang terakhir namun
menggunakan B v1.2.3, seperti yang diminta oleh A.
(Jika ada kebutuhan yang saling bersaing untuk sebuah modul tertentu, 'go
get' menyelesaikan kebutuhan mereka dengan memilih versi maksimum yang
diminta.)

Opsi -t menyuruh 'get' supaya mengunduh modul-modul yang dibutuhkan untuk
pengujian paket yang dispesifikasikan pada baris perintah.

Opsi -u menyuruh 'get' untuk memperbarui modul-modul sebagai dependensi dari
nama paket pada baris perintah supaya menggunakan rilis minor atau patch
terbaru bila ada.
Melanjutkan contoh sebelumnya, 'go get -u A' akan menggunakan versi A yang
terakhir dengan B v1.3.1 (bukan B v1.2.3).
Jika B membutuhkan modul C, namun C tidak menyediakan paket apa pun yang
dibutuhkan untuk membangun paket di A, maka C tidak akan diperbarui.

Opsi -u=patch (bukan '-u patch') juga menyuruh 'get' untuk memperbarui
dependensi, namun dengan menggunakan rilis patch saja.
Melanjutkan contoh sebelumnya, 'go get -u=patch A@latest' akan menggunakan
versi A yang terakhir dengan B v1.2.4 (bukan B v1.2.3), namun untuk
'go get -u=patch A' akan menggunakan rilis patch dari A.

Bila opsi -t dan -u digunakan bersamaan, 'get' akan memperbarui dependensi tes
juga.

Pada umumnya, menambahkan dependensi baru membutuhkan pembaruan dependensi
yang ada supaya pembangunan dapat berjalan, dan 'go get' akan melakukan hal
ini secara otomatis.
Hal yang sama, menurunkan versi salah satu dependensi bisa jadi menurunkan
dependensi yang lain, dan 'go get' juga menangani ini secara otomatis.

Opsi -insecure membolehkan pengambilan dari repositori yang menggunakan skema
tidak aman seperti HTTP.
Gunakan dengan hati-hati.

Langkah kedua yaitu mengunduh (bila perlu), membangun, dan memasang paket yang
diminta.

Jika argumen berupa modul bukan paket (karena tidak ada sumber kode Go dalam
direktori akar dari modul), maka langkah pemasangan dilewati, bukan
menyebabkan gagal pembangunan.
Misalnya, 'go get golang.org/x/perf' akan sukses walaupun tidak ada kode di
dalam path impor tersebut.

Ingat bahwa pola paket dibolehkan dan dikembangkan setelah versi modul
diselesaikan.
Misalnya, 'go get golang.org/x/perf/cmd/...' menambahkan versi
'golang.org/x/perf' yang terakhir dan kemudian memasang perintah-perintah pada
versi yang terakhir juga.

Opsi -d membuat 'get' mengunduh kode yang dibutuhkan untuk membangun paket,
termasuk mengunduh dependensi yang dibutuhkan, namun tidak membangun dan
memasang mereka.

Tanpa ada argumen, 'go get' berlaku terhadap paket Go di direktori yang
sekarang, jika ada.
Terutama, 'go get -u' dan 'go get -u=patch' memperbarui semua dependensi dari
paket tersebut.
Jika tidak ada argumen paket dan juga tanpa -u, 'go get' hampir sama dengan
'go install', dan 'go get -d' hampir sama dengan 'go list'.

Untuk lebih tentang modul, lihat 'go help modules'.

Untuk lebih lanjut tentang argumen paket, lihat 'go help packages'.

Tulisan ini menjelaskan perilaku dari 'get' pada modul untuk mengatur kode dan
dependensi.
Jika perintah 'go' berjalan dalam mode GOPATH, opsi dari 'get' berubah,
sebagaimana juga 'go help get'.
Lihat 'go help modules' dan 'go help gopath-get'.

Lihat juga: go build, go install, go clean, go mod.


[#hdr-Compile_and_install_packages_and_dependencies]
==  Kompilasi dan pasang paket dan dependensi

Penggunaan:

----
go install [-i] [build flags] [packages]
----

Perintah 'install' mengompilasi dan memasang paket berdasarkan path impor.

Program _executable_ dipasang dalam direktori GOBIN dari variabel lingkungan,
yang bila kosong akan diset ke $GOPATH/bin atau $HOME/go/bin.
Program dalam $GOROOT dipasang di $GOROOT/bin atau $GOTOOLDIR bukan $GOBIN.

Jika mode modul tidak aktif, paket-paket lain dipasang dalam direktori
$GOPATH/pkg/$GOOS_$GOARCH.
Jika mode modul aktif, paket-paket dibangun dan di-_cache_ tapi tidak
dipasang.

Opsi -i memasang dependensi dari paket juga.

Untuk informasi lebih lanjut tentang opsi pembangunan, lihat 'go help build'.
Untuk informasi lebih lanjut tentang penamaan paket, lihat 'go help packages'.

Lihat juga: go build, go get, go clean.


[#hdr-List_packages_or_modules]
==  Cetak daftar paket atau modul

Penggunaan:

----
go list [-f format] [-json] [-m] [list flags] [build flags] [packages]
----

Perintah 'list' mencetak nama paket, per baris.
Opsi yang sering digunakan yaitu -f dan -json, yang mengatur pencetakan dari
setiap paket.
Opsi 'list' lainnya, mengontrol detail yang lebih khusus.

Keluaran bakunya mencetak path impor dari paket:

----
bytes
encoding/json
github.com/gorilla/mux
golang.org/x/net/html
----

Opsi -f menentukan format alternatif dari daftar tersebut, menggunakan
sintaksis dari templat paket.
Keluaran bakunya sama dengan -f '{{.ImportPath}}'.
Struct yang dikirim ke templat yaitu:

----
type Package struct {
    Dir           string   // direktori yang berisi sumber paket
    ImportPath    string   // path impor dari paket dalam direktori
    ImportComment string   // path dalam komentar impor di perintah 'package'
    Name          string   // nama paket
    Doc           string   // dokumentasi paket
    Target        string   // path pemasangan
    Shlib         string   // pustaka yang berisi paket ini (hanya di set saat -linkshared)
    Goroot        bool     // apakah paket ini ada di Go root?
    Standard      bool     // apakah paket ini bagian dari pustaka standar Go?
    Stale         bool     // apakah 'go install' melakukan sesuatu pada paket ini?
    StaleReason   string   // penjelasan untuk Stale==true
    Root          string   // direktori Go root atau Go path yang berisi paket ini
    ConflictDir   string   // direktori ini menutup direktori dalam $GOPATH
    BinaryOnly    bool     // paket yang binari saja (tidak lagi didukung)
    ForTest       string   // paket hanya digunakan pada tes
    Export        string   // berkas berisi data ekspor (saat menggunakan -export)
    Module        *Module  // info tentang paket berisi modul, jika ada (bisa nil)
    Match         []string // pola baris-perintah yang sesuai dengan paket ini
    DepOnly       bool     // paket ini hanya lah dependensi, tidak terdaftar secara eksplisit

    // Berkas-berkas sumber
    GoFiles         []string // berkas-berkas .go (kecuali CgoFiles, TestGoFiles, XTestGoFiles)
    CgoFiles        []string // berkas-berkas .go yang mengimpor "C"
    CompiledGoFiles []string // berkas-berkas .go yang diberikan ke compiler (bila menggunakan -compiled)
    IgnoredGoFiles  []string // berkas-berkas .go yang diindahkan karena batasan pembangunan
    CFiles          []string // berkas-berkas .c
    CXXFiles        []string // berkas-berkas .cc, .cxx and .cpp
    MFiles          []string // berkas-berkas .m
    HFiles          []string // berkas-berkas .h, .hh, .hpp and .hxx
    FFiles          []string // berkas-berkas .f, .F, .for dan .f90 Fortran
    SFiles          []string // berkas-berkas .s
    SwigFiles       []string // berkas-berkas .swig
    SwigCXXFiles    []string // berkas-berkas .swigcxx
    SysoFiles       []string // berkas-berkas objek .syso yang ditambahkan ke arsip
    TestGoFiles     []string // berkas-berkas _test.go dalam paket
    XTestGoFiles    []string // berkas-berkas _test.go di luar paket

    // Cgo directives
    CgoCFLAGS    []string // cgo: opsi untuk C compiler
    CgoCPPFLAGS  []string // cgo: opsi untuk C preprocessor
    CgoCXXFLAGS  []string // cgo: opsi untuk C++ compiler
    CgoFFLAGS    []string // cgo: opsi untuk Fortran compiler
    CgoLDFLAGS   []string // cgo: opsi untuk linker
    CgoPkgConfig []string // cgo: nama-nama pkg-config

    // Dependency information
    Imports      []string          // path impor yang digunakan oleh paket ini
    ImportMap    map[string]string // map dari impor ke ImportPath (identitas dihilangkan)
    Deps         []string          // semua (rekursif) dependensi yang diimpor
    TestImports  []string          // impor dari TestGoFiles
    XTestImports []string          // impor dari XTestGoFiles

    // Error information
    Incomplete bool            // paket ini atau dependensinya memiliki eror
    Error      *PackageError   // eror pada pemuatan paket
    DepsErrors []*PackageError // eror pada pemuatan dependensi
}
----

Paket yang disimpan dalam direktori vendor melaporkan ImportPath yang
mengikutkan path ke direktori vendor (misalnya, "d/vendor/p" bukan "p"),
sehingga ImportPath secara unik mengidentifikasi salinan dari sebuah paket.
Daftar pada Imports, Deps, TestImports, dan XTestImports juga berisi path
impor yang diperluas ini.
Lihat golang.org/s/go15vendor untuk lebih lanjut tentang "vendor".

Informasi eror, jika ada, yaitu

----
type PackageError struct {
    ImportStack   []string // path terpendek dari nama paket pada baris-perintah ke paket yang sekarang
    Pos           string   // posisi eror (jika ada, berkas:baris:kolom)
    Err           string   // eror itu sendiri
}
----

Informasi modul yaitu struct Module, didefinisikan dalam diskusi dari daftar
-m di bawah.

Fungsi templat "join" memanggil strings.Join.

Fungsi templat "context" mengembalikan context pembangunan, didefinisikan
sebagai:

----
type Context struct {
    GOARCH        string   // target arsitektur
    GOOS          string   // target sistem operasi
    GOROOT        string   // Go root
    GOPATH        string   // Go path
    CgoEnabled    bool     // apakah cgo dapat digunakan
    UseAllFiles   bool     // gunakan berkas, mengindahkan baris +build lines, nama berkas
    Compiler      string   // compiler yang digunakan untuk path target
    BuildTags     []string // batasan build sesuai baris +build
    ReleaseTags   []string // rilis yang sekarang tidak kompatibel
    InstallSuffix string   // sufiks yang digunakan dalam direktori pemasangan
}
----

Untuk informasi lebih lanjut tentang makna dari field-field tersebut lihat
dokumentasi paket go/build untuk tipe Context.

Opsi -json menyebabkan data paket dicetak dalam format JSON bukan menggunakan
format templat.

Opsi -compiled men-set CompiledGoFiles dengan berkas sumber Go yang diberikan
kepada _compiler_.
Biasanya hal ini berisi berkas dalam GoFiles dan juga menambahkan kode Go yang
dihasilkan dari pemrosesan CgoFiles dan SwigFiles.
Daftar impor berisi gabungan dari semua impor GoFiles dan CompiledGoFiles.

Opsi `-deps` membuat perintah "list" melakukan iterasi tidak hanya pada paket
tetapi juga semua dependensinya.
Semua dependensi dikunjungi secara _depth-first post-order_, sehingga paket
dicetak setelah semua dependensinya.
Paket-paket yang secara eksplisit tidak dicantumkan pada baris perintah akan
memiliki field `DepOnly` bernilai `true`.

Opsi `-e` mengubah penanganan paket-paket yang eror, yaitu paket yang tidak
bisa ditemukan atau salah format.
Secara baku, perintah "list" mencetak kesalahan untuk setiap paket dan
mengindahkan paket yang eror tersebut.
Dengan opsi `-e`, perintah "list" tidak akan mencetak kesalahan namun
memproses paket yang eror tersebut.
Paket yang eror akan memiliki isi pada field `ImportPath` dan `Error`;
informasi lainnya bisa saja kosong.

Opsi `-export` membuat field `Export` di-set dengan nama berkas yang berisi
informasi ekspor terbaru dari paket yang diberikan.

Opsi `-find` membuat perintah "list" mengidentifikasi paket tetapi tidak
mencari dependensinya: field `Imports` dan `Deps` akan kosong.

Opsi `-test` melaporkan tidak hanya nama paket namun juga program pengujiannya
(untuk paket-paket dengan tes), supaya perkakas analisis sumber kode tahu
bagaimana program test dibangun.
Path impor yang dilaporkan untuk sebuah program tes yaitu path import dari
paket diikuti oleh sufiks ".test", seperti "math/rand.test".
Saat membangun sebuah tes, terkadang perlu membangun ulang beberapa dependensi
khusus untuk tes (umumnya paket tes itu sendiri).
Path impor yang dilaporkan dari sebuah paket yang dikompilasi ulang untuk
sebuah program tes tertentu yaitu diikuti dengan sebuah spasi dan nama dari
program tes dalam tanda kurung siku, seperti "math/rand [math/rand.test]"
atau "regexp [sort.test]".
Field `ForTest` diisi dengan nama dari paket yang di tes ("math/rand" atau
"sort" pada contoh sebelumnya).

Path berkas pada `Dir`, `Target`, `Shlib`, `Root`, `ConflictDir`, dan `Export`
adalah path absolut.

Secara baku, daftar dalam `GoFiles`, `CgoFiles`, dan seterusnya berisi
nama-nama berkas dalam `Dir` (yaitu path yang relatif terhadap `Dir`, bukan
path absolut).
Berkas-berkas yang ditambah saat menggunakan opsi `-compiled` dan `-test`
adalah berupa path absolut yang mengacu ke salinan dari berkas sumber Go.
Walaupun mereka adalah sumber berkas Go, path mereka sendiri bisa saja tidak
diakhiri dengan ".go".

Opsi `-m` mencetak daftar modul bukan paket-paket.

Saat mencetak modul, opsi `-f` menentukan format templat yang diterapkan pada
sebuah Go struct, yaitu Module struct:

----
type Module struct {
    Path      string       // path modul
    Version   string       // versi modul
    Versions  []string     // versi modul yang tersedia (dengan -versions)
    Replace   *Module      // ditimpa oleh modul ini
    Time      *time.Time   // waktu saat versi dibuat
    Update    *Module      // update yang tersedia, jika ada (dengan -u)
    Main      bool         // apakah ini modul utama?
    Indirect  bool         // apakah modul ini dependensi tidak langsung dari
                           // modul utama?
    Dir       string       // direktori tempat modul berada, jika ada
    GoMod     string       // path ke berkas go.mod dari modul ini, jika ada
    GoVersion string       // versi Go yang digunakan oleh modul
    Error     *ModuleError // kesalahan yang terjadi saat memuat modul
}

type ModuleError struct {
    Err string // eror itu sendiri
}
----

Keluaran baku yaitu mencetak path modul dan informasi tentang versi dan
penggantinya jika ada.
Contohnya, 'go list -m all' mencetak:

----
my/main/module
golang.org/x/text v0.3.0 => /tmp/text
rsc.io/pdf v0.1.1
----

Struct `Module` memiliki method String yang membuat format baris keluaran di
atas, sehingga format baku sama dengan `-f '{{.String}}'`.

Ingatlah bahwa saat sebuah modul telah ditimpa, field `Replace` menjelaskan
modul yang menggantinya, dan field `Dir` diisi dengan sumber kode pengganti,
jika ada.
(Jika `Replace` tidak kosong, maka `Dir` diisi dengan `Replace.Dir`, tanpa
akses ke sumber kode yang menggantinya.)

Opsi `-u` menambahkan informasi tambahan tentang adanya pembaruan.
Bila versi terakhir dari sebuah modul lebih baru dari yang sekarang, opsi `-u`
men-set field `Update` dengan informasi tentang modul terbaru.
Method `String` pada `Module` mengindikasikan adanya pembaruan dengan mencetak
versi terbaru dalam tanda kurung siku setelah versi yang sekarang.
Misalnya, 'go list -m -u all' bisa mencetak:

----
my/main/module
golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text
rsc.io/pdf v0.1.1 [v0.1.2]
----

(Untuk perkakas luar, 'go list -m -u -json all' mungkin lebih mudah untuk
diurai.)

Opsi `-versions` men-set field `Version` pada `Module` dengan daftar semua
versi dari modul tersebut, diurut berdasarkan versi semantik, dari yang lama
ke yang terbaru.
Opsi ini mengubah format keluaran baku dengan menampilkan path modul diikuti
daftar versi yang dipisahkan oleh spasi.
Misalnya,
----
$ go list -m -versions git.sr.ht/shulhan/pakakeh.go
go: finding versions for git.sr.ht/shulhan/pakakeh.go
git.sr.ht/shulhan/pakakeh.go v0.1.0 v0.2.0 v0.3.0 v0.4.0 v0.5.0 v0.6.0 v0.6.1
$
----

Argumen yang diberikan ke `-m` adalah daftar modul, bukan paket.
Modul utama yaitu modul yang berisi direktori sekarang.
Modul aktif adalah modul utama dan dependensinya.
Tanpa argumen, 'list -m' mencetak modul utama.
Dengan argumen, 'list -m' mencetak modul yang diberikan pada argumen.
Modul-modul yang aktif dapat dispesifikasikan dengan path modul mereka.
Pola khusus seperti "all" menentukan semua modul aktif, pertama modul utama
dan kemudian dependensinya diurut berdasarkan path modul.
Pola yang berisi "..." menentukan modul aktif yang path modul-nya cocok dengan
pola tersebut.
Kueri dengan format "path@version" menentukan hasil dari pencarian
tersebut, yang tidak dibatasi oleh modul aktif.
Lihat 'go help modules' untuk lebih tentang kueri modul.

Fungsi templat "module" menerima argumen sebuah string yang harus berupa path
modul atau kueri dan mengembalikan modul tertentu sebagai struct `Module`.
Jika terjadi kesalahan, hasilnya berupa struct `Module` dengan field `Error`
yang berisi.

Untuk lebih lanjut tentang opsi "build", lihat 'go help build'.

Untuk lebih lanjut tentang penentuan paket, lihat 'go help packages'.

Untuk lebih lanjut tentang modul, lihat 'go help modules'.

[#hdr-Module_maintenance]
==  Pemeliharaan modul

Perintah 'go mod' menyediakan akses terhadap operasi-operasi pada modul.

Ingatlah bahwa dukungan untuk modul tertanam pada semua perintah go, tidak
hanya 'go mod'.
Misalnya, penambahan, penghapusan, pembaruan, dan pemunduran dari dependensi
seharusnya dilakukan lewat 'go get'.
Lihat 'go help modules' untuk gambaran dari fungsionalitas modul.

Penggunaan:

----
go mod <command> [arguments]
----

Argumen "command" adalah:

----
download    unduh modul ke lokal cache
edit        sunting go.mod dengan perkakas atau skrip
graph       cetak dependensi modul
init        inisiasi modul baru di direktori sekarang
tidy        tambah modul yang hilang atau hapus modul yang tidak digunakan
vendor      salin semua dependensi ke direktori vendor
verify      verifikasi dependensi sesuai dengan yang diharapkan
why         jelaskan kenapa paket atau modul dibutuhkan
----

Gunakan "go help mod <command>" untuk informasi lebih lanjut tentang
perintah-perintah tersebut.


[#hdr-Download_modules_to_local_cache]
===  Unduh modul ke lokal _cache_

Penggunaan:

----
go mod download [-x] [-json] [modules]
----

Perintah "download" mengunduh modul sesuai argumen yang diberikan, yang bisa
dalam bentuk pola yang memilih dependensi dari modul utama atau kueri dalam
bentuk "path@version".
Jika argumen kosong, perintah "download" berlaku untuk semua dependensi dari
modul utama (sama dengan 'go mod download all').

Perintah go secara otomatis mengunduh modul yang dibutuhkan selama eksekusi.
Perintah "go mod download" biasa berguna untuk mengisi _cache_ di lokal atau
untuk mencari jawaban dari Go modul _proxy_

Secara bawaan, "download" tidak menulis apa pun ke layar.
Ia mungkin mencetak pesan kesalahan atau progres ke _standard error_.

Opsi `-json` membuat perintah "download" mencetak seurutan objek JSON ke
_standard output_, mendeskripsikan setiap modul yang diunduh (atau yang
gagal), sesuai dengan struct Go berikut

----
type Module struct {
	Path     string // path ke modul
	Version  string // versi modul
	Error    string // eror pemuatan modul
	Info     string // path absolut ke berkas .info dalam cache
	GoMod    string // path absolut ke berkas .mod dalam cache
	Zip      string // path absolut ke berkas .zip dalam cache
	Dir      string // path absolut ke direktori sumber dalam cache
	Sum      string // checksum untuk path, versi (seperti dalam go.sum)
	GoModSum string // checksum untuk go.mod (seperti dalam go.sum)
}
----

Opsi `-x` menyebabkan "download" mencetak perintah pengunduhan yang
dieksekusi.

Lihat `go help modules` untuk mengetahui lebih lanjut tentang pencarian modul.


[#hdr-Edit_go_mod_from_tools_or_scripts]
===  Sunting go.mod dengan perkakas atau skrip

Penggunaan:

----
go mod edit [editing flags] [go.mod]
----

Perintah "edit" menyediakan antarmuka baris-perintah untuk menyunting go.mod,
umumnya digunakan oleh perkakas atau skrip.
Ia hanya membaca go.mod;
tidak membaca informasi tentang dependensi modul-modul.
Secara bawaan, "edit" membaca dan menulis berkas "go.mod" dari modul utama,
namun berkas tujuan yang berbeda dapat diberikan sebagai argumen "edit".

Opsi-opsi pada "edit" menentukan seurutan operasi penyuntingan.

Opsi -fmt memformat ulang berkas go.mod tanpa membuat perubahan.
Pemformatan ulang ini biasanya dilakukan setelah melakukan perubahan yang
mengubah berkas go.mod.
Satu-satunya opsi ini diperlukan yaitu bila tidak ada lagi flag lain yang
diberikan, seperti 'go mod edit -fmt'.

Opsi -module mengubah path dari modul utama (baris "module" pada berkas
go.mod).

Opsi -require=path@version dan -droprequire=path menambah dan menghapus
dependensi dari modul dan versi yang diberikan.
Opsi -require akan menimpa dependensi yang sudah ada sesuai dengan path yang
diberikan.
Opsi ini umumnya untuk perkakas yang mengerti grafik modul.
Pengguna biasa seharusnya menggunakan 'go get path@version' atau
'go get path@none', yang membuat penyesuaian go.mod lainnya bila diperlukan
untuk memenuhi batasan-batasan yang diberikan oleh modul lainnya.

Opsi -exclude=path@version dan -dropexclude=path@version menambah dan
menghapus pengecualian dari path dan versi modul yang diberikan.
Opsi -exclude=path@version tidak melakukan operasi apa pun bila pengecualian
telah tercatat sebelumnya.

Opsi -replace=old[@v]=new[@v] menambah sebuah pengganti dari pasangan modul path dan
versi yang diberikan.
Jika @v dalam old@v tidak ada, penggantian tanpa versi pada bagian kiri
ditambahkan, yang berlaku untuk semua versi dari path modul old.
Jika @v dalam new@v tidak ada, path yang baru berarti direktori lokal dari
modul, bukan path dari modul.
Ingatlah bahwa -replace menimpa penggantian yang redundan untuk old[@v],
sehingga tanpa @v akan menghapus penggantian yang ada untuk versi tertentu.

Opsi -dropreplace=old[@v] menghapus sebuah penggantian dari pasangan path dan
versi modul yang diberikan.
Jika @v tidak ada, sebuah penggantian tanpa versi di bagian kiri akan dihapus.

Opsi -require, -droprequire, -exclude, -dropexclude, -replace, dan
-dropreplace bisa berulang, dan perubahan diterapkan sesuai dengan urutan yang
diberikan.

Opsi -go=version menset versi bahasa Go yang diinginkan.

Opsi -print mencetak berkas akhir dari go.mod dalam format teks bukan menulis
ke berkas.

Opsi -json mencetak berkas akhir dari go.mod dalam format JSON bukan menulis
ke berkas.
Keluaran dari JSON sesuai dengan tipe-tipe Go berikut:

----
type Module struct {
	Path string
	Version string
}

type GoMod struct {
	Module  Module
	Go      string
	Require []Require
	Exclude []Module
	Replace []Replace
}

type Require struct {
	Path string
	Version string
	Indirect bool
}

type Replace struct {
	Old Module
	New Module
}
----

Ingatlah bahwa ia hanya menjelaskan berkas go.mod itu sendiri, bukan
modul-modul lain yang diacu secara tidak langsung.
Untuk melihat seluruh modul yang digunakan pada saat "build", gunakan
'go list -m -json all'.

Sebagai contoh, sebuah perkakas bisa mengambil isi go.mod sebagai struktur
data dengan mengurai keluaran dari 'go mod edit -json' dan kemudian dapat
mengubahnya dengan memanggil 'go mod edit' dengan opsi -require, -exclude, dan
seterusnya.

[#hdr-Print_module_requirement_graph]
===   Cetak dependensi modul

Penggunaan:

----
go mod graph
----

Perintah "graph" mencetak grafik kebutuhan modul (dengan menerapkan
penggantian) dalam bentuk teks.
Setiap baris dari keluaran berisi dua kolom yang dibatasi dengan dua spasi:
nama modul dan satu atau lebih dependensinya.
Setiap modul diidentifikasi sebagai sebuah string dalam bentuk path@version,
kecuali untuk modul utama, tidak memiliki sufiks @version.

[#hdr-Initialize_new_module_in_current_directory]
===  Inisiasi modul baru di direktori sekarang

Penggunaan:

----
go mod init [module]
----

Perintah `init` menginisiasi dan menulis sebuah "go.mod" yang baru di
direktori yang sekarang, efeknya adalah sebuah modul baru dibuat di direktori
yang sama.
Berkas "go.mod" harus tidak ada sebelumnya.
Jika memungkinkan, `init` akan men-set path dari modul berdasarkan komentar
impor (lihat 'go help importpath') atau dari konfigurasi Version Control
System (VCS).
Untuk menimpa path modul, tambahkan path modul sebagai argumen pertama.

#hdr-Add_missing_and_remove_unused_modules
===  Tambah modul yang hilang atau hapus modul yang tidak digunakan

Penggunaan:

----
go mod tidy [-v]
----

Perintah `tidy` memastikan isi dari berkas go.mod sesuai dengan sumber kode
dalam modul.
Ia akan mencatat modul dependensi yang dibutuhkan supaya dapat membangun
paket-paket di dalam modul yang sekarang, dan menghapus dependensi modul yang
tidak digunakan.
Ia juga menambahkan catatan ke go.sum dan menghapus yang tidak dipergunakan
lagi.

Opsi -v menyebabkan `tidy` mencetak informasi tentang modul yang dihapus ke
__standard error__.


[#hdr-Make_vendored_copy_of_dependencies]
===   Salin semua dependensi ke direktori vendor

Penggunaan:

----
go mod vendor [-v]
----

Perintah `vendor` me-reset direktori "vendor" pada modul utama supaya
mengikutkan semua paket yang dibutuhkan untuk membangun dan menguji semua
paket-paket di modul utama.
Ia tidak mengikutkan berkas-berkas pengujian dari paket-paket yang
di-vendor-kan.

Opsi "-v" menyebabkan perintah "vendor" mencetak nama-nama dari modul dan
paket yang di-vendor-kan ke __standard error__.


[#hdr-Verify_dependencies_have_expected_content]
===  Verifikasi dependensi sesuai dengan yang diharapkan

Penggunaan:

----
go mod verify
----

Perintah `verify` memeriksa dependensi dari modul, yang disimpan dalam _cache_
di lokal, belum pernah dimodifikasi sejak diunduh.
Jika semua modul tidak pernah dimodifikasi, perintah `verify` mencetak
"all modules verified.", selain itu ia akan melaporkan modul-modul yang telah
berubah dan menyebabkan perintah 'go mod' keluar dengan status selain 0.


[#hdr-Explain_why_packages_or_modules_are_needed]
===  Jelaskan kenapa paket atau modul dibutuhkan

Penggunaan:

----
go mod why [-m] [-vendor] packages...
----

Perintah "why" memperlihatkan path terpendek dalam rangkaian impor dari modul
utama ke setiap paket pada parameter.
Jika opsi "-m" diberikan, perintah "why" menganggap argumen sebagai daftar
modul dan mencari sebuah path ke paket mana pun dalam setiap modul.

Secara baku, "why" mencari paket yang cocok dengan "go list all", yang
mengikutkan paket pengujian.
Opsi "-vendor" menyebabkan "why" mengindahkan dependensi pengujian.

Keluaran dari perintah ini yaitu seurutan stanza, setiap baris berisi nama
paket atau modul dari parameter yang diberikan pada baris perintah.
Setiap stanza dimulai dengan baris komentar "# paket" atau "# modul" sesuai
dengan target paket atau modul.
Baris selanjutnya mencetak sebuah path dari grafik impor, satu paket satu
baris.
Jika paket atau modul tidak diacu dari modul utama, maka stanza tersebut akan
menampilkan catatan dalam tanda kurung yang menyatakan alasannya.

Sebagai contohnya,

----
$ go mod why golang.org/x/text/language golang.org/x/text/encoding
# golang.org/x/text/language
rsc.io/quote
rsc.io/sampler
golang.org/x/text/language

# golang.org/x/text/encoding
(main module does not need package golang.org/x/text/encoding)
$
----


[#hdr-Compile_and_run_Go_program]
==   Kompilasi dan jalankan program Go

Penggunaan:

----
go run [build flags] [-exec xprog] package [arguments...]
----

Perintah "run" mengompilasi dan menjalankan paket Go bernama "main".
Biasanya paket tersebut ditentukan sebagai daftar berkas sumber .go dari
sebuah direktori, tetapi bisa juga dalam bentuk path impor, path dalam sistem
berkas, atau pola yang sesuai dengan sebuah paket, seperti 'go run .' atau
'go run my/cmd'.

Secara bawaan, 'go run' secara langsung menjalankan berkas binari hasil
kompilasi: 'a.out argumen...'.
Jika opsi "-exec" diberikan, 'go run' menjalankan berkas binari menggunakan
program "xprog":

----
'xprog a.out arguments...'.
----

Jika opsi "-exec" tidak diberikan, GOOS atau GOARCH berbeda dengan bawaan
sistem, dan sebuah program bernama go_$GOOS_$GOARCH_exec ditemukan ditemukan
dalam system PATH, 'go run' memanggil berkas binari menggunakan program
tersebut, misalnya 'go_js_wasm_exec a.out argumen...'.
Hal ini membolehkan eksekusi dari program yang dikompilasi silang
(__cross-compiled__) saat sebuah simulator atau metode eksekusi lain
tersedia.

Status keluaran dari perintah `run` bukanlah status keluaran dari berkas
binary hasil kompilasi.

Untuk informasi lebih lanjut tentang opsi-opsi pembangunan, lihat 'go help
build'.
Untuk informasi lebih lanjut tentang cara menspesifikasikan paket, lihat 'go
help packages'.

Lihat juga: go build.


[#hdr-Test_packages]
==  Menguji paket-paket

Penggunaan:

----
go test [build/test flags] [packages] [build/test flags & test binary flags]
----

Perintah 'go test' men- otomatisasi pengujian paket-paket berdasarkan nama
path impor.
Ia mencetak ringkasan dari hasil pengujian dalam format:

----
ok   archive/tar   0.011s
FAIL archive/zip   0.022s
ok   compress/gzip 0.033s
...
----

diikuti dengan detail untuk setiap paket yang gagal (`FAIL`).

Perintah 'go test' meng-ompilasi ulang setiap paket bersama dengan semua
berkas yang sesuai dengan pola berkas "*_test.go".
Berkas-berkas tambahan ini bisa berisi fungsi-fungsi pengujian, __benchmark__,
dan contoh.
Lihat 'go help testfunc' untuk lebih lanjut.
Setiap paket yang didaftarkan menyebabkan eksekusi pengujian yang berbeda.
Nama berkas yang dimulai dengan "_" (termasuk "_test.go") atau "." akan
diindahkan.

Berkas-berkas uji yang memiliki nama paket dengan sufiks "_test" akan
dikompilasi sebagai paket yang terpisah, dan kemudian dihubungkan dan
dijalankan bersamaan dengan binari pengujian utama.

Perkakas go akan mengindahkan sebuah direktori bernama "testdata", membuatnya
tersedia sebagai tempat penyimpanan data yang dibutuhkan oleh pengujian.

Sebagai bagian dari pembangunan sebuah binari pengujian, 'go test' menjalankan
'go vet' terhadap paket yang diberikan dan berkas sumber ujinya untuk
mengidentifikasi permasalahan yang signifikan.
Jika 'go vet' menemukan masalah, 'go test' melaporkannya dan tidak akan
menjalankan binari pengujian.
Hanya sebagian dari perkakas 'go vet' yang digunakan, yaitu: 'atomic', 'bool',
'buildtags', 'errorsas', 'ifaceassert', 'nilfunc', 'printf', dan
'stringintconv'.
Anda bisa membaca dokumentasi dari setiap perkakas tersebut lewat "go doc
cmd/vet".
Untuk meniadakan eksekusi 'go vet', gunakan opsi "-vet=off".

Semua baris keluaran dan ringkasan pengujian dicetak ke __standard output__,
bahkan bila fungsi pengujian mencetaknya ke __standard error__-nya sendiri.
(__standard error__ dari perintah go disediakan hanya untuk mencetak eror saat
membangun binari pengujian.)

Perintah 'go test' berjalan dalam dua mode berbeda:

Yang pertama, disebut mode direktori lokal, terjadi saat 'go test' dipanggil
tanpa argumen paket (misalnya, 'go test' atau 'go test -v').
Dalam mode ini, 'go test' mengompilasi sumber kode dan tes paket yang
ditemukan dalam direktori yang sekarang dan kemudian menjalankan binari tes.
Dalam mode ini, tembolok (didiskusikan di bawah) di non-aktifkan.
Setelah pengujian paket selesai, "go test" mencetak baris ringkasan
memperlihatkan status pengujian ('ok' atau 'FAIL'), nama paket, dan waktu yang
dihabiskan.

Yang kedua, disebut mode daftar paket, terjadi saat "go test" dipanggil dengan
argumen paket (misalnya 'go test math', 'go test ./...', dan bahkan 'go test
.').
Dalam mode ini, "go test" mengompilasi dan menguji setiap paket yang diberikan
pada baris perintah.
Jika sebuah pengujian paket berhasil, "go test" hanya mencetak baris ringkasan
'ok'.
Jika pengujian paket gagal, "go test" mencetak semua keluaran pengujian.
Jika dipanggil dengan opsi "-bench" atau "-v", "go test" mencetak semua
keluaran bahkan untuk pengujian paket yang berhasil, dengan tujuan menampilkan
hasil __benchmark__ atau pencatatan.
Setelah pengujian semua paket selesai, dan hasilnya dicetak, "go test"
menampilkan status 'FAIL' jika salah satu pengujian paket gagal.

Pada mode daftar paket, "go test" menyimpan hasil pengujian paket yang
berhasil dalam sebuah tembolok untuk menghindari pengulangan pengujian yang
tidak penting.
Bila hasil dari sebuah pengujian dapat dipulihkan dari tembolok, "go test"
akan menampilkan ulang keluaran sebelumnya bukan menjalankan binari pengujian
kembali.
Bila ini terjadi, "go test" mencetak '(cached)' sebagai pengganti waktu pada
baris ringkasan.

Aturan dari penggunaan tembolok yaitu pengujian dijalankan mengikutkan binari
pengujian yang sama dan opsi-opsi pada baris perintah menggunakan sekumpulan
opsi yang dapat di-__cache__, yaitu -cpu, -list, -parallel, -run, -short, dan
-v.
Jika "go test" dijalankan dengan opsi selain dari sekumpulan opsi tersebut,
maka hasilnya tidak akan di-__cache__.
Untuk menonaktifkan __caching__ pengujian, gunakan opsi pengujian atau argumen
selain opsi-opsi yang dapat di-__cache__.
Cara idiomatis untuk menonaktifkan __cache__ pengujian secara eksplisit yaitu
menggunakan -count=1.
Tes-test yang membuka berkas dalam sumber paket (biasanya $GOPATH) atau yang
membaca variabel lingkungan akan selalu berjalan sama selama berkas dan
variabel lingkungan tidak berubah.
Sebuah hasil pengujian yang di-__cache__ dianggap dieksekusi tanpa memakan
waktu sama sekali, sehingga sebuah hasil tes yang sukses akan di-__cache__ dan
digunakan ulang dengan mengindahkan pengaturan -timeout.

Selain opsi-opsi "build", opsi-opsi yang ditangani oleh 'go test' itu sendiri
diantaranya:

----
-args
    Kirim sisa baris perintah (semua argumen setelah -args) ke binari tes,
    tanpa diinterpretasi dan tidak diubah.
    Secara opsi ini mengonsumsi sisa dari baris perintah, daftar paket (jika
    ada) harus muncul sebelum opsi ini.

-c
    Kompilasi binari tes ke "pkg.test" namun jangan jalankan (yang mana "pkg"
    adalah elemen terakhir dari path impor paket).
    Nama berkas dapat diubah lewat opsi -o.

-exec xprog
    Jalankan binari tes menggunakan xprog.  Perilaku ini sama dengan 'go run'.
    Lihat 'go help run' untuk lebih jelas.

-i
    Pasang paket-paket dependensi dari tes.
    Jangan jalankan tes.

-json
    Konversi hasil tes ke JSON yang cocok untuk pemrosesan otomatis.
    Lihat 'go doc test2json' untuk detail format.

-o berkas
    Kompilasi binari tes ke berkas.
    Tes masih tetap dijalankan (kecuali -c atau -i diberikan).
----

Binari tes juga menerima opsi yang mengontrol eksekusi dari tes; opsi-opsi
tersebut juga dapat diakses oleh 'go test'.  Lihat 'go help testflag' untuk
lebih detail.

Untuk lebih lanjut tentang opsi "build", lihat 'go help build'.
Untuk lebih lanjut tentang cara menspesifikasikan paket, lihat 'go help
packages'.

Lihat juga: go build, go vet.


[#hdr-Run_specified_go_tool]
==  Jalankan perkakas go tertentu

Penggunaan:

----
go tool [-n] perintah [args...]
----

Perintah 'tool' menjalankan perintah yang diidentifikasi oleh
argumen-argumennya.
Bila argumen tidak diberikan, ia akan mencetak daftar perintah yang dikenal
oleh 'tool'.

Opsi -n menyebabkan 'tool' mencetak perintah yang akan dieksekusi tetapi tidak
mengeksekusinya.

Untuk informasi lebih lanjut tentang setiap perintah pada 'tool', lihat
'go doc cmd/<perintah>'.


[#hdr-Print_Go_version]
==  Cetak versi Go

Penggunaan:

----
go version [-m] [-v] [file ...]
----

Perintah 'version' mencetak informasi pembangunan dari hasil binari Go.

Perintah 'go version' melaporkan versi Go yang digunakan untuk membangun
setiap nama berkas binari yang diberikan pada baris perintah.

Jika tidak ada berkas yang diberikan, 'go version' akan mencetak informasi
versi dirinya sendiri.

Jika sebuah direktori diberikan, 'go version' menelusuri direktori tersebut
secara rekursif, mencari hasil binari-binari Go yang dikenal dan melaporkan
versi mereka masing-masing.
Secara bawaan, 'go version' tidak melaporkan berkas-berkas yang tidak dikenal
yang ditemukan selama pemindaian direktori.
Opsi -v melaporkan berkas-berkas yang tidak dikenal tersebut.

Opsi -m menyebabkan 'go version' mencetak informasi versi modul yang tertanam
dalam binari, bila ada.
Keluarannya yaitu informasi modul yang berisi beberapa baris diikuti oleh
versi, yang dipisahkan oleh karakter tab.

Lihat juga: go doc runtime/debug.BuildInfo.

[#hdr-Report_likely_mistakes_in_packages]
== Periksa kemungkinan kesalahan dalam paket

Penggunaan

	go vet [-n] [-x] [-vettool prog] [build flags] [vet flags] [packages]

Program `vet` menjalankan perintah `go vet` pada paket-paket berdasarkan nama
path impor yang diberikan pada parameter "packages".

Untuk informasi lebih lanjut tentang vet dan opsinya, lihat 'go doc cmd/vet'.
Untuk informasi tentang parameter "packages", lihat 'go help packages'.
Untuk informasi dafter _checker_ (pemeriksa) yang tersedia berikut opsinya,
lihat 'go tool vet help'.
Untuk informasi tentang _checker_ seperti 'printf', lihat
'go tool vet help printf'.

Opsi `-n` mencetak perintah yang akan dieksekusi.
Opsi `-x` mencetak perintah saat mereka dieksekusi.

Opsi `-vettool=prog` menentukan perkakas analisis yang akan digunakan dengan
pemeriksaan alternatif atau tambahan.
Misalnya, penganalisis 'shadow' dapat dibangun dan dijalankan menggunakan
perintah berikut:

	go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow
	go vet -vettool=$(which shadow)

Opsi "build flags" yang didukung oleh "go vet" yaitu opsi-opsi yang mengontrol
eksekusi dan pencarian paket, seperti `-n`, `-x`, `-v`, `-tags`, dan
`-toolexec`.
Untuk tahu lebih banyak tentang opsi tersebut, lihat 'go help build'.

Lihat juga: `go fmt`, `go fix`.

[#hdr-Build_constraints]
== Batasan-batasan pembangunan

Sebuah batasan pembangunan, dikenal juga dengan tag _build_, adalah baris
komentar yang diawali dengan

	// +build

yang berisi daftar kondisi yang mana sebuah berkas akan disertakan dalam
paket.
Batasan-batasan tersebut bisa muncul dalam berkas sumber kode apa saja (tidak
hanya Go), namun harus berada paling atas, diawali hanya oleh baris kosong
atau baris komentar lain.
Aturan ini berarti bahwa dalam berkas Go sebuah batasan pembangunan harus
muncul sebelum klausa "package".

Untuk membedakan antara batasan pembangunan dengan dokumentasi paket,
sekumpulan batasan pembangunan harus diikuti oleh baris kosong.

Sebuah batasan pembangunan dievaluasi sebagai logika OR dari opsi-opsi yang
dipisahkan dengan spasi.
Setiap opsi dievaluasi sebagai logika AND bila dipisahkan oleh koma.
Setiap kondisi terdiri dari huruf, angka, garis bawah, dan titik.
Sebuah kondisi bisa dinegasikan dengan mengawali dengan `!`.
Sebagai contoh, batasan pembangunan berikut:

	// +build linux,386 darwin,!cgo

berkorespondensi dengan formula logika:

	(linux AND 386) OR (darwin AND (NOT cgo))

Sebuah berkas bisa memiliki banyak batasan pembangunan.
Keseluruhan batasan dievaluasi dengan operasi AND.
Batasan pembangunan berikut:

	// +build linux darwin
	// +build amd64

berkorespondensi dengan formula logika:

	(linux OR darwin) AND amd64

Saat pembangunan dilakukan, beberapa kata-kata berikut dipenuhi:

* target sistem operasi, yang dikeluarkan oleh `runtime.GOOS`, di set dengan
  variabel sistem `GOOS`
* target arsitektur, yang dikeluarkan oleh `runtime.GOARCH`, di set lewat
  variabel sistem `GOARCH`.
* _compiler_ yang digunakan, antara "gc" atau "gccgo"
* "cgo", jika perintah cgo didukung (lihat `CGO_ENABLED` dalam 'go help
  environment').
* rilis mayor dari Go, "go1.1" untuk Go versi 1.1, "go1.12" untuk Go 1.12, dan
  seterusnya.
* tag-tag tambahan yang diberikan lewat opsi "-tags" (lihat 'go help build').

Tidak ada tag-tag pembangunan yang memisahkan antara rilis beta atau minor.

Jika sebuah nama berkas, setelah ekstensi dan akhiran "_test" dihapus, cocok
dengan salah satu pola berikut:

----
*_GOOS
*_GOARCH
*_GOOS_GOARCH
----

(contoh: source_windows_amd64.go) yang mana `GOOS` dan `GOARCH`
merepresentasikan sistem operasi dan arsitektur, maka berkas tersebut dianggap
memiliki batasan pembangunan implisit (dengan tambahan batasan-batasan
eksplisit dari dalam berkas).

Menggunakan GOOS=android akan cocok dengan tag dan berkas pembangunan untuk
GOOS=linux dengan tambahan tag dan berkas untuk android.

Menggunakan GOOS=illumos akan cocok dengan tag dan berkas pembangunan untuk
GOOS=solaris dengan tambahan tag dan berkas untuk illumos.

Menggunakan GOOS=ios akan cocok dengan tag dan berkas untuk GOOS=darwin dengan
tambahan tag dan berkas khusus untuk ios.

Untuk melewati sebuah berkas dari pembangunan:

	// +build ignore

(kata lain bisa digunakan, tetapi "ignore" lebih konvensional.)

Untuk membangun sebuah berkas hanya saat menggunakan cgo, dan hanya pada Linux
dan OS X:

	// +build linux,cgo darwin,cgo

Berkas tersebut biasanya dipadukan dengan berkas lain yang mengimplementasikan
fungsionalitas baku untuk sistem berbeda, yang mana pada kasus ini akan
memiliki batasan sebaliknya:

	// +build !linux,!darwin !cgo

Menamakan sebuah berkas dengan `dns_windows.go` akan menyebabkan ia hanya
diikutkan saat membangun paket pada sistem Windows; hal yang sama,
`math_386.s` hanya akan diikutkan saat membangun paket untuk arsitektur 32-bit
x86.


[#hdr-Build_modes]
== Mode-mode pembangunan

Perintah 'go build' dan 'go install' menerima argumen `-buildmode` yang
mengindikasikan jenis berkas objek apa yang akan dibangun.
Nilai yang didukung antara lain,

`-buildmode=archive`::
	Bangun paket selain main menjadi berkas arsip `.a`.
	Paket bernama main akan diindahkan.

`-buildmode=c-archive`::
	Bangun paket main yang didaftarkan, berikut semua paket yang diimpor,
	menjadi berkas arsip C.
	Simbol-simbol yang bisa dipanggil hanya fungsi yang diekspor menggunakan
	komentar "//export" pada cgo.
	Membutuhkan paling tidak satu paket main didaftarkan.

`-buildmode=c-shared`::
	Bangun paket main yang didaftarkan, berikut semua paket yang diimport,
	menjadi sebuah pustaka C.
	Simbol-simbol yang bisa dipanggil hanya fungsi yang diekspor menggunakan
	komentar "//export" cgo.
	Membutuhkan paling tidak satu paket main didaftarkan.

`-buildmode=default`::
	Paket-paket main yang didaftarkan akan dibangun menjadi program dan paket
	selain main dibangun menjadi berkas arsip .a (perilaku bawaan).

`-buildmode=shared`::
	Gabung semua paket non-main menjadi pustaka tunggal yang akan digunakan
	untuk pembangunan dengan opsi `-linkshared`.
	Paket bernama main akan diindahkan.

`-buildmode=exe`::
	Bangun semua paket main yang didaftarkan dan semua yang diimpor menjadi
	program.
	Paket yang tidak bernama main akan diindahkan.

`-buildmode=pie`::
	Bangun semua paket main yang didaftarkan dan semua yang mereka impor
	menjadi _position independent executables_ (PIE).
	Paket yang tidak bernama main akan diindahkan.

`-buildmode=plugin`::
	Bangun paket main yang didaftarkan, berikut semua paket yang diimpor,
	menjadi sebuah plugin Go.
	Paket selain "main" akan diindahkan.

Pada AIX, saat mengaitkan program C yang menggunakan arsip Go yang dibangun
dengan -buildmode=c-archive, Anda harus mengirim -Wl,-bnoobjreorder ke
_compiler_ C.


[#hdr-Calling_between_Go_and_C]
== Pemanggilan antara Go dan C

Ada dua perbedaan cara pemanggilan antara kode Go dan C/C++.

Yang pertama yaitu perkakas cgo, yang merupakan bawaan dari distribusi Go.
Untuk informasi tentang cara penggunaannya lihat dokumentasi cgo (go doc
cmd/cgo).

Yang kedua yaitu program SWIG, yaitu sebuah perkakas umum antarmuka antar
bahasa.
Informasi lebih lanjut tentang SWIG lihat
https://swig.org/[swig.org^].
Saat menjalankan "go build", setiap berkas dengan ekstensi .swig akan dikirim
ke SWIG.
Setiap berkas dengan ekstensi .swigcxx akan dikirim ke SWIG dengan opsi
`-c++`.

Bila cgo atau SWIG tidak digunakan, "go build" akan mengirim semua berkas
.c, .m, .s, .S, atau .sx ke _compiler_ C, dan semua berkas .cc, .cpp, .cxx ke
_compiler_ C++.
Variabel lingkungan CC atau CXX bisa diset untuk menentukan _compiler_ C atau
C++ yang akan digunakan.

[#hdr-Build_and_test_caching]
== Tembolok pembangunan dan pengujian

Perintah go menyimpan hasil pembangunan untuk digunakan lagi pada pembangunan
berikutnya.
Lokasi baku dari tempat penyimpanan ini yaitu direktori bernama `go-build` di
dalam direktori tembolok pengguna sesuai dengan sistem operasi yang digunakan.
Lokasi ini dapat diganti lewat variabel lingkungan `GOCACHE`, dan menjalankan
'go env GOCACHE' akan menampilkan direktori tembolok yang sedang digunakan.

Perintah go secara berkala akan menghapus data tembolok yang jarang digunakan.
Menjalankan 'go clean --cache' menghapus semua data tembolok.

Tembolok pembangunan mencatat perubahan pada sumber kode Go, _compiler_, opsi
pada _compiler_, dan seterusnya: membersihkan tembolok secara eksplisit
sebenarnya tidak perlu dilakukan.
Namun, tembolok pembangunan tidak mendeteksi perubahan terhadap pustaka C yang
diimpor lewat cgo.
Jika Anda melakukan perubahan pada pustaka C dalam sistem Anda, Anda harus
membersihkan tembolok secara eksplisit atau gunakan opsi pembangunan -a (lihat
'go help build') untuk memaksa membangun ulang semua paket yang bergantung
pada pustaka C yang diubah.

Perintah go juga menyimpan tembolok hasil pengujian paket yang sukses.
Lihat 'go help test' untuk lebih detail.
Menjalankan 'go clean -testcache' menghapus semua tembolok hasil pengujian
(namun tetap menyimpan tembolok hasil pembangunan).

Variabel sistem GODEBUG dapat digunakan untuk menghidupkan pelacakan
(_debugging_) tentang kondisi dari tembolok:

`GODEBUG=gocacheverify=1` menyebabkan perintah go mengindahkan tembolok
sehingga memaksa membangun ulang semuanya dan memeriksa apakah hasilnya sesuai
dengan isi tembolok sekarang.

`GODEBUG=gocachehash=1` menyebabkan perintah go mencetak input yang di-_hash_
untuk membangun kunci pencarian tembolok.
Keluaran dari pelacakan ini sangat banyak namun berguna untuk memeriksa
tembolok.

`GODEBUG=gocachetest=1` menyebabkan perintah go mencetak detail keputusan
apakah memakai ulang hasil pengujian di tembolok atau tidak.


[#hdr-Environment_variables]
== Variabel lingkungan

Perintah go dan perkakas yang dieksekusi, membaca variabel lingkungan untuk
konfigurasi.
Jika sebuah variabel lingkungan tidak diset, perintah go menggunakan
pengaturan bawaan.
Untuk melihat pengaturan efektif dari variabel <NAME>, jalankan
'go env <NAME>'.
Untuk mengganti pengaturan bawaan, jalankan 'go env -w <NAME>=<VALUE>'.
Perubahan dari 'go env -w' dicatat dalam berkas konfigurasi Go yang disimpan
dalam direktori konfigurasi user, yang diambil lewat `os.UserConfigDir`.
Lokasi dari berkas konfigurasi dapat diganti dengan men-set variabel
lingkungan `GOENV`, dan 'go env GOENV' mencetak lokasi efektifnya, namun
'go env -w' tidak bisa mengganti lokasi bawaannya.
Lihat 'go help env' untuk lebih detail.

Variabel lingkungan untuk tujuan umum:

`GO111MODULE`::
    Mengontrol apakah perintah go berjalan dengan mode GOPATH atau modul.
    Bisa "off", "on", atau "auto".
    Lihat https://golang.org/ref/mod#mod-commands .

`GCCGO`::
    Mengatur perintah gccgo untuk menjalankan 'go build -compiler=gccgo'.

`GOARCH`::
    Arsitektur, atau prosesor, tujuan dari kode yang akan dikompilasi.
    Contohnya amd64, 386, arm, ppc64.

`GOBIN`::
    Direktori tempat 'go install' akan memasang hasil pembangunan program.

`GOCACHE`::
    Direktori tempat perintah go akan menyimpan informasi tembolok untuk
    digunakan pada pembangunan berikutnya.

`GOMODCACHE`::
    Direktori tempat perintah go akan menyimpan modul-modul yang diunduh.

`GODEBUG`::
    Menghidupkan beragam fasilitas pelacakan.
    Lihat 'go doc runtime' untuk detail.

`GOENV`::
    Lokasi dari berkas konfigurasi lingkungan.
    Tidak dapat di set menggunakan 'go env -w'.

`GOFLAGS`::
    Daftar pengaturan `-flag=value` yang dikirim ke perintah go.
    Karena setiap input dipisahkan oleh spasi, nilai dari flag tidak boleh
    berisi spasi.
    Flag-flag yang didaftarkan pada baris perintah diterapkan setelah daftar
    ini dan oleh karena itu bisa menimpanya.

`GOINSECURE`::
    Daftar prefiks path modul dengan pola _glob_, yang dipisahkan oleh koma,
    (dengan sintak sesuai dengan `path.Match`) yang diunduh dengan cara tidak
    aman.
    Hanya berlaku untuk dependensi yang diambil secara langsung.
    `GOINSECURE` tidak mematikan validasi _checksum_.
    `GOPRIVATE` atau `GONOSUMDB` bisa digunakan untuk hal tersebut.

`GOOS`::
    Sistem operasi tujuan untuk kode yang akan dikompilasi.
    Contohnya linux, darwin, windows, netbsd.

`GOPATH`::
    Untuk lebih detail lihat: 'go help gopath'.

`GOPROXY`::
    URL untuk proksi modul Go.
    Lihat
    https://golang.org/ref/mod#environment-variables
    dan
    https://golang.org/ref/mod#module-proxy
    untuk lebih detail.

`GOPRIVATE`, `GONOPROXY`, `GONOSUMDB`::
    Daftar prefiks path modul, dengan pola _glob_ dipisahkan oleh koma (sesuai
    dengan sintaks `path.Match`), yang harus diambil secara langsung atau yang
    tidak dibandingkan dengan basis data _checksum_.
	Lihat https://golang.org/ref/mod#private-modules .

`GOROOT`::
    Lokasi utama dari perkakas go.

`GOSUMDB`::
    Nama basis data _checksum_ yang digunakan, berikut pilihan kunci publik
    dan URL-nya.
    Lihat https://golang.org/ref/mod#authenticating .

`GOTMPDIR`::
    Direktori tempat perintah go menulis berkas sumber, paket, dan program
    untuk sementara.

`GOVCS`::
    Daftar perintah _version control_ yang digunakan sesuai dengan peladen.
	Lihat 'go help vcs'.

Variabel lingkungan yang digunakan dengan cgo:

`AR`::
    Program yang digunakan untuk memanipulasi arsip pustaka saat membangun
    dengan _compiler_ gccgo.
	Nilai bakunya adalah 'ar'.

`CC`::
    Program yang digunakan untuk mengompilasi kode C.

`CGO_ENABLED`::
    Menentukan apakah perintah cgo dihidupkan atau tidak.
    Nilainya antara 0 atau 1.

`CGO_CFLAGS`::
    Opsi yang cgo kirim ke _compiler_ saat mengompilasi kode C.

`CGO_CFLAGS_ALLOW`::
    _Regular expression_ yang menentukan opsi-opsi tambahan yang boleh muncul
    dalam sumber kode perintah `#cgo CFLAGS`.
    Tidak berlaku untuk variabel lingkungan `CGO_CFLAGS`.

`CGO_CFLAGS_DISALLOW`::
    _Regular expression_ yang menentukan opsi-opsi yang tidak dibolehkan
    muncul dalam perintah sumber kode `#cgo CFLAGS`.
    Tidak berlaku untuk variabel lingkungan `CGO_CFLAGS`.

`CGO_CPPFLAGS`, `CGO_CPPFLAGS_ALLOW, `CGO_CPPFLAGS_DISALLOW`::
    Seperti `CGO_CFLAGS`, `CGO_CFLAGS_ALLOW`, dan `CGO_CFLAGS_DISALLOW` namun
    untuk pra-proses C.

`CGO_CXXFLAGS`, `CGO_CXXFLAGS_ALLOW`, `CGO_CXXFLAGS_DISALLOW`::
    Seperti `CGO_CFLAGS`, `CGO_CFLAGS_ALLOW`, dan `CGO_CFLAGS_DISALLOW` namun
    untuk _compiler_ C++.

`CGO_FFLAGS`, `CGO_FFLAGS_ALLOW`, `CGO_FFLAGS_DISALLOW`::
    Seperti `CGO_CFLAGS`, `CGO_CFLAGS_ALLOW`, dan `CGO_CFLAGS_DISALLOW` namun
    untuk _compiler_ Fortran.

`CGO_LDFLAGS`, `CGO_LDFLAGS_ALLOW`, `CGO_LDFLAGS_DISALLOW`::
    Seperti `CGO_CFLAGS`, `CGO_CFLAGS_ALLOW`, dan `CGO_CFLAGS_DISALLOW` namun
    untuk _linker_.

`CXX`::
    Program yang digunakan untuk mengompilasi kode C++.

`FC`::
    Program yang digunakan untuk mengompilasi kode Fortran.

`PKG_CONFIG`::
    Lokasi perkakas pkg-config.

Variabel lingkungan untuk arsitektur tertentu:

`GOARM`::
    Untuk `GOARCH=arm`, menentukan arsitektur ARM dari target kompilasi.
    Nilai validnya adalah 5, 6, 7.

`GO386`::
    Untuk `GOARCH=386`, menentukan implementasi instruksi _floating-point_
    yang akan digunakan.
    Nilai validnya adalah `sse2` (baku), `softfloat`.

`GOMIPS`::
	Untuk `GOARCH=mips{,le}`, menentukan instruksi _floating-point_ yang akan
    digunakan.
	Nilai validnya adalah `hardfloat` (baku), `softfloat`.

`GOMIPS64`::
    Untuk `GOARCH=mips64{,le}`, menentukan instruksi _floating-point_ yang
    akan digunakan.
	Nilai valid-nya adalah `hardfloat` (baku), `softfloat`.

`GOWASM`::
	Untuk `GOARCH=wasm`, berisi daftar fitur eksperimental WebAssembly yang
    akan digunakan, dipisahkan oleh koma.
    Nilai valid-nya adalah `satconv`, `signext`.

Variabel lingkungan untuk tujuan tertentu:

`GCCGOTOOLDIR`::
    Jika diset, menentukan lokasi pencarian perkakas gccgo, seperti cgo.
    Nilai bakunya berdasarkan bagaimana gccgo dikonfigurasi.

`GOROOT_FINAL`::
    Direktori tempat Go dipasang, jika Go dipasang di direktori yang berbeda
    dengan tempat dibangun.
    Nama berkas saat mencetak _stack traces_ diganti dari `GOROOT` menjadi
    `GOROOT_FINAL`.

`GO_EXTLINK_ENABLED`::
    Menentukan apakah _linker_ menggunakan mode _linking_ eksternal saat
    menggunakan `-linkmode=auto` untuk kode yang menggunakan cgo.
    Set ke 0 untuk mematikan mode penautan eksternal, 1 untuk menghidupkan.

`GIT_ALLOW_PROTOCOL`::
    Didefinisikan oleh Git.
    Daftar skema, dipisahkan dengan ':', yang boleh digunakan pada saat
    `git fetch/clone`.
    Jika di set, setiap skema yang secara eksplisit tidak dicantumkan akan
    dianggap sebagai tidak aman oleh 'go get'.
    Secara nilai variabel ini ditentukan oleh Git, nilai bakunya tidak bisa
    diganti lewat 'go env -w'.

Informasi tambahan yang tersedia lewat 'go env' tapi tidak dibaca dari
lingkungan:

`GOEXE`::
    Nama ekstensi untuk berkas program hasil pembangunan (".exe" pada Windows,
    "" untuk sistem lain).

`GOGCCFLAGS`::
    Daftar argumen, dipisahkan oleh spasi, yang dikirimkan ke perintah CC.

`GOHOSTARCH`::
    Arsitektur (`GOARCH`) dari perkakas Go yang terpasang.

`GOHOSTOS`::
    Sistem operasi (`GOOS`) dari perkakas Go yang terpasang.

`GOMOD`::
    Lokasi absolut dari berkas go.mod pada modul utama.
    Jika mode modul dihidupkan, tapi berkas go.mod tidak ditemukan, `GOMOD`
    akan berisi `os.DevNull` ("/dev/null" pada sistem berbasis Unix, "NUL"
    pada Windows).
    Jika mode modul dimatikan, `GOMOD` akan berisi string kosong.

`GOTOOLDIR`::
    Direktori tempat perkakas go (compile, cover, doc, dll) dipasang.

`GOVERSION`::
    Versi dari Go yang terpasang, seperti yang dilaporkan oleh
    `runtime.Version`.


[#hdr-File_types]
== Tipe-tipe berkas

Perintah go memeriksa isi dari direktori dengan batasan berkas tertentu.
Go mengidentifikasi berkas mana yang diperiksa berdasarkan ekstensi dari nama
berkas.
Ekstensi tersebut antara lain:

`.go`::
    Sumber kode Go.

`.c`, `.h`::
    Sumber kode C.
    Jika paket menggunakan cgo atau SWIG, berkas ini akan dikompilasi dengan
    _compiler_ bawaan sistem operasi (biasanya gcc); selain itu akan mencetak
    pesan kesalahan.

`.cc`, `.cpp`, `.cxx`, `.hh`, `.hpp`, `.hxx`::
    Sumber kode C++.
    Hanya berlaku pada cgo atau SWIG, dan selalu dikompilasi dengan _compiler_
    bawaan sistem operasi.

`.m`::
    Sumber kode Objective-C.
    Hanya berlaku pada cgo, dan selalu dikompilasi dengan _compiler_ bawaan
    OS.

`.s`, `.S`, `.sx`::
    Sumber kode assembler.
    Jika paket menggunakan cgo atau SWIG, berkas ini akan digabungkan dengan
    _assembler_ bawaan sistem operasi (biasanya gcc); selain itu akan
    digabungkan dengan Go assembler.

`.swig`, `.swigcxx`::
    Berkas definisi SWIG.

`.syso`::
    Berkas objek sistem.

Berkas dari setiap tipe-tipe tersebut kecuali `.syso` bisa berisi batasan
pembangunan (komentar `//+build`), namun perintah go akan berhenti mencari
batasan pembangunan bila baris pertama pada berkas bukan baris kosong atau
bukan baris komentar dengan prefiks `//`.
Lihat dokumentasi go/build untuk lebih detail.


[#hdr-The_go_mod_file]
== Berkas go.mod

Sebuah versi modul didefinisikan oleh kumpulan berkas, dengan sebuah berkas
go.mod pada _root_ direktori.
Saat perintah go berjalan, ia akan mencari berkas go.mod tersebut di direktori
sekarang dan di direktori di atas-nya untuk menentukan _root_ dari modul
utama.

Format berkas go.mod dijelaskan secara detail di
https://golang.org/ref/mod#go-mod-file.

Untuk membuat berkas go.mod yang baru, gunakan 'go mod init'.
Untuk detail lihat 'go help mod init' atau
https://golang.org/ref/mod#go-mod-init.

Untuk menambahkan modul yang kurang atau menghapus modul yang tidak
dibutuhkan, gunakan 'go mod tidy'.
Untuk detail, lihat 'go help mod tidy' atau
https://golang.org/ref/mod#go-mod-tidy.

Untuk menambah, meningkatkan atau menurunkan versi modul, atau menghapus modul
tertentu, gunakan 'go get'.
Untuk detail-nya, lihat 'go help module-get' atau
https://golang.org/ref/mod#go-get.

Untuk membuat perubahan lain atau membaca go.mod sebagai JSON untuk digunakan
oleh perkakas lain, gunakan 'go mod edit'.
Lihat 'go help mod edit' atau
https://golang.org/ref/mod#go-mod-edit.

[#hdr-GOPATH_environment_variable]
== Variabel lingkungan GOPATH

Variabel lingkungan `GOPATH` berisi daftar direktori untuk mencari kode Go.
Pada Unix, nilainya adalah string yang dipisahkan oleh titik-dua ":".
Pada Windows, nilainya adalah string yang dipisahkan oleh titik-koma ";".
Pada Plan 9, nilainya adalah sebuah daftar.

Jika `GOPATH` tidak diset, nilai bakunya adalah direktori bernama "go" di
dalam rumah direktori user (`$HOME/go` pada Unix, `%USERPROFILE%` pada
Windows), kecuali bila direktori tersebut telah berisi pemasangan distribusi
Go.
Jalankan "go env GOPATH" untuk melihat nilai `GOPATH`.

Lihat https://golang.org/wiki/SettingGOPATH untuk menset nilai `GOPATH`.

Setiap direktori yang terdaftar dalam `GOPATH` haruslah memiliki struktur
sebagai berikut:

Direktori `src` menyimpan sumber kode.
Path yang ada di dalam `src` menentukan path impor atau nama program.

Direktori `pkg` menyimpan pemasangan objek-objek paket.
Seperti pada distribusi Go, setiap pasangan target sistem operasi dan
arsitektur memiliki sub-direktori sendiri (`pkg/GOOS_GOARCH`).

Jika `DIR` adalah sebuah direktori dalam `GOPATH`, sebuah paket dengan sumber
kode dalam `DIR/src/foo/bar` dapat diimpor lewat "foo/bar" dan hasil
kompilasinya dipasang ke "DIR/pkg/GOOS_GOARCH/foo/bar.a".

Direktori `bin` menyimpan hasil kompilasi program.
Setiap program memiliki nama sesuai dengan nama sumber direktorinya, namun
hanya elemen direktori terakhir, bukan keseluruhan _path_.
Misalnya, program dengan sumber kode dalam `DIR/src/foo/quux` dipasang ke
`DIR/bin/quux`, bukan `DIR/bin/foo/quux`.
Prefiks "foo/" dihapus supaya Anda bisa menambahkan `DIR/bin` ke variabel
lingkungan `PATH` pada sistem operasi Anda.
Jika variabel lingkungan `GOBIN` diset, program-program akan dipasang ke dalam
direktori tersebut bukan ke `DIR/bin`.
Nilai dari `GOBIN` haruslah path absolut.

Berikut contoh struktur direktori:

----
GOPATH=/home/user/go

/home/user/go/
    src/
        foo/
            bar/               (kode Go dalam paket bar)
                x.go
            quux/              (kode Go dalam paket main)
                y.go
    bin/
        quux                   (program yang terpasang)
    pkg/
        linux_amd64/
            foo/
                bar.a          (objek paket yang terpasang)
----

Go mencari setiap direktori yang terdaftar dalam `GOPATH` untuk mencari sumber
kode, namun paket-paket yang baru selalu diunduh ke direktori pertama dalam
daftar tersebut.

Lihat
link:/doc/code.html
sebagai contohnya.

[#hdr-GOPATH_and_Modules]
== GOPATH dan modul

Saat menggunakan mode modul, `GOPATH` tidak digunakan lagi untuk mencari
impor.
Namun, ia masih digunakan untuk menyimpan sumber kode yang diunduh (dalam
`GOPATH/pkg/mod`) dan menyimpan program yang dikompilasi (dalam `GOPATH/bin`).


[#hdr-Internal_Directories]
== Direktori internal

Kode yang ada di dalam direktori bernama "internal" hanya bisa diimpor oleh
kode-kode dalam direktori di atas dari "internal".
Berikut versi tambahan dari struktur direktori di atas:

----
/home/user/go/
    src/
        crash/
            bang/              (kode go dalam paket bang)
                b.go
        foo/                   (kode go dalam paket foo)
            f.go
            bar/               (kode go dalam paket bar)
                x.go
            internal/
                baz/           (kode go dalam paket baz)
                    z.go
            quux/              (kode go dalam paket main)
                y.go
----

Kode dalam `z.go` diimpor sebagai "foo/internal/baz", namun perintah impor
tersebut hanya dapat dilakukan dalam berkas sumber dari dalam direktori `foo`
dan turunannya.
Berkas sumber `foo/f.go`, `foo/bar/x.go`, dan `foo/quux/y.go` dapat mengimpor
"foo/internal/baz", namun berkas sumber `crash/bang/b.go` tidak bisa.

Lihat https://golang.org/s/go14internal untuk lebih detailnya.

[#hdr-Vendor_Directories]
== Direktori vendor

Go 1.6 mendukung penggunaan salinan lokal dari dependensi eksternal untuk
memenuhi impor-impor dari dependensi tersebut, sering juga disebut dengan
istilah _vendoring_.

Kode di dalam direktori bernama "vendor" hanya dapat diimpor oleh kode dalam
direktori dan sub-direktori dari bagian atas "vendor", dan hanya dengan
menggunakan path impor yang mengindahkan prefiks sampai ke elemen vendor.

Berikut contoh dari bagian sebelumnya, tapi dengan direktori "internal"
diganti nama dengan "vendor" dan sebuah direktori "foo/vendor/crash/bang"
ditambahkan:

----
/home/user/go/
    src/
        crash/
            bang/              (kode go dalam paket bang)
                b.go
        foo/                   (kode go dalam paket foo)
            f.go
            bar/               (kode go dalam paket bar)
                x.go
            vendor/
                crash/
                    bang/      (kode go dalam paket bang)
                        b.go
                baz/           (kode go dalam paket baz)
                    z.go
            quux/              (kode go dalam paket main)
                y.go
----

Aturan impor diterapkan sebagaimana pada direktori internal, namun kode dalam
z.go diimpor sebagai "baz", bukan sebagai "foo/vendor/baz".

Kode di dalam direktori vendor menimpa kode pada direktori di atasnya.
Misalnya, kode-kode di bawah direktori "foo" yang mengimpor "crash/bang" akan
menunjuk ke "foo/vendor/crash/bang", bukan bagian teratas "crash/bang".

Kode di dalam direktori vendor tidak ada pemeriksaan path impor (lihat 'go
help importpath').

Saat 'go get' mengambil atau memperbarui sebuah repositori git, ia juga akan
memperbarui `submodules`.

Direktori vendor tidak memengaruhi penempatan dari repositori-repositori baru
yang diunduh pertama kali oleh 'go get': repositori tersebut selalu disimpan
dalam `GOPATH`, tidak dalam direktori vendor.

Lihat https://golang.org/s/go15vendor untuk lebih detailnya.


[#hdr-Legacy_GOPATH_go_get]
== Legasi GOPATH go get

Perintah 'go get' memiliki perilaku yang berbeda bergantung pada apakah
perintah go berjalan dengan mode modul atau mode legasi GOPATH.
Teks bantuan untuk legasi GOPATH berikut, yang dapat diakses juga lewat 'go
help gopath-get' bahkan untuk mode modul, menjelaskan 'go get' yang beroperasi
dengan mode legasi GOPATH.

Penggunaan: go get [-d] [-f] [-t] [-u] [-v] [-fix] [opsi build] [paket]

Perintah get mengunduh paket-paket berdasarkan nama dari path impor, berikut
dengan dependensinya.
Ia kemudian memasang paket-paket tersebut, seperti dengan 'go install'.

Opsi -d membuat perintah `get` berhenti setelah mengunduh paket; tidak
memasang paket tersebut.

Opsi -f, hanya berlaku bila -u juga digunakan, memaksa perintah `get -u` untuk
tidak memeriksa bahwa setiap paket telah diunduh dari repositori yang ditandai
oleh path impor-nya.
Opsi ini bisa digunakan jika sumber repositori adalah salinan lokal dari yang
aslinya.

Opsi -fix membuat perintah get menjalankan perkakas `fix` pada paket-paket
yang diunduh sebelum mencari dependensi atau membangun kode.

Opsi -t membuat perintah get juga mengunduh paket-paket yang dibutuhkan untuk
membangun pengujian untuk paket-paket yang ditentukan.

Opsi -u membuat perintah get memperbarui paket-paket yang diberikan berikut
dengan dependensinya.
Secara bawaan, `get` menggunakan jaringan internet untuk mengunduh paket yang
kurang tapi tidak untuk mencari pembaruan dari paket-paket yang telah
terpasang.

Opsi -v membuat perintah `get` menampilkan progres dan pelacakan lebih lanjut.

Perintah `get` juga dapat menerima opsi dari perintah `build` untuk mengontrol
pemasangan.
Lihat 'go help build'.

Saat mengunduh sebuah paket yang baru, `get` membuat direktori target
`GOPATH/src/<import-path>`.
Jika `GOPATH` berisi lebih dari satu direktori, `get` menggunakan direktori
yang pertama.
Untuk detail lebih lanjut lihat: 'go help gopath'.

Saat mengunduh atau memperbarui sebuah paket, `get` mencari _branch_ atau
_tag_ yang sesuai dengan versi Go yang terpasang di lokal.
Aturannya yaitu jika versi pemasangan Go di lokal yaitu "go1", get akan
mencari _branch_ atau _tag_ bernama "go1".
Jika versi tersebut tidak ada ia akan mengambil _branch_ bawaan dari paket.

Saat `go get` mengunduh atau memperbarui sebuah repositori Git, ia juga
memperbarui `git submodules` yang diacu oleh repositori tersebut.

Perintah `get` tidak pernah mengunduh atau memperbarui kode yang disimpan
dalam direktori vendor.

Untuk informasi lebih lanjut tentang parameter paket, lihat 'go help
packages'.

Untuk informasi tentang bagaimana 'go get' mencari sumber kode untuk diunduh,
lihat 'go help importpath'.

Bagian ini menjelaskan perilaku perintah `get` bila menggunakan `GOPATH` untuk
mengatur sumber kode dan dependensi.
Jika perintah go berjalan dalam mode modul, detail dari opsi `get` dan
efeknya berubah, seperti yang dijelaskan pada 'go help get'.
Lihat 'go help modules' dan 'go help module-get'.

Lihat juga: `go build`, `go install`, `go clean`.

[#hdr-Module_proxy_protocol]
== Protokol proksi modul

Sebuah proksi Go modul adalah peladen web yang dapat merespon permintaan GET
untuk URL dari bentuk tertentu.
Permintaan tersebut tidak memiliki parameter kueri, bahkan sebuah situs yang
melayani sistem berkas yang statik (termasuk sebuah URL `file:///`)
bisa menjadi proksi modul.

Untuk detail tentang protokol `GOPROXY`, lihat
https://golang.org/ref/mod#goproxy-protocol.


[#hdr-Import_path_syntax]
== Sintaksis path impor

Sebuah path impor (lihat 'go help packages') menandakan sebuah paket yang
disimpan dalam sistem berkas lokal.
Secara umum, sebuah path impor menandakan sebuah paket standar (seperti
"unicode/utf8") atau sebuah paket yang ditemukan dalam salah satu ruang kerja
(Untuk informasi lebih detail lihat: 'go help gopath').


[#hdr-Relative_import_paths]
== Path impor relatif

Sebuah path impor yang dimulai dengan `./` atau `../` disebut dengan path
relatif.
Perkakas Go mendukung path impor relatif sebagai penyingkat dengan dua cara.

Pertama, sebuah path relatif dapat digunakan sebagai singkatan pada baris
perintah.
Jika Anda misalkan sedang bekerja dalam direktori yang berisi kode yang
diimpor sebagai "unicode" dan ingin menjalankan pengujian untuk
"unicode/utf8", Anda bisa menjalankan "go test ./utf8" tanpa perlu menulis
keseluruhan path.
Hal yang sama, dengan situasi yang sebaliknya, "go test .." akan menjalankan
pengujian "unicode" jika dijalankan dari dalam direktori "unicode/utf8".
Pola relatif juga dibolehkan, seperti "go test ./..." untuk menguji semua
sub-direktori.
Lihat 'go help packages' untuk detail tentang sintaksis pola.

Kedua, jika Anda mengompilasi sebuah program Go bukan dari ruang kerja, Anda
bisa menggunakan path relatif pada perintah impor dalam program tersebut untuk
mengacu ke kode terdekat yang juga tidak dalam ruang kerja.
Hal ini mempermudah bereksperimen dengan program kecil di luar ruang kerja
yang biasa, namun program tersebut tidak bisa dipasang dengan "go install"
(tidak ada ruang kerja tempat ia akan dipasang), jadi program tersebut akan
selalu dibangun ulang dari awal setiap kali pembangunan dilakukan.
Untuk menghindari ambiguitas, program Go tidak bisa menggunakan path impor
relatif dari dalam ruang kerja.


[#hdr-Remote_import_paths]
== Path impor asing (_remote_)

Beberapa path impor juga menentukan bagaimana mendapatkan sumber kode dari
paket tersebut menggunakan sebuah sistem kontrol revisi (_version control
system_ atau VCS).

Beberapa situs penyimpanan kode umum memiliki sintaksis khusus:

* Bitbucket (Git, Mercurial)

    import "bitbucket.org/user/project"
    import "bitbucket.org/user/project/sub/directory"

* GitHub (Git)

	import "github.com/user/project"
	import "github.com/user/project/sub/directory"

* Launchpad (Bazaar)

	import "launchpad.net/project"
	import "launchpad.net/project/series"
	import "launchpad.net/project/series/sub/directory"

	import "launchpad.net/~user/project/branch"
	import "launchpad.net/~user/project/branch/sub/directory"

* IBM DevOps Services (Git)

	import "hub.jazz.net/git/user/project"
	import "hub.jazz.net/git/user/project/sub/directory"

Untuk kode yang disimpan pada peladen lain, path impor bisa ditambahkan dengan
tipe pengontrol versi, atau perkakas go bisa secara dinamik mengambil path
impor lewat https/http dan menentukan di mana kode disimpan berdasarkan tag
`<meta>` dalam HTML.

Untuk mendeklarasikan lokasi kode, sebuah path impor dengan bentuk

    repository.vcs/path

menentukan repositori, dengan atau tanpa sufiks `.vcs`, menggunakan nama VCS,
dan path dalam repositori.
Nilai VCS yang didukung antara lain:

----
Bazaar      .bzr
Fossil      .fossil
Git         .git
Mercurial   .hg
Subversion  .svn
----

Misalnya,

    import "example.org/user/foo.hg"

menyatakan direktori dari repositori Mercurial pada example.org/user/foo atau
foo.hg, dan

    import "example.org/repo.git/foo/bar"

menyatakan foo/bar direktori sebagai repositori Git pada example.org/repo atau
repo.git.

Saat sebuah VCS mendukung beberapa protokol, setiap protokol akan dicoba
bergantian saat melakukan pengunduhan.
Misalnya, pengunduhan Git mencoba `+https://+`, kemudian `+git+ssh://+`.

Secara bawaan, pengunduhan dibatasi hanya untuk protokol yang aman (misalnya
https, ssh).
Untuk menimpa pengaturan ini pada saat pengunduhan dengan Git, variabel
lingkungan `GIT_ALLOW_PROTOCOL` dapat diset (Untuk detail lebih lanjut lihat:
'go help environment').

Jika path impor bukan dari situs yang dikenal dan juga tidak memiliki penanda
VCS, perkakas go mencoba mengambil path impor lewat https/http dan mencari tag
`<meta>` dalam HTML dokumen `<head>`.

Tag meta tersebut memiliki bentuk berikut:

    <meta name="go-import" content="import-prefix vcs repo-root">

Bagian `import-prefix` adalah path impor yang berkorespondensi dengan root
repositori.
Nilainya haruslah sebuah prefiks atau path dari paket yang akan diambil lewat
"go get".
Jika path tidak sesuai, permintaan http berikutnya dilakukan terhadap
`import-prefix` untuk memverifikasi bahwa tag `<meta>` cocok.

Tag `meta` sebaiknya berada paling awal dalam berkas HTML sebisa mungkin.
Secara khusus, sebaiknya muncul sebelum ada JavaScript atau CSS, untuk
menghindari kesalahan penguraian pada perintah Go yang terbatas.

Bagian `vcs` yaitu salah satu dari "bzr", "fossil", "git", "hg", "svn".

Bagian `repo-root` yaitu root dari VCS yang berisi sebuah skema dan tidak
berisi `.vcs`.

Misalnya,

    import "example.org/pkg/foo"

akan menghasilkan beberapa permintaan berikut:

----
https://example.org/pkg/foo?go-get=1 (direkomendasikan)
http://example.org/pkg/foo?go-get=1  (pilihan terakhir, hanya bila GOINSECURE diset)
----

Jika halaman kembalian berisi tag `meta` berikut

----
<meta name="go-import" content="example.org git https://code.org/r/p/exproj">
----

perkakas go akan memverifikasi bahwa https://example.og/?go-get=1 berisi tag
`meta` yang sama dan kemudian mengeksekusi

    git clone https://code.org/r/p/exproj

ke dalam

    GOPATH/src/example.org

Bila menggunakan mode `GOPATH`, paket-paket yang diunduh akan disimpan dalam
direktori pertama yang terdaftar dalam variabel lingkungan `GOPATH`.
(Lihat 'go help gopath-get' dan 'go help gopath'.)

Bila menggunakan mode modul, paket-paket yang diunduh disimpan dalam tembolok
modul.
Lihat https://golang.org/ref/mod#module-cache.

Bila menggunakan mode modul, sebuah variasi tambahan dari tag meta `go-import`
akan dikenali dan dipilih.
Variasi tersebut menggunakan "mod" sebagai nilai dalam `vcs`, seperti berikut:

----
<meta name="go-import" content="example.org mod https://code.org/moduleproxy">
----

Tag tersebut berarti untuk mengunduh modul dengan path yang diawali dengan
`example.org` dari proksi modul lewat URL https://code.org/moduleproxy.
Lihat https://golang.org/ref/mod#goproxy-protocol untuk detail tentang
protokol proksi.


[#hdr-Import_path_checking]
== Pemeriksaan path impor

Saat fitur path impor kostum seperti yang dijelaskan di atas dialihkan ke
situs penyimpanan yang dikenal, maka setiap paket-paket bisa memiliki dua path
impor, menggunakan domain kostum atau lewat situs penyimpanan.

Sebuah perintah paket dikatakan memiliki "komentar impor" jika ia diikuti oleh
(sebelum baris baru selanjutnya) oleh sebuah komentar dengan dua bentuk
berikut:

----
package math // import "path"
package math /* import "path" */
----

Perintah go akan menolak memasang sebuah paket dengan komentar impor kecuali
bila ia diacu dengan path impor tersebut.
Dengan cara ini, komentar impor membolehkan pemilik paket memastikan bahwa
path impor kostum yang digunakan dan bukan path langsung ke situs penyimpanan.

Pemeriksaan path impor dimatikan untuk kode yang ditemukan dalam direktori
vendor.
Hal ini membolehkan menyalin kode ke dalam lokasi alternatif dalam direktori
vendor tanpa perlu mengganti komentar impor.

Pemeriksaan path impor juga dimatikan saat menggunakan modul.
Komentar path impor sudah tidak berlaku lagi karena digantikan oleh berkas
go.mod lewat baris perintah `module`.

Lihat https://golang.org/s/go14customimport untuk detailnya.


[#hdr-Modules__module_versions__and_more]
== Modul, versi modul, dan lainnya

Modul adalah bagaimana Go mengatur dependensi.

Sebuah modul adalah koleksi dari paket-paket yang dirilis, diberi versi, dan
didistribusikan bersamaan.
Modul bisa diunduh langsung lewat repositori VCS atau lewat peladen proksi
modul.

Untuk seri tutorial tentang modul, lihat
https://golang.org/doc/tutorial/create-module.

Untuk referensi detail tentang modul, lihat
https://golang.org/ref/mod.

Secara bawaan, perintah go bisa mengunduh modul lewat
https://proxy.golang.org.
Ia bisa melakukan autentikasi modul menggunakan basis data _checksum_ pada
https://sum.golang.org.
Kedua layanan ini dioperasikan oleh tim Go pada Google.
Kebijakan privasi bagi layanan tersebut dapat dilihat di
https://proxy.golang.org/privacy
dan
https://sum.golang.org/privacy.

Perilaku pengunduhan dari perintah Go bisa diatur lewat variabel lingkungan
`GOPROXY`, `GOSUMDB`, `GOPRIVATE`, dan lainnya.
Lihat 'go help environment' dan
https://golang.org/ref/mod#private-module-privacy
untuk informasi lebih lanjut.

[#hdr-Module_authentication_using_go_sum]
== Autentikasi modul menggunakan go.sum

Saat perintah go mengunduh sebuah berkas zip dari modul atau berkas go.mod ke
dalam tembolok modul, ia akan menghitung _hash_ kriptografi dan
membandingkannya dengan nilai yang diketahui untuk memverifikasi bahwa berkas
tersebut belum berubah sejak ia diunduh pertama kalinya.
Daftar _hash_ yang dikenal tersebut disimpan dalam sebuah berkas dalam
direktori modul bernama `go.sum`.
Daftar _hash_ tersebut juga bisa diunduh lewat basis data _checksum_
bergantung pada nilai dari `GOSUMDB`, `GOPRIVATE`, dan `GONOSUMDB`.

Untuk detailnya, lihat
https://golang.org/ref/mod#authenticating.

[#hdr-Package_lists_and_patterns]
== Daftar dan pola paket

Banyak perintah Go berlaku untuk sekumpulan paket-paket:

    go action [packages]

Biasanya, `[packages]` adalah daftar dari path impor.

Sebuah path impor yang absolut atau dimulai dengan `.` atau `..`
diinterpretasikan sebagai path pada sistem berkas dan menyatakan paket dalam
direktori tersebut.

Selain itu, path impor `P` menyatakan paket ditemukan dalam direktori
`DIR/src/P` untuk `DIR` yang terdaftar dalam variabel lingkungan `GOPATH`
(Untuk detail lebih lanjut lihat: 'go help gopath').

Jika tidak ada path impor yang diberikan, maka aksi dari perintah go tersebut
berlaku untuk paket dalam direktori yang sekarang.

Ada empat nama untuk path yang sebaiknya tidak digunakan untuk nama paket yang
akan dibangun dengan perkakas go:

* "main" menyatakan paket teratas dari program yang berdiri sendiri.

* "all" akan dikembangkan menjadi semua paket yang ditemukan dalam semua
  direktori GOPATH.
  Misalnya, 'go list all' mencetak semua paket dalam sistem lokal.
  Saat menggunakan modul, "all" berarti semua paket dalam modul utama dan
  dependensinya, termasuk dependensi yang dibutuhkan untuk pengujian.

* "std" mirip dengan "all" tapi dikembangkan hanya menjadi paket-paket dalam
  pustaka standar Go.

* "cmd" dikembangkan menjadi repositori Go dan pustaka internalnya.

Path impor yang diawali dengan "cmd/" hanya dicocokan dengan sumber kode dalam
repositori Go.

Sebuah path impor adalah sebuah pola jika ia mengikutkan satu atau lebih
"..." _wildcard_, setiap _wildcard_ dapat dicocokan dengan string apapun,
termasuk string kosong dan string yang berisi _slash_ "/".
Pola seperti itu dikembangkan menjadi semua direktori paket yang ditemukan
dalam `GOPATH` dengan nama yang sesuai dengan pola.

Supaya pola umum lebih gampang, ada dua kasus khusus.
Pertama, `+/...+` di akhir dari pola dapat cocok dengan string kosong,
sehingga `+net/...+` cocok dengan `net` dan paket-paket dalam sub-direktori
nya, seperti `net/http`.
Kedua, setiap pola yang dipisahkan oleh _slash_ "/" yang berisi sebuah
_wildcard_ tidak diikutkan dalam pencocokan dengan elemen "vendor", sehingga
`+./...+` tidak dicocokan dengan paket-paket dalam direktori `./vendor` atau
`./mycode/vendor`, namun `+./vendor/...+` dan `+./mycode/vendor/...+` bisa.
Ingatlah, bahwa sebuah direktori bernama "vendor" yang berisi kode bukanlah
paket yang di-vendor-kan: `cmd/vendor` berarti sebuah program bernama
`vendor`, dan pola `+./cmd/...+` akan mengikutkannya.
Lihat https://golang.org/s/go15vendor untuk informasi tentang _vendoring_.

Sebuah path impor bisa mengikutkan sebuah paket yang akan diunduh dari
repositori _remote_.
Lihat 'go help importpath' untuk detailnya.

Setiap paket dalam sebuah program haruslah memiliki path impor yang unik.
Secara konvensi, hal ini diatur dengan mengawali setiap path dengan prefiks
yang unik yang dimiliki oleh Anda.
Misalnya, path yang digunakan secara internal oleh Google semuanya dimulai
dengan 'google', dan path yang menyatakan repositori remote dimulai dengan
path ke kode, seperti 'github.com/user/repo'.

Paket-paket dalam sebuah program tidak harus memiliki nama yang unik, tetapi
ada dua nama paket yang memiliki nama yang spesial.
Paket bernama "main" mengindikasikan sebuah program, bukan sebuah pustaka.
Program bisa dieksekusi dan tidak bisa diimpor.
Paket bernama "documentation" mengindikasikan dokumentasi untuk program selain
Go di dalam direktori.
Berkas-berkas di dalam paket dokumentasi diindahkan oleh perintah go.

Sebagai kasus khusus, jika parameter `[packages]` adalah daftar berkas-berkas
.go dari sebuah direktori yang sama, maka perintah tersebut akan digabungkan
menjadi sebuah paket yang berisi berkas-berkas tersebut, mengindahkan batasan
pembangunan dalam berkas tersebut dan mengindahkan berkas-berkas lain dalam
direktori paket tersebut.

Nama berkas dan direktori yang dimulai dengan "." atau "_" diindahkan oleh
perkakas go, sebagaimana juga direktori bernama "testdata".


[#hdr-Configuration_for_downloading_non_public_code]
== Konfigurasi untuk mengunduh kode yang bukan publik

Perintah go secara bawaan mengunduh Go modul yang publik lewat proksi di
proxy.golang.org.
Ia secara bawaan juga melakukan validasi _checksum_ terhadap modul yang
diunduh, dengan basis data publik yang ada di sum.golang.org.
Konfigurasi bawaan ini bekerja untuk semua sumber kode yang publik.

Variabel lingkungan GOPRIVATE mengontrol modul mana saja yang dianggap oleh
perintah go sebagai privat (tidak tersedia secara umum) yang meniadakan
penggunaan proksi dan validasi basis data _checksum_.
Variabel tersebut berisi daftar prefiks dari modul, dipisahkan oleh koma
(sesuai dengan sintaksis fungsi `patch.Match`).
Misalnya,

    GOPRIVATE=*.corp.example.com,rsc.io/private

menyebabkan perintah go menganggap semua modul yang sesuai dengan prefiks
tersebut sebagai privat, termasuk git.corp.example.com/xyzzy, rsc.io/private,
dan rsc.io/private/guux.

Untuk kontrol lebih lanjut terhadap pengunduhan dan validasi modul, variabel
lingkungan GONOPROXY dan GONOSUMDB menerima daftar pola yang sama dan menimpa
GOPRIVATE untuk menentukan apakah menggunakan proksi dan basis data
_checksum_.

Misalnya, jika sebuah perusahaan memiliki modul proksi sendiri untuk
modul-modul pribadi, pengguna akan set go menggunakan:

----
GOPRIVATE=*.corp.example.com
GOPROXY=proxy.example.com
GONOPROXY=none
----

Variabel GOPRIVATE juga menentukan pola "publik" dan "private" untuk variabel
GOVCS; lihat 'go help vcs'.
Untuk penggunaan tersebut, GOPRIVATE berlaku bahkan untuk mode GOPATH.
Pada kasus ini, ia mencocokan path impor bukan path modul.

Perintah 'go env -w' (lihat 'go help env') dapat digunakan untuk menset
variabel-variabel lingkungan tersebut untuk diaplikasikan pada perintah go
selanjutnya.

Untuk lebih rinci, lihat https://golang.org/ref/mod#private-modules.

[#hdr-Testing_flags]
== Opsi-opsi pengujian

Perintah 'go test' menerima opsi-opsi yang berlaku untuk 'go test' itu sendiri
dan juga untuk hasil program pengujian.

Beberapa opsi-opsi tersebut mengontrol _profiling_ dan menulis hasil eksekusi
_profile_ yang sesuai untuk "go tool pprof";
jalankan 'go tool pprof -h' untuk informasi lebih lanjut.
Opsi --alloc_space, --alloc_objects, dan --show_types dari `pprof` mengontrol
bagaimana informasi tersebut ditulis.

Opsi-opsi berikut dikenali oleh perintah 'go test' dan mengontrol eksekusi
dari pengujian:

`-bench regexp`::
    Hanya jalankan benchmark yang sesuai dengan _regular expression_.
    Secara bawaan, tidak ada benchmark yang akan dijalankan oleh program
    pengujian.
    Untuk menjalankan semua benchmark, gunakan '-bench .' atau '-bench=.'.
    Dua atau lebih _regular expression_ dipisahkan oleh karakter '/', dan
    setiap bagian dari pengidentifikasi benchmark harus cocok dengan elemen
    secara berurutan, jika ada.
    Induk dari sub-benchmark dijalankan dengan b.N=1.
    Misalnya, diberikan -bench=X/Y, benchmark induk yang sesuai dengan X
    dijalankan dengan b.N=1 untuk mencari sub-benchmark yang cocok dengan Y,
    yang kemudian dijalankan secara penuh.

`-benchtime t`::
    Jalankan iterasi dari benchmark sampai t, dispesifikasikan sebagai
    time.Duration (misalnya, `-benchtime 1h30s`).
    Nilai bawaannya yaitu 1 detik (1s).
    Sintaksis khusus `Nx` berarti menjalakan benchmark N kali (misalnya,
    `-benchtime 100x`).

`-count n`::
    Jalankan setiap tes dan benchmark `n` kali (nilai bawaan 1).
    Jika -cpu di set, jalankan `n` kali untuk setiap nilai GOMAXPROCS.
    Fungsi ExampleXxx selalu berjalan hanya sekali.

`-cover`::
    Nyalakan liputan analisis kode.
    Ingatlah bahwa secara liputan analisis bekerja dengan menandai sumber kode
    sebelum kompilasi, kegagalan kompilasi dan pengujian saat menyalakan
    liputan analisis bisa saja melaporkan nomor baris yang tidak
    sesuai dengan nomor baris pada sumber kode aslinya.

`-covermode set,count,atomic`::
    Set mode analisis untuk paket yang dites.
    Nilai bawaannya adalah "set" kecuali bila -race dinyalakan, maka nilai
    bawaannya adalah "atomic".
    Nilainya:
    * `set`: bool: apakah baris ini dijalankan?
    * `count`: int: berapa kali baris kode ini dijalankan?
    * `atomic`: int: sama dengan `count` tapi lebih tepat untuk tes
      pada multi _thread_; secara signifikan memakan lebih banyak biaya.

`-coverpkg pattern1,pattern2,pattern3`::
    Terapkan analisis kode terhadap paket yang sesuai dengan pola paket.
    Nilai bawaannya yaitu untuk setiap tes menganalisis hanya paket yang
    dites.
    Lihat 'go help packages' untuk deskripsi dari pola paket.

`-cpu 1,2,4`::
    Menentukan nilai GOMAXPROCS untuk setiap tes atau benchmark yang
    dieksekusi.
    Nilai bawaannya yaitu nilai dari GOMAXPROCS.

`-failfast`::
    Jangan jalankan tes yang baru setelah tes yang pertama gagal.

`-list regexp`::
    Tampilkan daftar tes, _benchmark_, atau contoh yang sesuai dengan
    _regular expression_.
    Tidak ada tes, _benchmark_, atau contoh yang akan dijalankan.
    Opsi ini hanya menampilkan tes induk.
    Tidak ada sub-tes atau sub-_benchmark_ yang ditampilkan.

`-parallel n`::
    Membolehkan eksekusi paralel dari fungsi tes yang memanggil `T.Parallel`.
    Nilai dari opsi ini adalah jumlah maksimum dari tes yang berjalan secara
    simultan;
    secara bawaan, nilainya sama dengan GOMAXPROCS.
    Opsi ini hanya berlaku untuk satu program tes saja.
    Perintah 'go test' bisa saja menjalankan tes untuk paket-paket yang
    berbeda secara parallel, berdasarkan pengaturan dari opsi -p (lihat 'go
    help build').

`-run regexp`::
    Jalankan hanya tes dan contoh yang sesuai dengan _regular expression_.
    Untuk tes, _regular expression_ dipisahkan oleh karakter '/' menjadi
    seurutan _regular expression_, dan setiap bagian dari identifikasi tes
    harus sesuai dengan elemen dalam urutan tersebut, jika ada.
    Ingatlah bahwa induk tes yang cocok juga dijalankan, sehingga -run=X/Y
    menjalankan dan melaporkan hasil dari semua tes yang sesuai dengan X,
    walaupun tidak ada sub-tes yang sesuai dengan Y, karena tes harus
    menjalankan X untuk mencari sub-tes Y.

`-short`::
    Untuk memberitahu tes yang berjalan lama supaya mempersingkat waktunya.
    Secara bawaan opsi ini tidak aktif.

`-shuffle off,on,N`::
    Acak urutan eksekusi dari tes dan _benchmark_.
    Opsi ini "off" secara bawaan.
    Jika -shuffle dinyalakan, maka nilai pengacak akan diinisiasi (_seed_)
    dengan waktu sistem.
    Jika -shuffle diset dengan integer N, maka N akan digunakan sebagai nilai
    inisiasi pengacak.
    Pada kedua kasus tersebut, nilai inisiasi akan ditampilkan untuk
    bisa direproduksi.

`-timeout d`::
    Jika sebuah program tes berjalan lebih lama dari d, maka panic.
    Jika d adalah 0, maka timeout tidak diaktifkan.
    Nilai bawaannya adalah 10 menit (10m).

`-v`::
    Laporkan semua tes saat berjalan.
    Laporkan juga semua teks dari pemanggilan Log dan Logf bahkan jika tes
    sukses.

`-vet list`::
    Konfigurasi pemanggilan dari 'go vet' menggunakan daftar pemeriksaan vet,
    yang dipisahkan dengan koma.
    Jika daftar ini kosong, maka tes akan menjalankan 'go vet' dengan daftar
    bawaan yang telah disiapkan.
    Jika daftar bernilai "off", maka 'go test' tidak akan menjalankan 'go
    vet'.

Opsi-opsi berikut juga dikenali oleh 'go test' dan dapat digunakan untuk
mem-_profile_ tes saat eksekusi:

`-benchmem`::
    Laporkan statistik alokasi memori pada saat _benchmark_.

`-blockprofile block.out`::
    Laporkan _profile_ goroutine yang menyebabkan pemblokiran ke berkas
    bernama "block.out" saat semua tes selesai.

`-blockprofilerate n`::
    Atur detail yang dikeluarkan oleh -blockprofile dengan memanggil
    `runtime.SetBlockProfileRate` dengan n.
    Lihat 'go doc runtime.SetBlockProfileRate'.
    Si _profiler_ mencoba mengambil sampel, secara rata-rata, satu even
    pemblokiran setiap n nano-detik.
    Secara bawaan, jika -blockprofile diset tanpa opsi ini, semua even
    pemblokiran akan dicatat, sama dengan `-blockprofilerate=1`.

`-coverprofile cover.out`::
    Tulis laporan _profile_ ke berkas "cover.out" setelah semua tes sukses.
    Opsi ini otomatis menyalakan opsi -cover.

`-cpuprofile cpu.out`::
    Tulis _profile_ CPU ke berkas "cpu.out" sebelum program tes berakhir.

`-memprofile mem.out`::
    Tulis _profile_ alokasi ke berkas bernama "mem.out" setelah semua tes
    sukses.

`-memprofilerate n`::
    Hidupkan _profile_ alokasi memori yang lebih tepat (dan lebih memakan
    biaya) dengan menset `runtime.MemProfileRate`.
    Lihat 'go doc runtime.MemProfileRate'.
    Untuk melaporkan semua alokasi memori, gunakan `-memprofilerate=1`.

`-mutexprofile mutex.out`::
    Tulis _profile_ sengketa _mutex_ ke berkas yang bernama "mutex.out" saat
    semua tes telah selesai.

`-mutexprofilefraction n`::
    Ambil satu sampel dalam n _stack traces_ dari goroutine yang memegang
    _mutex_.

`-outputdir direktori`::
    Simpan berkas keluaran dari _profile_ dalam direktori tertentu, secara
    bawaan diset ke direktori tempat 'go test' dijalankan.

`-trace trace.out`::
    Tulis pelacakan eksekusi ke berkas bernama "trace.out" sebelum tes
    berakhir.

Setiap opsi-opsi tersebut juga dikenali lewat prefiks opsional 'test.',
seperti `-test.v`.
Saat mengeksekusi program tes (hasil dari 'go test -c') secara langsung,
prefiks ini menjadi wajib.

Perintah 'go test' akan menulis atau menghapus opsi-opsi yang dikenali, bila
diperlukan, sebelum dan sesudah parameter opsional untuk daftar paket, sebelum
menjalankan program tes.

Misalnya, perintah

    go test -v -myflag testdata -cpuprofile=prof.out -x

akan mengompilasi program tes dan menjalankannya sebagai

    pkg.test -test.v -myflag testdata -test.cpuprofile=prof.out

(Opsi `-x` dihapus karena hanya berlaku untuk eksekusi perintah go, bukan
untuk program tes itu sendiri.)

Opsi tes yang membangkitkan _profile_ (selain liputan analisis) juga menyimpan
program tes dalam pkg.test untuk digunakan saat menganalisis _profile_.

Saat 'go test' menjalankan sebuah program tes, ia akan dijalankan di dalam
direktori sumber kode paket.
Bergantung kepada tes yang dijalankan, bisa jadi ia akan melakukan hal yang
sama saat mengeksekusi program tes secara langsung.

Daftar paket pada baris perintah, jika ada, harus muncul sebelum opsi-opsi
yang tidak dikenali oleh perintah 'go test'.
Melanjutkan contoh sebelumnya, daftar paket seharusnya muncul sebelum
`-myflag`, namun bisa diberikan antara `-v`.

Saat 'go test' berjalan dengan mode daftar paket, 'go test' menyimpan tembolok
dari hasil tes paket yang sukses untuk mengurangi menjalankan tes yang tidak
diperlukan.
Untuk mematikan tembolok, gunakan opsi tes atau argumen selain dari opsi yang
bisa mempengaruhi tembolok.
Cara paling umum untuk mematikan tembolok tes secara eksplisit yaitu
menggunakan `-count=1`.

Untuk menghindari supaya argumen dari program tes dianggap sebagai nama paket
atau opsi, gunakan `-args` (lihat 'go help test') yang akan mengirim sisa dari
baris perintah ke program tes tanpa diubah.

Misalnya, perintah

    go test -v -args -x -v

akan mengompilasi program tes dan menjalankannya sebagai

    pkg.test -test.v -x -v

Hal yang sama,

    go test -args math

akan mengompilasi program tes dan menjalankannya sebagai

    pkg.test math

Pada contoh yang pertama, argumen `-x` dan `-v` dikirim ke program tes tanpa
diubah dan tanpa memengaruhi program go itu sendiri.
Pada contoh kedua, argumen `math` dikirim ke program tes, bukan dianggap
sebagai bagian dari daftar paket.


[#hdr-Testing_flags]
== Fungsi-fungsi pengujian

Perintah 'go test' mencari fungsi tes, _benchmark_, dan contoh dalam
berkas-berkas '*_test.go' pada paket-paket yang akan dites.

Sebuah fungsi tes yaitu fungsi yang memiliki prefiks `Test`, misalnya
`TestXxx` (yang mana `Xxx` harus diawali dengan huruf kapital) dan harus
memiliki penanda berikut,

    func TestXxx(t *testing.T) { ... }

Sebuah fungsi _benchmark_ yaitu yang bernama `BenchmarkXxx` dan harus memiliki
penanda berikut,

    func BenchmarkXxx(b *testing.B) { ... }

Sebuah fungsi ExampleXxx mirip dengan fungsi TestXxx tetapi tidak menggunakan
`*testing.T` untuk melaporkan sukses atau gagal, melainkan mencetak keluaran
ke `os.Stdout`.
Jika komentar terakhir pada function ExampleXxx dimulai dengan "Output:" maka
keluaran dari fungsi tersebut dibandingkan dengan komentar (lihat contoh di
bawah).
Jika komentar terakhir dimulai dengan "Unordered output:" maka keluaran dari
fungsi Example tersebut dibandingkan dengan isi dari komentar, namun dengan
urutan dari baris komentar bisa tidak berurut.
Sebuah fungsi Example tanpa ada dua komentar tersebut hanya dikompilasi tapi
tidak dijalankan.
Sebuah fungsi Example tanpa ada teks setelah "Output:" dikompilasi,
dieksekusi, dan ekspektasi-nya adalah tidak ada keluaran.

Godoc menampilkan badan dari ExampleXxx untuk mendemonstrasikan penggunaan
dari fungsi, konstanta, atau variabel `Xxx`.
Contohnya, sebuah method `M` dengan penerima bertipe `T` atau `*T` nama fungsi
Example-nya adalah `ExampleT_M`.
Bisa saja ada banyak contoh untuk fungsi, konstanta, atau variabel tersebut,
dibedakan dari akhiran `_xxx`, yang mana `xxx` adalah sebuah sufiks yang tidak
dimulai dengan huruf kapital.

Berikut sebuah contoh dari fungsi Example:

----
func ExamplePrintln() {
	Println("Keluaran dari\ncontoh ini.")
	// Output: Keluaran dari
	// contoh ini.
}
----

Berikut contoh lain yang mana urutan dari keluaran diindahkan:

----
func ExamplePerm() {
	for _, value := range Perm(4) {
		fmt.Println(value)
	}

	// Unordered output: 4
	// 2
	// 1
	// 3
	// 0
}
----

Keseluruhan berkas tes dipresentasikan sebagai contoh bila ia hanya berisi
sebuah fungsi Example saja, paling tidak deklarasi fungsi, tipe, variabel,
atau konstanta, dan tidak ada fungsi Benchmark atau Test lainnya.

Lihat dokumentasi dari paket `testing` untuk informasi lebih lanjut.


[#hdr-Controlling_version_control_with_GOVCS]
== Mengatur perkakas _version control_ lewat GOVCS

Perintah 'go get' dapat menjalankan perintah-perintah _version control_,
seperti `git`, untuk mengunduh kode yang diimpor.
Fungsionalitas ini sangat penting untuk ekosistem desentralisasi paket Go,
yang mana kode dapat diimpor dari peladen mana pun, namun hal ini juga
bisa menimbulkan masalah keamanan, jika peladen yang berniat jahat menemukan
cara untuk menjalankan kode yang tidak diinginkan.

Untuk menyeimbangkan fungsionalitas dan keamanan, perintah 'go get' secara
bawaan hanya akan menggunakan `git` dan `gh` untuk mengunduh kode dari peladen
publik.
Namun ia akan menggunakan sistem _version control_ yang dikenal (bzr,
fossil, git, hg, svn) untuk mengunduh kode dari peladen privat, selama
paket-paket yang disimpan sesuai dengan variabel GOPRIVATE (lihat
'go help private').
Rasionalitas dari hanya membolehkan Git dan Mercurial adalah kedua sistem ini
memiliki perhatian yang khusus terhadap isu-isu bila dijalankan sebagai klien
pada peladen yang tidak dipercaya.
Sebaliknya, Bazaar, Fossil, dan Subversion umumnya hanya digunakan pada
lingkungan yang dipercaya dengan autentikasi dan rentan terhadap serangan.

Batasan perintah _version control_ hanya berlaku saat menggunakan akses
langsung untuk mengunduh kode.
Saat mengunduh modul dari sebuah proksi, 'go get' akan menggunakan protokol
proksi, yang mana selalu dibolehkan.
Secara bawaan, perintah 'go get' menggunakan salinan modul Go pada proksi
(proxy.golang.org) untuk paket-paket publik dan hanya menggunakan _version
control_ untuk paket-paket private atau saat proksi publik menolak melayani
publik paket (biasanya karena alasan legalitas).
Oleh karena itu, klien masih dapat mengakses kode publik yang disimpan lewat
repositori Bazaar, Fossil, atau Subversion, secara pengunduhan dilakukan oleh
Go modul proksi, yang menangani resiko keamanan dengan menjalankan perintah
_version control_ menggunakan _sandbox_ tersendiri.

Variabel GOVCS dapat digunakan untuk mengubah sistem _version control_ apa
saja yang dibolehkan untuk paket-paket tertentu (diidentifikasi lewat path
impor atau modul).
Variabel GOVCS diterapkan saat membangun paket dengan mode modul dan GOPATH.
Saat menggunakan mode modul, pola dengan path modul.
Saat menggunakan mode GOPATH, pola disamakan dengan path impor yang
berkorespondensi dengan induk dari repositori.

Format umum dari nilai pengaturan GOVCS yaitu sebuah aturan yang dipisahkan
dengan koma, format aturan ini yaitu "pola:daftar_vcs".
Format dari "pola" yaitu menggunakan _glob_ yang harus sesuai dengan satu atau
lebih elemen dari path impor atau modul.
Format dari "daftar_vcs" yaitu daftar _version control_ yang dibolehkan yang
dipisahkan dengan '|', atau "all" untuk membolehkan perintah apa pun, atau
"off" untuk menolak perintah apa pun.
Ingatlah bahwa jika sebuah modul cocok dengan pola pada "daftar_vcs" yang di
set ke "off", ia bisa saja tetap diunduh jika peladen menggunakan skema "mod",
yang menyuruh perintah go untuk mengunduh modul tersebut menggunakan
protokol GOPROXY.
Pola pertama yang cocok akan digunakan, walaupun pola selanjutnya ada yang
cocok juga.

Misalnya,

    GOVCS=github.com:git,evil.com:off,*:git|hg

Dengan pengaturan ini, kode dengan modul atau path impor yang diawali dengan
github.com/ hanya dapat menggunakan git;
path dengan evil.com tidak dapat menggunakan perintah _version control_ apa
pun, dan semua path lainnya (`*` berarti cocok dengan lainnya) hanya dapat
menggunakan git atau hg.

Pola khusus "public" dan "private" cocok dengan modul atau path impor publik
dan privat.
Sebuah path dikatakan "private" jika ia cocok dengan isi dari variabel
GOPRIVATE; selain itu maka akan dianggap publik.

Jika tidak ada aturan dalam variabel GOVCS yang cocok dengan sebuah modul atau
path impor tertentu, perintah 'go get' akan menerapkan aturan bawaan, yaitu
'public:git|gh,private:all'.

Untuk membolehkan penggunaan sistem _version control_ mana pun untuk semua
paket, gunakan:

    GOVCS=*:all

Untuk mematikan penggunakan _version control_, gunakan:

    GOVCS=*:off

Perintah 'go env -w' (lihat 'go help env') dapat digunakan untuk menset
variabel GOVCS untuk pemanggilan perintah go selanjutnya.
