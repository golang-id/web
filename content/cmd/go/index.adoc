=  Perintah go
:toc:

Go adalah sebuah perkakas untuk mengatur sumber kode Go.

Penggunaan:

----
go <perintah> [argumen]
----

Perintah-perintahnya adalah:

----
bug         jalankan pelaporan bug
build       kompilasi paket-paket dan dependensi
clean       hapus berkas-berkas objek dan cache
doc         tampilkan dokumentasi dari paket atau simbol
env         cetak informasi lingkungan dari Go
fix         ubah paket untuk menggunakan API yang baru
fmt         gofmt (format ulang) sumber-sumber paket
generate    buat berkas Go dengan memproses sumber
get         tambah dan pasang dependensi ke modul yang sekarang
install     kompilasi dan pasang paket dan dependensi
list        cetak daftar paket atau modul
mod         pemeliharaan modul
run         kompilasi dan jalankan program Go
test        tes paket-paket
tool        jalankan perkakas go tertentu
version     cetak versi Go
vet         laporkan kemungkinan kesalahan dalam paket-paket
----

Gunakan "go help <perintah>" untuk informasi tentang perintah.

Beberapa topik bantuan tambahan:

----
buildmode      mode pembangunan
c              pemanggilan antara Go dan C
cache          cache pada pembangunan dan tes
environment    variabel-variabel lingkungan
filetype       tipe-tipe berkas
go.mod         berkas go.mod
gopath         variabel lingkungan GOPATH
gopath-get     legasi GOPATH menggunakan go get
goproxy        protokol proxy pada modul
importpath     sintaksis untuk path impor
modules        modul, versi modul, dan banyak lagi
module-get     go get dengan menggunakan modul
module-auth    autentikasi modul menggunakan go.sum
module-private konfigurasi modul untuk modul yang tidak publik
packages       daftar dan pola paket
testflag       opsi-opsi untuk tes
testfunc       fungsi-fungsi untuk tes
----

Gunakan "go help <topik>" untuk informasi lanjut tentang topik tersebut.

[#hdr-Start_a_bug_report]
==  Jalankan pelaporan bug

Penggunaan:

----
go bug
----

Perintah `bug` membuka peramban dan menjalankan laporan _bug_ yang baru.
Laporan tersebut mengikutkan informasi sistem.


[#hdr-Compile_packages_and_dependencies]
==  Kompilasi paket-paket dan dependensi

Penggunaan:

----
go build [-o output] [-i] [flag build] [paket]
----

Perintah `build` mengompilasi paket-paket berdasarkan nama dari path import,
bersama dengan dependensinya, namun tidak memasang hasilnya.

Jika argumennya adalah daftar berkas .go dari sebuah direktori, maka `build`
menganggapnya sebagai daftar berkas sumber dari paket yang sama.

Saat mengompilasi paket, `build` mengindahkan berkas yang berakhiran
`_test.go`.

Saat mengompilasi paket main, `build` menulis hasil program ke sebuah berkas
yang namanya diambil dari berkas sumber pertama (`go build ed.go rx.go`
menulis `ed` atau `ed.exe`) atau direktori sumber kode
(`go build unix/sam` menulis `sam` atau `sam.exe`).
Akhiran '.exe' ditambahkan bila menulis program untuk Windows.

Saat mengompilasi beberapa paket atau paket yang bukan `main`, `build`
mengompilasi paket-paket tersebut namun mengindahkan objek hasilnya,
cara ini untuk memeriksa bahwa paket dapat dibangun.

Opsi "-o" memaksa `build` untuk menulis hasil program atau objek dengan nama
atau direktori yang diberikan, bukan dengan perilaku seperti yang dijelaskan
pada dua paragraf sebelumnya.
Jika nama keluaran adalah direktori yang sudah ada, maka hasil program akan
ditulis di dalam direktori tersebut.

Opsi "-i" memasang paket-paket dependensi dari target.

Opsi-opsi dari `build` berikut dapat digunakan pada perintah `clean`, `get`,
`install`, `list`, `run`, dan `test`:

----
-a
	buat ulang semua paket bahkan yang sudah terbarukan.
-n
	cetak perintah-perintah tetapi jangan jalankan.
-p n
	jumlah program, seperti perintah build atau tes, yang dapat berjalan
	secara paralel.
	Nilai baku dari n yaitu jumlah CPU yang tersedia.
-race
	izinkan deteksi data race.
	Hanya didukung pada linux/amd64, freebsd/amd64, darwin/amd64,
	windows/amd64, linux/ppc64le, dan linux/arm64 (hanya untuk 48-bit
	VMA).
-msan
	izinkan operasi dengan pembersih memory.
	Hanya didukung pada linux/amd64, linux/arm64 dan hanya lewat
	Clang/LLVM sebagai compiler C.
	Pada linux/arm64, mode build "pie" akan digunakan.
-v
	cetak nama-nama paket saat mereka dikompilasi.
-work
	cetak nama dari direktori sementara dan jangan hapus saat selesai.
-x
	cetak perintah-perintah.

-asmflags '[pattern=]arg list'
	argumen yang dikirim ke setiap pemanggilan `go tool asm`.
-buildmode mode
	mode pembangunan yang akan digunakan.  lihat 'go help buildmode' untuk
	lebih lanjut.
-compiler name
	nama compiler yang akan digunakan, seperti dalam runtime.Compiler
	(gccgo atau gc).
-gccgoflags '[pattern=]arg list'
	argumen yang akan dikirim setiap pemanggilan compiler/linker gccgo.
-gcflags '[pattern=]arg list'
	argumen yang akan dikirim setiap pemanggilan "go tool compile"
-installsuffix suffix
	Sufiks yang digunakan sebagai nama direktori pemasangan paket, dengan
	tujuan untuk menjaga keluaran terpisah dengan pembangunan biasa.
	Jika menggunakan opsi -race, maka akhiran pada pemasangan secara
	otomatis di set ke race atau, jika di set secara eksplisit, akan
	ditambahkan _race.
	Hal yang sama juga berlaku pada opsi -msan.
	Menggunakan opsi -buildmode yang membutuhkan opsi-opsi yang tidak
	biasa akan mendapatkan efek yang sama.
-ldflags '[pattern=]arg list'
	argumen yang akan dikirim ke setiap pemanggilan "go tool link"
-linkshared
	link dengan pustaka yang dibuat sebelumnya dengan -buildmode=shared.
-mod mode
	mode pengunduhan modul yang digunakan: readonly atau vendor.
	Lihat 'go help modules' untuk lebih lanjut.
-modcacherw
	direktori yang baru dibuat dalam modul _cache_ akan di set read-write
	bukan read-only
.-pkgdir dir
	pasang dan muat semua paket dari "dir" sebagai ganti dari lokasi
	biasa.
	Contohnya, saat membangun dengan konfigurasi non-standar, gunakan
	-pkgdir untuk menghasilkan paket di lokasi yang berbeda.
-tags tag,list
	daftar tag dari build yang terpisah dengan koma yang akan dipenuhi
	selama pembangunan.
	Untuk informasi lebih lanjut tentang build tag, lihat deskripsi dari
	batasan-batasan build dalam dokumentasi untuk paket go/build.
	(Versi dahulu dari Go menggunakan daftar yang terpisah dengan spasi,
	dan bentuk tersebut sudah tidak digunakan lagi namun masih tetap
	dikenali.
-trimpath
	hapus semua path-path sistem dari hasil program.
	Nama berkas yang tercatat akan dimulai dengan "go" (untuk pustaka
	standar), atau module path@version (bila menggunakan modul), atau path
	import biasa (bila menggunakan GOPATH).
-toolexec 'cmd args'
	program yang digunakan untuk memanggil program toolchain seperti vet
	dan asm.
	Misalnya, alih-alih menjalankan asm, perintah go akan menjalankan
	'cmd args /path/to/asm <argumen untuk asm>'.
----

Opsi -asmflags, -gccgoflags, -gcflags, dan -ldflags menerima daftar argumen
yang dipisahkan oleh spasi untuk dikirim ke perkakas yang dijalankan
dibelakangnya selama pembangunan.
Untuk menambah spasi dalam elemen dalam daftar tersebut, kurung dengan tanda
kutip tunggal atau ganda.
Daftar argumen bisa diawali dengan sebuah pola paket dan tanda sama dengan
("="), yang membatasi penggunaan dari daftar argumen tersebut ke pembangunan
paket-paket yang cocok dengan pola (lihat 'go help packages' untuk deskripsi
dari pola paket).
Tanpa pola, daftar argumen hanya berlaku untuk paket yang diberikan pada
perintah baris.
Opsi-opsi tersebut bisa berulang dengan pola yang berbeda dengan tujuan untuk
menentukan argumen yang berbeda untuk sekumpulan paket.
Jika sebuah pola pencocokan paket diberikan dalam beberapa opsi, kecocokan
yang terakhir akan digunakan.
Sebagai contohnya, 'go build -gcflags=-S fmt' mencetak _disassembly_ hanya
untuk paket fmt, sementara 'go build -gcflags=all=-S fmt' mencetak
_disassembly_ untuk fmt dan semua dependensinya.

Untuk lebih tahu tentang cara menspesifikasikan paket, lihat 'go help
packages'.
Untuk mengetahui lebih lanjut tentang di mana paket dan program dipasang,
jalankan 'go help gopath'.
Untuk mengetahui lebih lanjut tentang pemanggilan antara Go dan C/C++,
jalankan 'go help c'.

Catatan: Perintah `build` mengikuti beberapa konvensi seperti yang dijelaskan
oleh 'go help gopath'.
Tidak semua proyek dapat mengikuti konvensi tersebut.
Pemasangan yang memiliki konvensinya sendiri atau yang menggunakan sistem
pembangunan perangkat lunak yang terpisah bisa memilih untuk menggunakan
pemanggilan tingkat-rendah seperti 'go tool compile' dan 'go tool link' untuk
menghindari beberapa beban dan rancangan dari perkakas build.

Lihat juga: go install, go get, go clean.


[#hdr-Remove_object_files_and_cached_files]
==  Hapus berkas-berkas objek dan _cache_

Penggunaan:

----
go clean [clean flags] [build flags] [packages]
----

Perintah `clean` menghapus berkas objek dari direktori sumber paket.
Perintah go menulis objek dalam sebuah direktori sementara, sehingga
'go clean' biasanya berguna untuk berkas objek sisa dari perkakas lain atau
dari pemanggilan manual dari go build.

Jika argumen sebuah paket diberikan atau opsi -i atau -r di set, `clean`
menghapus berkas-berkas berikut dari setiap direktori sumber yang
berkorespondensi dengan path impor:

----
_obj/            direktori objek yang lama, sisa dari Makefiles
_test/           direktori tes yang lama, sisa dari Makefiles
_testmain.go     berkas gotest lama, sisa dari Makefiles
test.out         log tes lama, sisa dari Makefiles
build.out        log tes lama, sisa dari Makefiles
*.[568ao]        berkas object, sisa dari Makefiles

DIR(.exe)        dari go build
DIR.test(.exe)   dari go test -c
MAINFILE(.exe)   dari go build MAINFILE.go
*.so             dari SWIG
----

Dalam daftar tersebut, DIR merepresentasikan elemen path terakhir dari
direktori, dan MAINFILE adalah nama dasar dari sumber kode Go dalam direktori
tersebut yang tidak diikutkan saat membangun paket.

Opsi -i membuat perintah `clean` untuk menghapus arsip dan binary yang
terpasang (yang dibuat oleh 'go install').

Opsi -n membuat perintah `clean` untuk mencetak perintah penghapusan yang
akan dieksekusi, namun tidak menjalankannya.

Opsi -r membuat perintah `clean` menerapkan secara rekursif ke semua
dependensi dari paket dari path impor.

Opsi -x membuat perintah `clean` mencetak perintah penghapus saat ia
dieksekusi.

Opsi -cache membuat `clean` menghapus semua _cache_ dari go build.

Opsi -testcache menyuruh supaya `clean` untuk kedaluwarsa semua hasil tes
dalam _cache_ go build.

Opsi -modcache menyebabkan `clean` menghapus semua _cache_ unduhan modul
termasuk sumber kode dari dependensi yang memiliki versi.

Untuk lebih lanjut tentang opsi build, lihat 'go help build'.

Untuk lebih lanjut tentang menentukan paket, lihat 'go help packages'.


[#hdr-Show_documentation_for_package_or_symbol]
==  Tampilkan dokumentasi dari paket atau simbol

Penggunaan:

----
go doc [-u] [-c] [package|[package.]symbol[.methodOrField]]
----

Perintah `doc` mencetak komentar dokumentasi yang berasosiasi dengan item yang
diidentifikasi lewat argumen-argumen (sebuah paket, const, func, type, var,
method, atau field dari struct) diikuti dengan sebuah ringkasan satu-baris
dari setiap item tingkat-pertama "di bawah" item tersebut (deklarasi
tingkat-paket untuk sebuah paket, method untuk sebuah tipe, dan seterusnya.).

Perintah `doc` menerima argumen kosong, satu, atau dua.

Bila argumen tidak ada, yaitu, bila dijalankan seperti

----
go doc
----

ia akan mencetak dokumentasi paket dalam direktori yang sekarang.
Jika paket adalah sebuah program (package main), simbol-simbol yang diekspor
oleh paket tidak ditampilkan kecuali bila opsi -cmd diberikan.

Bila dijalankan dengan satu argumen, maka argumen tersebut dianggap sebagai
representasi mirip sintaksis Go dari item yang didokumentasikan.
Apa yang argumen pilih bergantung pada apa yang dipasang dalam GOROOT dan
GOPATH, sebagaimana juga bentuk dari argumen, yang secara semantik adalah satu
dari hal berikut:

----
go doc <pkg>
go doc <sym>[.<methodOrField>]
go doc [<pkg>.]<sym>[.<methodOrField>]
go doc [<pkg>.][<sym>.]<methodOrField>
----

Item pertama dalam daftar di atas yang sesuai dengan argumen akan dicetak
dokumentasinya.
(Lihat contoh di bawah).
Namun jika argumen dimulai dengan huruf besar maka diasumsikan sebagai simbol
atau method dari direktori yang sekarang.

Untuk paket, urutan pencarian ditentukan secara leksikal dengan cara
_breadth-first order_.
Yaitu, paket yang ditampilkan adalah yang cocok dengan pencarian dan terdekat
dengan root dan yang pertama secara leksikal di tingkat hirarkinya.
Pohon GOROOT selalu dicari pertama kali sebelum GOPATH.

Jika tidak ada paket yang diberikan atau cocok, maka paket di direktori
sekarang yang dipilih, sehingga "go doc Foo" memperlihatkan dokumentasi untuk
simbol Foo dalam paket yang sekarang.

Path dari paket bisa secara penuh atau cukup sufiks dari path saja.
Mekanisme umum dari go tool tidak berlaku: elemen path paket seperti . dan ...
tidak diimplementasikan oleh `go doc`.

Bila dijalankan dengan dua argumen, yang pertama haruslah path penuh dari
paket (tidak hanya sufiks saja), dan yang kedua adalah simbol, atau simbol
dengan method atau field struct.
Hal ini sama dengan sintaksis yang diterima oleh godoc:

----
go doc <pkg> <sym>[.<methodOrField>]
----

Dalam semua bentuk, saat mencocokan simbol, huruf kecil dalam argumen
menyesuaikan dengan huruf kecil atau besar namun huruf besar dicocokan persis.
Hal ini berarti akan ada beberapa kecocokan dari argumen dengan huruf kecil
dalam sebuah paket jika simbol yang berbeda memiliki huruf yang berbeda.
Jika hal ini terjadi, dokumentasi untuk semua kecocokan dicetak.

Contoh:

----
go doc
	Tampilkan dokumentasi dari paket yang sekarang.
go doc Foo
	Tampilkan dokumentasi dari Foo dalam paket sekarang.
	(Foo dimulai dengan huruf besar sehingga tidak sesuai dengan path
	paket.)
go doc encoding/json
	Tampilkan dokumentasi dari paket encoding/json.
go doc json
	Cara cepat untuk encoding/json.
go doc json.Number (or go doc json.number)
	Tampilkan dokumentasi dan ringkasan method untuk json.Number.
go doc json.Number.Int64 (or go doc json.number.int64)
	Tampilkan dokumentasi untuk method json.Number Int64.
go doc cmd/doc
	Tampilkan dokumentasi paket untuk perintah doc.
go doc -cmd cmd/doc
	Tampilkan dokumentasi dan simbol-simbol yang diekspor dalam perintah
	doc.
go doc template.new
	Tampilkan dokumentasi untuk fungsi html/template New.
	(html/template secara leksikal sebelum text/template).
go doc text/template.new # Satu argumen
	Tampilkan dokumentasi untuk fungsi text/template New.
go doc text/template new # Dua argumen
	Tampilkan dokumentasi untuk fungsi text/template New.

Paling tidak, pemanggilan berikut mencetak dokumentasi untuk method
json.Decoder Decode:

go doc json.Decoder.Decode
go doc json.decoder.decode
go doc json.decode
cd go/src/encoding/json; go doc decode
----

Opsi-opsi:

----
-all
	Tampilkan semua dokumentasi dari paket.
-c
	Perhatikan huruf besar/kecil saat mencari simbol.
-cmd
	Perlakukan sebuah perintah (paket main) seperti paket biasa.
	Sebaliknya simbol-simbol yang diekspor paket main disembunyikan saat
	menampilkan dokumentasi paket tingkat-atas.
-short
	Tampilkan satu-baris representasi untuk setiap simbol.
-src
	Tampilkan keseluruhan sumber kode dari simbol.  Cara ini
	memperlihatkan seluruh sumber Go dari deklarasi dan definisi, seperti
	sebuah definisi fungsi (termasuk badannya), deklarasi tipe atau blok
	const.  Keluarannya bisa mengikutkan rincian yang tidak diekspor.
-u
	Tampilkan dokumentasi untuk simbol, method, field yang tidak diekspor
	dan yang diekspor.
----


[#hdr-Print_Go_environment_information]
==  Cetak informasi lingkungan dari Go

Penggunaan:

----
go env [-json] [-u] [-w] [var ...]
----

Perintah `env` mencetak informasi lingkungan Go.

Secara baku env mencetak informasi sebagai skrip _shell_ (pada Windows, sebuah
berkas _batch_).
Jika satu atau lebih variabel diberikan sebagai argumen, env mencetak nilai
dari setiap variabel per baris.

Opsi -json mencetak nilai variabel dalam format JSON.

Opsi -u membutuhkan satu atau lebih argumen dan akan menghapus pengaturan baku
dari variabel lingkungan tersebut, jika sebelumnya telah diset dengan
'go env -w'.

Opsi -w membutuhkan satu atau lebih argumen dengan bentuk NAME=VALUE dan
mengubah pengaturan baku dari variabel lingkungan yang diberikan sesuai dengan
nilainya.

Untuk lebih lanjut tentang variabel lingkungan, lihat 'go help environment'.


[#hdr-Update_packages_to_use_new_APIs]
==  Ubah paket untuk menggunakan API yang baru

Penggunaan:

----
go fix [packages]
----

Perintah `fix` menjalankan perintah perbaikan Go terhadap nama paket-paket
yang diberikan lewat path impor.

Untuk lebih lanjut tentang fix, lihat 'go doc cmd/fix'.
Untuk lebih lanjut tentang argumen paket, lihat 'go help packages'.

Untuk menjalankan fix dengan opsi-opsi tertentu, jalankan 'go tool fix'.

Lihat juga: go fmt, go vet.


[#hdr-Gofmt__reformat__package_sources]
==  Gofmt (format ulang) sumber-sumber paket

Penggunaan:

----
go fmt [-n] [-x] [packages]
----

Fmt menjalankan program 'gofmt -l -w' pada paket-paket berdasarkan nama dari
path import.
Ia akan mencetak nama berkas yang diubah.

Untuk informasi lebih lanjut tentang gofmt, lihat 'go doc cmd/gofmt'.
Untuk informasi tentang menentukan paket, lihat 'go help packages'.

Opsi -n mencetak perintah yang akan dieksekusi.
Opsi -x mencetak perintah saat dieksekusi.

Opsi -mod menset mode unduhan yang akan digunakan: baca-saja atau vendor.
Lihat 'go help modules' untuk lebih lanjut.

Untuk menjalankan gofmt dengan opsi tertentu, jalankan gofmt itu sendiri.

Lihat juga: go fix, go vet.


[#hdr-Generate_Go_files_by_processing_source]
==  Buat berkas Go dengan memproses sumber

Penggunaan:

----
go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
----

Generate menjalankan perintah yang dijelaskan oleh petunjuk dalam berkas.
Perintah tersebut dapat menjalankan proses apa saja namun tujuannya yaitu
membuat atau memperbarui sumber berkas Go.

Go generate tidak pernah dijalankan secara otomatis oleh go build, go get, go
test, and seterusnya.
Ia harus dijalankan secara eksplisit.

Go generate memindai petunjuk dalam berkas, yang berupa baris dalam bentuk,

----
//go:generate perintah argumen...
----

(catatan: tidak ada spasi awal dan spasi dalam "//go") yang mana "perintah"
adalah generator yang akan dijalankan, yang berkorespondensi dengan nama
berkas program yang dapat dijalankan di lokal.
Program tersebut harus ada dalam PATH dari _shell_, path penuh
(/usr/you/bin/mytool), atau sebuah alias dari perintah, yang dijelaskan di
bawah.

Untuk memberitahu ke manusia atau mesin bahwa kode tersebut hasil generate,
sumber hasil generate seharusnya memiliki baris yang sesuai dengan _regular
expression_ (dalam sintaksis Go):

----
^// Code generated .* DO NOT EDIT\.$
----

Baris tersebut bisa muncul di mana pun dalam berkas Go, namun biasanya berada
di awal supaya mudah dicari.

Ingat bahwa go generate tidak mem-_parse_ berkas, sehingga baris-baris yang
mirip dengan _directive_ dalam komentar atau string akan dianggap sebagai
_directive_.

Argumen dari _directive_ adalah token yang dipisahkan oleh koma atau string
dengan kutip ganda yang dikirim sebagai sebuah argumen saat ia dijalankan.

String dengan tanda kutip menggunakan sintaksis Go dan dievaluasi sebelum
dieksekusi;
String dengan tanda kutip dianggap sebagai sebuah argumen oleh _generator_.

Go generate men-set beberapa variabel saat ia berjalan:

----
$GOARCH
	Arsitektur dari eksekusi (arm, amd64, dll.)
$GOOS
	Sistem operasi dari eksekusi (linux, windows, dll.)
$GOFILE
	Nama dari berkas.
$GOLINE
	Nomor baris dari directive dalam sumber kode
$GOPACKAGE
	Nama dari paket dari bekas yang berisi directive.
$DOLLAR
	Karaketer dolar.
----

Selain penggantian variabel dan evaluasi string berkutip, tidak ada lagi
pemrosesan khusus yang dilakukan, seperti "globbing", dalam baris perintah.

Sebagai langkah terakhir sebelum menjalankan perintah, pemanggilan variabel
lingkungan apa pun dengan nama alfa-numerik, seperti $GOFILE atau $HOME, akan
diganti lewat baris perintah.
Sintaksis dari penggatian variabel yaitu $NAME pada semua sistem operasi.
Dikarenakan urutan evaluasi, variabel diganti bahkan di dalam string berkutip.
Jika variabel NAME tidak diset, $NAME akan akan diganti dengan string kosong.

Sebuah _directive_ dengan bentuk,

----
//go:generate -command xxx args...
----

menspesifikasikan, untuk berkas itu saja, bahwa string xxx merepresentasikan
perintah yang diidentifikasi oleh argumennya.
Hal ini bisa digunakan untuk membuat alias atau menangani generator dengan
banyak kata.
Sebagai contohnya,

----
//go:generate -command foo go tool foo
----

menentukan bahwa perintah "foo" merepresentasikan "go tool foo".

Perintah generate memproses paket-paket dengan urutan sesuai dengan yang
diberikan pada baris perintah, satu per satu.
Jika baris perintah berisi berkas .go dari sebuah direktori, mereka akan
diperlakukan sebagai satu paket.
Dalam sebuah paket, generate memproses sumber berkas dalam paket berurutan
sesuai nama, satu per satu.
Dalam sebuah berkas, generate menjalankan generator dengan urutan kemunculan
dalam berkas, satu per satu.
Perkakas "go generate" juga men-set tag build "generate" sehingga
berkas-berkas bisa diperiksa oleh "go generate" namun diindahkan selama
pembangunan.

Jika salah satu generator berhenti karena eror, "go generate" melewati semua
pemrosesan selanjutnya untuk paket tersebut.

Si generator berjalan dalam sumber direktori paket.

Go generate menerima satu opsi khusus:

----
-run=""
	Jika tidak kosong, menspesifikasikan regular expression untuk memilih
	directive yang keseluruhan teksnya (kecuali spasi dan baris baru)
	cocok dengan ekspresi.
----

Go generate juga dapat menerima opsi "build" termasuk -v, -n, dan -x.
Opsi -v mencetak nama-nama paket dan berkas saat proses berjalan.
Opsi -n mencetak perintah yang akan dieksekusi.
Opsi -x mencetak perintah saat dieksekusi.

Untuk lebih lanjut tentang opsi "build", lihat 'go help build'.

Untuk lebih lanjut tentang cara menspesifikasikan paket, lihat 'go help
packages'.


==  Tambah dan pasang dependensi ke modul yang sekarang

Penggunaan:

----
go get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]
----

Perintah "get" menambahkan dependensi ke modul pengembangan yang sekarang dan
kemudian membangun dan memasangnya.

Langkah pertama yaitu menyelesaikan dependensi apa yang ditambahkan.

Untuk setiap paket atau pola paket, "get" harus memutuskan versi mana dari
modul yang akan digunakan.
Secara baku, "get" mencari _tag_ dari versi rilis _tag_ yang terakhir, seperti
v0.4.5 atau v1.2.3.
Jika versi rilis tidak memiliki _tag_, "get" mencari versi _tag_ pra-rilis
yang terakhir, seperti v0.0.1-pre1.
Jika tidak ada versi _tag_ sama sekali, "get" mencari _commit_ terakhir.
Jika modul belum dibutuhkan (misalnya, pra-rilis lebih baru dan rilis
terakhir), "get" akan menggunakan versi yang dicarinya.
Selain itu, "get" akan menggunakan versi yang sekarang dibutuhkan.

Pemilihan versi ini dapat ditimpa dengan menambahkan sufiks @version pada
argumen paket, seperti 'go get golang.org/x/text@v0.3.0'.
Versi tersebut bisa berupa prefiks: @v1 berarti versi terakhir yang tersedia
mulai dari v1.
Lihat 'go help modules' pada 'Module queries' untuk sintaks keseluruhan.

Untuk modul yang disimpan dalam repositori dengan _version control system_
(sistem kontrol versi, atau disingkat VCS), sufiks di versi bisa berupa _hash_
dari _commit_, nama _branch_, atau sintaks lainnya yang dikenal oleh VCS
tersebut, seperti 'go get golang.org/x/text@master'.
Ingat bahwa nama _branch_ yang sama dengan sintaks _query_ modul tidak dapat
dipilih secara eksplisit.
Contohnya, sufiks @v2 artinya versi terakhir mulai dari v2, bukan _branch_
yang bernama v2.

Jika sebuah modul yang diinginkan sudah menjadi dependensi dari modul
pengembangan sekarang, maka "get" akan memperbarui versi yang dibutuhkan.
Menspesifikasikan sebuah versi yang lebih awal dari versi yang dibutuhkan
sekarang adalah valid dan akan men-_downgrade_ dependensi.
Versi dengan sufiks @none mengindikasikan bahwa dependensi harus dihapus
sepenuhnya, di-_downgrade_ atau menghapus modul yang bergantung kepadanya.

Versi dengan sufiks @latest secara eksplisit meminta rilis minor terakhir dari
modul yang diberikan pada path argumen.
Sufiks @upgrade seperti @latest namun tidak akan men-_downgrade_ modul jika ia
sudah dibutuhkan pada versi tertentu atau versi pra-rilis lebih baru dari pada
versi rilis terbaru.
Sufiks @patch meminta rilis _patch_ terbaru: versi rilis terbaru dengan angka
mayor dan minor yang sama dengan yang dibutuhkan sekarang.
Seperti halnya dengan @upgrade, @path tidak akan men-_downgrade_ sebuah modul
yang sudah dibutuhkan pada versi terbaru.
Jika path tertentu belum diperlukan, @upgrade dan @path sama dengan @latest.

Walaupun "get" secara bawaan menggunakan versi terakhir dari modul yang beris
nama paket, ia tidak menggunakan versi terakhir dari dependensi modul.
Namun ia menggunakan versi dependensi tertentu yang diminta oleh modul
tersebut.
Misalnya, jika A butuh modul B v1.2.3, sementara B v1.2.4 dan v1.3.1 juga
tersedia, maka 'go get A' akan menggunakan versi A yang terakhir namun
menggunakan B v1.2.3, seperti yang diminta oleh A.
(Jika ada kebutuhan yang saling bersaing untuk sebuah modul tertentu, 'go
get' menyelesaikan kebutuhan mereka dengan memilih versi maksimum yang
diminta.)

Opsi -t menyuruh 'get' supaya mengunduh modul-modul yang dibutuhkan untuk
pengujian paket yang dispesifikasikan pada baris perintah.

Opsi -u menyuruh 'get' untuk memperbarui modul-modul sebagai dependensi dari
nama paket pada baris perintah supaya menggunakan rilis minor atau patch
terbaru bila ada.
Melanjutkan contoh sebelumnya, 'go get -u A' akan menggunakan versi A yang
terakhir dengan B v1.3.1 (bukan B v1.2.3).
Jika B membutuhkan modul C, namun C tidak menyediakan paket apa pun yang
dibutuhkan untuk membangun paket di A, maka C tidak akan diperbarui.

Opsi -u=patch (bukan '-u patch') juga menyuruh 'get' untuk memperbarui
dependensi, namun dengan menggunakan rilis patch saja.
Melanjutkan contoh sebelumnya, 'go get -u=patch A@latest' akan menggunakan
versi A yang terakhir dengan B v1.2.4 (bukan B v1.2.3), namun untuk
'go get -u=patch A' akan menggunakan rilis patch dari A.

Bila opsi -t dan -u digunakan bersamaan, 'get' akan memperbarui dependensi tes
juga.

Pada umumnya, menambahkan dependensi baru membutuhkan pembaruan dependensi
yang ada supaya pembangunan dapat berjalan, dan 'go get' akan melakukan hal
ini secara otomatis.
Hal yang sama, menurunkan versi salah satu dependensi bisa jadi menurunkan
dependensi yang lain, dan 'go get' juga menangani ini secara otomatis.

Opsi -insecure membolehkan pengambilan dari repositori yang menggunakan skema
tidak aman seperti HTTP.
Gunakan dengan hati-hati.

Langkah kedua yaitu mengunduh (bila perlu), membangun, dan memasang paket yang
diminta.

Jika argumen berupa modul bukan paket (karena tidak ada sumber kode Go dalam
direktori akar dari modul), maka langkah pemasangan dilewati, bukan
menyebabkan gagal pembangunan.
Misalnya, 'go get golang.org/x/perf' akan sukses walaupun tidak ada kode di
dalam path impor tersebut.

Ingat bahwa pola paket dibolehkan dan dikembangkan setelah versi modul
diselesaikan.
Misalnya, 'go get golang.org/x/perf/cmd/...' menambahkan versi
'golang.org/x/perf' yang terakhir dan kemudian memasang perintah-perintah pada
versi yang terakhir juga.

Opsi -d membuat 'get' mengunduh kode yang dibutuhkan untuk membangun paket,
termasuk mengunduh dependensi yang dibutuhkan, namun tidak membangun dan
memasang mereka.

Tanpa ada argumen, 'go get' berlaku terhadap paket Go di direktori yang
sekarang, jika ada.
Terutama, 'go get -u' dan 'go get -u=patch' memperbarui semua dependensi dari
paket tersebut.
Jika tidak ada argumen paket dan juga tanpa -u, 'go get' hampir sama dengan
'go install', dan 'go get -d' hampir sama dengan 'go list'.

Untuk lebih tentang modul, lihat 'go help modules'.

Untuk lebih lanjut tentang argumen paket, lihat 'go help packages'.

Tulisan ini menjelaskan perilaku dari 'get' pada modul untuk mengatur kode dan
dependensi.
Jika perintah 'go' berjalan dalam mode GOPATH, opsi dari 'get' berubah,
sebagaimana juga 'go help get'.
Lihat 'go help modules' dan 'go help gopath-get'.

Lihat juga: go build, go install, go clean, go mod.


==  Kompilasi dan pasang paket dan dependensi

Penggunaan:

----
go install [-i] [build flags] [packages]
----

Perintah 'install' mengompilasi dan memasang paket berdasarkan path impor.

Program _executable_ dipasang dalam direktori GOBIN dari variabel lingkungan,
yang bila kosong akan diset ke $GOPATH/bin atau $HOME/go/bin.
Program dalam $GOROOT dipasang di $GOROOT/bin atau $GOTOOLDIR bukan $GOBIN.

Jika mode modul tidak aktif, paket-paket lain dipasang dalam direktori
$GOPATH/pkg/$GOOS_$GOARCH.
Jika mode modul aktif, paket-paket dibangun dan di-_cache_ tapi tidak
dipasang.

Opsi -i memasang dependensi dari paket juga.

Untuk informasi lebih lanjut tentang opsi pembangunan, lihat 'go help build'.
Untuk informasi lebih lanjut tentang penamaan paket, lihat 'go help packages'.

Lihat juga: go build, go get, go clean.


==  Cetak daftar paket atau modul

Penggunaan:

----
go list [-f format] [-json] [-m] [list flags] [build flags] [packages]
----

Perintah 'list' mencetak nama paket, per baris.
Opsi yang sering digunakan yaitu -f dan -json, yang mengatur pencetakan dari
setiap paket.
Opsi 'list' lainnya, mengontrol detail yang lebih khusus.

Keluaran bakunya mencetak path impor dari paket:

----
bytes
encoding/json
github.com/gorilla/mux
golang.org/x/net/html
----

Opsi -f menentukan format alternatif dari daftar tersebut, menggunakan
sintaksis dari templat paket.
Keluaran bakunya sama dengan -f '{{.ImportPath}}'.
Struct yang dikirim ke templat yaitu:

----
type Package struct {
    Dir           string   // direktori yang berisi sumber paket
    ImportPath    string   // path impor dari paket dalam direktori
    ImportComment string   // path dalam komentar impor di perintah 'package'
    Name          string   // nama paket
    Doc           string   // dokumentasi paket
    Target        string   // path pemasangan
    Shlib         string   // pustaka yang berisi paket ini (hanya di set saat -linkshared)
    Goroot        bool     // apakah paket ini ada di Go root?
    Standard      bool     // apakah paket ini bagian dari pustaka standar Go?
    Stale         bool     // apakah 'go install' melakukan sesuatu pada paket ini?
    StaleReason   string   // penjelasan untuk Stale==true
    Root          string   // direktori Go root atau Go path yang berisi paket ini
    ConflictDir   string   // direktori ini menutup direktori dalam $GOPATH
    BinaryOnly    bool     // paket yang binari saja (tidak lagi didukung)
    ForTest       string   // paket hanya digunakan pada tes
    Export        string   // berkas berisi data ekspor (saat menggunakan -export)
    Module        *Module  // info tentang paket berisi modul, jika ada (bisa nil)
    Match         []string // pola baris-perintah yang sesuai dengan paket ini
    DepOnly       bool     // paket ini hanya lah dependensi, tidak terdaftar secara eksplisit

    // Berkas-berkas sumber
    GoFiles         []string // berkas-berkas .go (kecuali CgoFiles, TestGoFiles, XTestGoFiles)
    CgoFiles        []string // berkas-berkas .go yang mengimpor "C"
    CompiledGoFiles []string // berkas-berkas .go yang diberikan ke compiler (bila menggunakan -compiled)
    IgnoredGoFiles  []string // berkas-berkas .go yang diindahkan karena batasan pembangunan
    CFiles          []string // berkas-berkas .c
    CXXFiles        []string // berkas-berkas .cc, .cxx and .cpp
    MFiles          []string // berkas-berkas .m
    HFiles          []string // berkas-berkas .h, .hh, .hpp and .hxx
    FFiles          []string // berkas-berkas .f, .F, .for dan .f90 Fortran
    SFiles          []string // berkas-berkas .s
    SwigFiles       []string // berkas-berkas .swig
    SwigCXXFiles    []string // berkas-berkas .swigcxx
    SysoFiles       []string // berkas-berkas objek .syso yang ditambahkan ke arsip
    TestGoFiles     []string // berkas-berkas _test.go dalam paket
    XTestGoFiles    []string // berkas-berkas _test.go di luar paket

    // Cgo directives
    CgoCFLAGS    []string // cgo: opsi untuk C compiler
    CgoCPPFLAGS  []string // cgo: opsi untuk C preprocessor
    CgoCXXFLAGS  []string // cgo: opsi untuk C++ compiler
    CgoFFLAGS    []string // cgo: opsi untuk Fortran compiler
    CgoLDFLAGS   []string // cgo: opsi untuk linker
    CgoPkgConfig []string // cgo: nama-nama pkg-config

    // Dependency information
    Imports      []string          // path impor yang digunakan oleh paket ini
    ImportMap    map[string]string // map dari impor ke ImportPath (identitas dihilangkan)
    Deps         []string          // semua (rekursif) dependensi yang diimpor
    TestImports  []string          // impor dari TestGoFiles
    XTestImports []string          // impor dari XTestGoFiles

    // Error information
    Incomplete bool            // paket ini atau dependensinya memiliki eror
    Error      *PackageError   // eror pada pemuatan paket
    DepsErrors []*PackageError // eror pada pemuatan dependensi
}
----

Paket yang disimpan dalam direktori vendor melaporkan ImportPath yang
mengikutkan path ke direktori vendor (misalnya, "d/vendor/p" bukan "p"),
sehingga ImportPath secara unik mengidentifikasi salinan dari sebuah paket.
Daftar pada Imports, Deps, TestImports, dan XTestImports juga berisi path
impor yang diperluas ini.
Lihat golang.org/s/go15vendor untuk lebih lanjut tentang "vendor".

Informasi eror, jika ada, yaitu

----
type PackageError struct {
    ImportStack   []string // path terpendek dari nama paket pada baris-perintah ke paket yang sekarang
    Pos           string   // posisi eror (jika ada, berkas:baris:kolom)
    Err           string   // eror itu sendiri
}
----

Informasi modul yaitu struct Module, didefinisikan dalam diskusi dari daftar
-m di bawah.

Fungsi templat "join" memanggil strings.Join.

Fungsi templat "context" mengembalikan context pembangunan, didefinisikan
sebagai:

----
type Context struct {
    GOARCH        string   // target arsitektur
    GOOS          string   // target sistem operasi
    GOROOT        string   // Go root
    GOPATH        string   // Go path
    CgoEnabled    bool     // apakah cgo dapat digunakan
    UseAllFiles   bool     // gunakan berkas, mengindahkan baris +build lines, nama berkas
    Compiler      string   // compiler yang digunakan untuk path target
    BuildTags     []string // batasan build sesuai baris +build
    ReleaseTags   []string // rilis yang sekarang tidak kompatibel
    InstallSuffix string   // sufiks yang digunakan dalam direktori pemasangan
}
----

Untuk informasi lebih lanjut tentang makna dari field-field tersebut lihat
dokumentasi paket go/build untuk tipe Context.
