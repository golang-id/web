=  Spesifikasi Bahasa Pemrograman Go
:stylesheet: /assets/style.css
:toc:

==  Versi 2018 November 16

[#Introduction]
==  Pendahuluan

Dokumen ini adalah referensi manual untuk bahasa pemrograman Go.
Untuk informasi dan dokumentasi lainnya lihat
https://golang.org[golang.org (Inggris)]
atau
link:/[golang-id.org (Indonesia)].

Go adalah bahasa pemrograman yang dirancang untuk pemrograman sistem.
Go adalah bahasa dengan tipe yang kuat dan dengan _garbage-collection_ dan
mendukung pemrograman konkuren secara eksplisit.
Program dibangun dari paket-paket, yang membolehkan ketergantungan
paket secara efisien.

Tata-bahasa dari Go padat dan teratur, membuatnya mudah untuk dianalisis oleh
perkakas-perkakas otomatis seperti lingkungan pengembangan integrasi (IDE).


[#Notation]
===  Notasi

Spesifikasi sintaksis menggunakan _Extended Backus-Naur Form_ (EBNF):

----
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
----

_Production_ adalah ekspresi yang dibangun dari sekumpulan _term_ dan operator
pendukung berikut, secara berurut:

----
|   alternasi
()  pengelompokan
[]  opsi (0 atau 1 kali)
{}  pengulangan (0 sampai n kali)
----

Nama `production_name` dengan huruf kecil digunakan untuk mengidentifikasi
token leksikal.
`production_name` dengan _CamelCase_ adalah _non-terminal_ (tidak berakhir).
Token leksikal dibungkus dalam tanda kutip ganda " " atau kutip terbalik ````.

Bentuk `a … b` merepresentasikan kumpulan huruf alternatif dari `a` sampai
`b`.
Elipsis horizontal `…` juga digunakan dalam spesifikasi ini
untuk secara informal menandakan enumerasi atau kode yang dipotong.
Karakter `…` (berlawanan dengan tiga karakter ...) bukanlah token dari
bahasa Go.

[#Source_code_representation]
==  Representasi sumber kode

Sumber kode adalah teks Unicode dalam
https://id.wikipedia.org/wiki/UTF-8[UTF-8].
Teks tersebut tidak kanonis, sehingga titik kode dengan aksen berbeda dengan
karakter yang sama yang dibangun dari menggabungkan sebuah aksen dan sebuah
huruf;
keduanya dianggap sebagai dua titik kode.
Demi kemudahan, dokumen ini menggunakan istilah _karakter_ untuk mengacu pada
titik kode Unicode dalam teks sumber kode.

Setiap titik kode berbeda satu dengan yang lainnya; misalnya, huruf besar dan
kecil adalah karakter yang berbeda.

Batasan implementasi: Untuk kompatibilitas dengan perkakas lainnya, _compiler_
mungkin tidak membolehkan karakter NUL (U+0000) dalam teks sumber kode.

Batasan implementasi: Untuk kompatibilitas dengan perkakas lainnya, _compiler_
bisa mengindahkan penanda urutan byte untuk _UTF-8-encoded_ (U+FEFF) jika ia
adalah titik kode Unicode pertama dalam teks sumber kode.
Penanda urutan _byte_ bisa saja tidak dibolehkan dalam sumber kode.

[#Characters]
===  Karakter

Istilah berikut digunakan untuk menandakan kelas karakter Unicode tertentu:

----
newline        = /* titik kode Unicode U+000A untuk baris baru */ .
unicode_char   = /* titik kode Unicode apa pun kecuali baris baru */ .
unicode_letter = /* titik kode Unicode dikelompokkan sebagai "Letter" (huruf) */ .
unicode_digit  = /* titik kode Unicode dikelompokkan sebagai "Number, decimal digit" */ .
----

https://www.unicode.org/versions/Unicode8.0.0/[The Unicode Standard 8.0],
Bagian 4.5 "General Category" mendefinisikan sekumpulan kategori karakter.
Go mengenali semua karakter dalam kategori Letter berikut Lu, Ll, Lt, Lm, atau
Lo sebagai huruf Unicode, dan yang berada dalam kategori Number Nd sebagai
angka Unicode.

[#Letters_and_digits]
===  Huruf dan angka

Karakter garis bawah `_` (U+005F) dianggap sebagai huruf.

----
letter        = unicode_letter | "_" .
decimal_digit = "0" … "9" .
octal_digit   = "0" … "7" .
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .
----


[#Lexical_elements]
==  Elemen leksikal

[#Comments]
===  Komentar

Komentar berfungsi sebagai dokumentasi program.
Ada dua bentuk komentar:

.  _Komentar baris_ dimulai dengan urutan karakter `//` dan berakhir pada
   ujung baris.
.  _Komentar umum_ dimulai dengan urutan karakter `/*` dan berakhir dengan
   urutan karakter `*/` yang pertama.

Komentar tidak boleh dimulai dalam sebuah
<<Rune_literals,rune>>
atau
<<String_literals,string>>,
atau di dalam komentar yang lain.
Komentar umum tanpa baris baru berarti memiliki sebuah spasi.
Komentar lainnya akan diartikan berada pada baris baru.


[#Tokens]
===  Token

Token-token membentuk kosakata dari bahasa Go.
Ada empat kelas token: _identifiers_ (pengidentifikasi), _keywords_
(kata-kunci), _operators dan punctuation_ (operator dan tanda baca),
dan _literal_ (abjad).
Karakter kosong yang dibentuk dari spasi (U+0020), tab horizontal (U+0009),
_carriage returns_ (U+0009), dan baris baru (U+000A), diindahkan kecuali ia
memisahkan token-token yang bila digabungkan menjadi sebuah token.
Juga, sebuah baris baru atau akhir dari berkas bisa memicu
<<#Semicolons,titik-koma>>.
Saat memecah input menjadi token-token, token selanjutnya adalah urutan
karakter terpanjang yang membentuk sebuah token yang valid.

[#Semicolons]
===  Titik-koma

Tata-bahasa formal menggunakan titik-koma ";" sebagai penanda akhir pada
beberapa pernyataan.
Program Go bisa menghilangkan titik-koma tersebut menggunakan dua aturan
berikut:

.  Saat input terpecah menjadi token-token, sebuah titik-koma secara otomatis
   langsung ditambahkan ke dalam aliran token setelah token terakhir pada
   sebuah baris jika token tersebut adalah

   *  sebuah <<#Identifiers,pengidentifikasi>>
   *  sebuah <<#Integer_literals,integer>>,
      <<#Floating-point_literals,floating-point>>, <<#Rune_literals,rune>>,
      atau <<#String_literals,string>>
   *  salah satu <<#Keywords,kata-kunci>> `break`, `continue`, `fallthrough`,
      atau `return`
   *  salah satu <<#Operators_and_punctuation,operator dan tanda baca>> `++`,
      `--`, `)`, `]`, atau `}`

.  Untuk membolehkan perintah yang kompleks menghabiskan satu baris,
   titik-koma bisa dihilangkan sebelum ditutup oleh ")" atau "}"

Untuk merefleksikan penggunaan idiomatis, contoh kode dalam dokumen ini tidak
menggunakan titik-koma menggunakan aturan di atas.


[#Identifiers]
[Pengidentifikasi]

Pengidentifikasi memberi nama entitas seperti variabel dan tipe.
Sebuah pengidentifikasi adalah sebuah urutan satu atau lebih huruf dan angka.
Karakter pertama dalam sebuah pengidentifikasi haruslah huruf.

----
identifier = letter { letter | unicode_digit } .
----

----
a
_x9
ThisVariableIsExported
αβ
----

Beberapa pengidentifikasi <<#Predeclared_identifiers,telah dideklarasikan
sebelumnya>>.

[#Keywords]
===  Kata kunci

Kata kunci berikut telah disiapkan dan tidak bisa digunakan sebagai
pengidentifikasi:

----
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
----

[#Operators_and_punctuation]
===  Operator dan tanda baca

Urutan karakter berikut merepresentasikan
<<#Operators,operator>>
(termasuk <<#assign_op,operator penempatan>>)
dan tanda baca:

----
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=
----

[#Integer_literals]
===  Abjad integer

Abjad integer adalah urutan angka merepresentasikan sebuah
<<#Constants,konstan integer>>.
Beberapa opsi prefiks menyatakan basis non-desimal: `0` untuk oktal, `0x`
atau `0x` untuk heksadesimal.
Dalam abjad heksadesimal, huruf `a-f` dan `A-F` merepresentasikan nilai antara
10 sampai 155.

----
int_lit     = decimal_lit | octal_lit | hex_lit .
decimal_lit = ( "1" … "9" ) { decimal_digit } .
octal_lit   = "0" { octal_digit } .
hex_lit     = "0" ( "x" | "X" ) hex_digit { hex_digit } .
----

----
42
0600
0xBadFace
170141183460469231731687303715884105727
----


[#Floating-point_literals]
===  Abjad _floating-point_

Abjad _floating-point_ adalah representasi desimal dari
<<#Constants,konstan _floating-point_>>.
Ia memiliki bagian integer, titik desimal, bagian pecahan, dan bagian
eksponen.
Bagian integer dan pecahan terdiri dari angka desimal;
bagian eksponen yaitu `e` atau `E` diikuti dengan nilai eksponen.
Salah satu bagian integer atau pecahan bisa diindahkan;
salah satu bagian pecahan atau eksponen bisa diindahkan juga.

----
float_lit = decimals "." [ decimals ] [ exponent ] |
            decimals exponent |
            "." decimals [ exponent ] .
decimals  = decimal_digit { decimal_digit } .
exponent  = ( "e" | "E" ) [ "+" | "-" ] decimals .
----

----
0.
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
----


[#Imaginary_literals]
===  Abjad imajiner

Abjad imajiner merepresentasikan bagian imajiner dari
<<#Constants,konstan kompleks>>.
Ia terdiri dari abjad
<<#Integer_literals,integer>>
atau
<<#Floating-point_literals,floating-point>>
diikuti oleh huruf kecil `i`.
Nilai dari abjad imajiner yaitu nilai dari abjad integer atau floating-point
dikalikan dengan unit imajiner _i_.

----
imaginary_lit = (decimal_digits | int_lit | float_lit) "i" .
----

Untuk kompatibilitas, bagian integer dari abjad imajiner yang
semuanya terdiri dari angka desimal (dan kemungkinan garis bawah) dianggap
sebagai integer desimal, walaupun dimulai dengan `0`.

----
0i
0123i         // == 123i untuk kompatibilitas
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
0x1p-2i       // == 0x1p-2 * 1i == 0.25i
----


[#Rune_literals]
===  Abjad rune

Abjad rune merepresentasikan sebuah link:/ref/spec#Constants[konstan rune],
sebuah nilai integer yang mengidentifikasi sebuah kode poin Unicode.
Abjad rune diekspresikan dengan satu atau lebih karakter yang ditutup dengan
tanda kutip tunggal, seperti `'x'` atau `'\n'`.
Di dalam tanda kutip tersebut, karakter apa pun dapat ditulis kecuali baris
baru dan tanda kutip tunggal itu sendiri.
Sebuah karakter dengan kutip merepresentasikan nilai Unicode dari karakter itu
sendiri, sementara seurutan karakter yang dimulai dengan garis miring terbalik
(_backslash_) akan ditulis nilainya menjadi beragam format.

Bentuk sederhana dari rune merepresentasikan karakter tunggal antara tanda
kutip; secara teks sumber kode dari Go adalah karakter Unicode yang ditulis
dalam UTF-8, multipel UTF-8 byte bisa merepresentasikan sebuah nilai integer.
Misalnya, abjad `'a'` menyimpan sebuah byte yang merepresentasikan sebuah
abjad `a`, Unicode U+0061, dengan nilai `0x61`; sementara `'ä'` menyimpan dua
byte (`0xc3 0xa4`) yang merepresentasikan abjad a-dwititik, U+00E4, nilai
`0xe4`.

Beberapa _backslash_ membolehkan nilai beragam ditulis sebagai teks ASCII.
Ada empat cara untuk merepresentasikan nilai integer sebagai konstan
numerik: `\x` diikuti dengan dua digit heksadesimal; `\u` diikuti dengan empat
digit heksadesimal; `\U` diikuti dengan delapan heksadesimal, dan _backslash_
kosong `\` diikuti dengan tiga digit oktal.
Pada setiap kasus tersebut nilai dari abjad adalah nilai yang
direpresentasikan oleh digit pada basis yang berhubungan.

Walaupun representasi tersebut semua hasilnya adalah sebuah integer, mereka
memiliki rentang yang berbeda.
Oktal harus merepresentasikan sebuah nilai antara 0 dan 255 secara inklusif.
Heksadesimal memenuhi kondisi ini secara konstruksi.
`\u` dan `\U` merepresentasikan kode poin Unicode sehingga beberapa nilai
adalah ilegal, khususnya nilai di atas `0x10FFFF` dan _surrogate half_
(bagian setengah atas dari empat heksadesimal).

Setelah tanda _backslash_, beberapa karakter tunggal merepresentasikan nilai
spesial:

----
\a   U+0007 alert atau bel
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed atau newline
\r   U+000D carriage return
\t   U+0009 tab horizontal
\v   U+000b tab vertikal
\\   U+005c backslash (garis miring terbalik)
\'   U+0027 tanda kutip tunggal (valid hanya pada abjad rune)
\"   U+0022 tanda kutip ganda (valid hanya pada abjad string)
----

Urutan karakter lain yang dimulai dengan sebuah _backslash_ adalah ilegal di
dalam abjad rune.

----
rune_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
----

----
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // abjad rune berisi sebuah karakter kutip
'aa'         // ilegal: terlalu banyak karaketer
'\xa'        // ilegal: terlalu sedikit digit heksadesimal
'\0'         // ilegal: terlalu sedikit digit oktal
'\uDFFF'     // ilegal: setengah
'\U00110000' // ilegal: invalid Unicode
----


[#String_literals]
===  Abjad string

Abjad string merepresentasikan
link:/ref/spec#Constants[konstan string] yang didapat dari menggabungkan
seurutan karakter-karakter.
Ada dua bentuk string: abjad string mentah dan abjad string interpretasi.

Abjad string mentah yaitu seurutan karakter antara kutip terbalik (aksen
nontirus), seperti dalam ````foo```` .
Di antara tanda kutip terbalik, karakter apa pun dapat muncul kecuali tanda
kutip terbalik itu sendiri.
Nilai dari abjad string mentah tersebut yaitu string yang terdiri dari
karakter-karakter yang tidak diinterpretasi (implisit UTF-8) di antara tanda
kutip;
pada khususnya, _backslash_ tidak berfungsi dan string bisa memiliki baris
baru.
Karakter _carriage return_ (`'\r'`) di dalam abjad string mentah diindahkan
dari nilai string mentah.

Abjad string interpretasi yaitu seurutan karakter antara tanda kutip ganda,
seperti dalam`"bar"`.
Di antara tanda kutip, karakter apa pun bisa muncul kecuali baris baru dan
tanda kutip ganda lepas (tanpa _backslash_).
Teks antara tanda kutip membentuk nilai dari abjad, dengan _backslash_
diartikan seperti halnya dalam
link:/ref/spec#Rune_literals[abjad rune] (kecuali `\'` adalah ilegal dan `\"`
adalah legal), dengan batasan-batasan yang sama.
Tiga-digit oktal (_\nnn_) dan dua-digit heksadesimal (\x_nn_)
merepresentasikan _byte_ individu dari string;
karakter lepas lainnya merepresentasikan _encoding_ UTF-8 (bisa jadi
multi-byte) dari _karakter-karakter_ tersebut.
Maka di dalam abjad string, `\377` dan `\xFF` merepresentasikan nilai
`0xFF`=255, sementara `ÿ, `\u00FF`, `\U000000FF` dan `\xc3\xbf`
merepresentasikan dua byte `0xc3 0xbf` dari _encoding_ karakter UTF-8  U+00FF.

----
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .
----

----
`abc`                // sama dengan "abc"
`\n
\n`                  // sama dengan "\\n\n\\n"
"\n"
"\""                 // sama dengan `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"             // ilegal: _surrogate half_
"\U00110000"         // ilegal: invalid kode poin Unicode
----

Contoh berikut merepresentasikan string yang sama:

----
"日本語"                                 // UTF-8 input teks
`日本語`                                // UTF-8 input teks sebagai abjad mentah
"\u65e5\u672c\u8a9e"                    // kode poin Unicode eksplisit
"\U000065e5\U0000672c\U00008a9e"        // kode poin Unicode eksplisit
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // UTF-8 byte eksplisit
----

Jika sumber kode merepresentasikan sebuah karakter sebagai dua kode poin,
seperti sebuah gabungan bentuk mengikutkan aksen dan sebuah huruf, hasilnya
akan eror jika ditempatkan dalam sebuah abjad rune (karena bukanlah kode poin
tunggal), dan akan muncul sebagai dua kode poin jika ditempatkan dalam abjad
string.


[#Constants]
==  Konstan

Ada _konstan boolean_, _konstan rune_, _konstan integer_,
_konstan floating-point_, _konstan complex_, dan _konstan string_.
Konstan rune, integer, _floating-point_, dan complex secara kolektif disebut
dengan _konstan numerik_.

Nilai sebuah konstan direpresentasikan oleh sebuah abjad
link:/ref/spec#Rune_literals[rune],
link:/ref/spec#Integer_literals[integer],
link:/ref/spec#Floating-point_literals[_floating-point_],
link:/ref/spec#Imaginary_literals[imajiner], atau
link:/ref/spec#String_literals[string],
sebuah pengidentifikasi yang menyatakan sebuah konstan,
sebuah link:/ref/spec#Constant_expressions[ekspresi konstan],
sebuah link:/ref/spec#Conversions[konversi] dengan hasil sebuah konstan,
atau nilai hasil dari fungsi bawaan seperti `unsafe.Sizeof` yang diterapkan
terhadap nilai apa pun, `cap` atau `len` yang diterapkan pada
link:/ref/spec#Length_and_capacity[beberapa ekspresi],
`real` dan `imag` yang diterapkan pada konstan complex dan
`complex` yang diterapkan pada konstan numerik.
Nilai boolean direpresentasikan dengan konstan `true` dan `false`.
Identifikasi
link:/ref/spec#Iota[iota]
menyatakan konstan integer.

Secara umum, konstan complex adalah sebuah bentuk dari
link:/ref/spec#Constant_expressions[ekspresi konstan]
dan didiskusikan di bagian tersebut.

Konstan numerik merepresentasikan nilai eksak dari presisi beragam dan
tidak _overflow_.
Karena itu, tidak ada konstan yang menyatakan nilai negatif nol IEEE-754,
_infinity_, dan nilai bukan-angka.

Konstan bisa
link:/ref/spec#Types[bertipe] atau tak bertipe.
Konstan harfiah, `true`, `false`, `iota`, dan beberapa
link:/ref/spec#Constant_expressions[ekspresi konstan]
yang berisi hanya operan konstan tanpa tipe adalah konstan tak bertipe.

Sebuah konstan bisa diberikan tipe secara eksplisit dengan
link:/ref/spec#Constant_declarations[deklarasi konstan] atau
link:/ref/spec#Conversions[konversi], atau secara implisit bila digunakan dalam
sebuah
link:/ref/spec#Variable_declarations[deklarasi variabel]
atau dalam sebuah
link:/ref/spec#Assignments[penempatan]
atau sebagai sebuah operan dalam sebuah
link:/ref/spec#Expressions[ekspresi].
Jika nilai konstan tidak dapat
link:/ref/spec#Representability[direpresentasikan] sebagai sebuah nilai dari
tipe maka ia akan eror.

Konstan tak bertipe memiliki _tipe bawaan_ yaitu tipe yang mana konstan
secara implisit dikonversi dalam konteks di mana nilai bertipe dibutuhkan,
misalnya,
dalam
link:/ref/spec#Short_variable_declarations[deklarasi variabel singkat]
seperti `i := 0` yang mana tidak ada tipe eksplisit.
Tipe bawaan dari konstan tak bertipe adalah `bool`, `rune`, `int`, `float64`,
`complex128` atau `string`, bergantung kepada apakah ia adalah sebuah konstan
boolean, rune, integer, _floating-point_, complex, atau string.

Batasan implementasi: Walaupun konstan numerik memiliki presisi beragam
dalam bahasa Go, _compiler_ bisa saja mengimplementasikan mereka menggunakan
representasi internal dengan presisi terbatas.
Dengan kata lain, setiap implementasi harus:

*  Merepresentasikan konstan integer paling tidak 256 bit.
*  Merepresentasikan konstan _floating-point_, termasuk bagian dari
   konstan complex, dengan mantisa setidaknya 256 bit dan sebuah eksponen
   binary _signed_ setidaknya 16 bit.
*  Kembalikan eror bila tidak bisa merepresentasikan konstan integer secara
   tepat.
*  Kembalikan eror bila tidak bisa merepresentasikan sebuah konstan
   _floating-point_ atau complex karena _overflow_.
*  Bulatkan ke konstan terdekat yang dapat direpresentasikan jika tidak bisa
   merepresentasikan konstan _floating-point_ atau complex dikarenakan limit
   atau presisi.

Kebutuhan-kebutuhan di atas berlaku baik terhadap konstan harfiah dan
terhadap hasil dari mengevaluasi
link:/ref/spec#Constant_expressions[ekspresi konstan].


[#Variables]
==  Variabel

Sebuah variabel adalah sebuah lokasi penampung untuk menyimpan sebuah _nilai_.
Kumpulan dari nilai yang diperbolehkan ditentukan oleh
link:/ref/spec#Types[tipe]
variabel.

Sebuah
link:/ref/spec#Variable_declarations[deklarasi variabel] atau penanda dari
link:/ref/spec#Function_declarations[deklarasi fungsi] (pada parameter dan
kembalian dari fungsi),
atau
link:/ref/spec#Function_literals[fungsi literal]
mencadangkan penampung untuk sebuah variabel bernama.
Memanggil fungsi bawaan
link:/ref/spec#Allocation[new]
atau mengambil alamat dari sebuah
link:/ref/spec#Composite_literals[abjad komposit]
mengalokasikan penampung untuk sebuah variabel pada saat _runtime_.
Variabel anonim diacu lewat sebuah (bisa jadi implisit)
link:/ref/spec#Address_operators[pointer tak-langsung].

Variabel berstruktur dari tipe
link:/ref/spec#Array_types[array],
link:/ref/spec#Slice_types[slice], dan
link:/ref/spec#Struct_types[struct]
memiliki elemen-elemen dan field-field yang bisa
link:/ref/spec#Address_operators[diakses]
secara individu.
Setiap elemen tersebut berlaku seperti sebuah variabel.

_Tipe statis_ (atau _tipe_) dari sebuah variabel yaitu tipe yang diberikan
saat deklarasi, tipe yang diberikan pada saat pemanggilan `new` atau
komposit literal, atau tipe dari sebuah elemen dari variabel berstruktur.
Variabel dari tipe interface memiliki _tipe dinamis_ berbeda, yaitu tipe
konkret dari nilai yang diberikan ke variabel pada saat _runtime_ (kecuali
bila nilainya adalah `nil`, yang berarti tak bertipe).
Tipe dinamis bisa beragam selama eksekusi namun nilai yang disimpan dalam
variabel interface selalu
link:/ref/spec#Assignability[ditempatkan]
ke tipe statis dari variabel.

----
var x interface{}  // x adalah nil dengan tipe statis interface{}
var v *T           // v bernilai nil, tipe statis *T
x = 42             // x bernilai 42 dan tipe dinamis int
x = v              // x bernilai (*T)(nil) dan tipe dinamis *T
----

Nilai variabel diambil dengan mengacu pada variabel dalam sebuah
link:/ref/spec#Expressions[ekspresi];
nilai dari variabel yaitu nilai terakhir yang
link:/ref/spec#Assignments[ditempatkan]
ke variabel tersebut.
Jika sebuah variabel belum diberi nilai, nilainya adalah
link:/ref/spec#The_zero_value[nilai kosong]
dari tipe variabel.


[#Types]
==  Tipe

Sebuah tipe menentukan sekumpulan nilai berikut dengan operasi dan method
yang spesifik terhadap nilainya.
Sebuah tipe bisa ditulis dengan sebuah _nama tipe_, jika ada, atau
dispesifikasikan menggunakan _literal tipe_, yang membentuk sebuah tipe dari
tipe-tipe yang telah ada.

----
Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
	    SliceType | MapType | ChannelType .
----

Bahasa Go
link:/ref/spec#Predeclared_identifiers[mendeklarasikan]
beberapa nama tipe.
Nama tipe lainnya diperkenalkan lewat
link:/ref/spec#Type_declarations[deklarasi tipe].
_Tipe komposit_ -- tipe array, struct, pointer, fungsi, interface, slice, map,
dan channel -- bisa dibangun menggunakan literal tipe.

Setiap tipe T memiliki _tipe dasar_: Jika `T` adalah salah satu tipe boolean,
numerik, string, literal; make tipe dasar dari `T` itu sendiri adalah `T`.
Selain itu, tipe dasar dari `T` yaitu tipe yang diberikan saat
link:/ref/spec#Type_declarations[deklarasi].

----
type (
	A1 = string
	A2 = A1
)

type (
	B1 string
	B2 B1
	B3 []B1
	B4 B3
)
----

Tipe dasar dari `string`, `A1`, `A2`, `B1`, dan `B2` adalah `string`.
Tipe dasar dari `[]B1`, `B3`, dan `B4` yaitu `[]B1`.

[#Method_sets]
===  Kumpulan method

Sebuah tipe bisa memiliki _sekumpulan method_.
Kumpulan method dari
link:/ref/spec#Interface_types[tipe interface]
yaitu interface-nya sendiri.
Kumpulan method dari tipe `T` terdiri dari semua
link:/ref/spec#Method_declarations[method-method]
yang dideklarasikan pada penerima (_receiver_) tipe `T`.
Kumpulan method dari
link:/ref/spec#Pointer_types[tipe pointer] `*T` yaitu semua
method yang dideklarasikan dengan penerima `*T` atau `T` (ia berisi juga
kumpulan method dari `T`).
Aturan yang sama juga berlaku untuk struct yang berisi field-field yang
ditanam (_embed_), seperti yang dijelaskan dalam bagian
link:/ref/spec#Struct_types[tipe struct].
Tipe apa pun memiliki kumpulan method kosong.
Di dalam sebuah kumpulan method, setiap method harus memiliki
link:/ref/spec#MethodName[nama method]
yang unik dan tidak kosong.

Kumpulan method dari sebuah tipe menentukan interface yang
link:/ref/spec#Interface_types[diimplementasi]
oleh tipe tersebut dan method tersebut bisa
link:/ref/spec#Calls[dipanggil]
menggunakan penerima dari tipe tersebut.


[#Boolean_types]
===  Tipe boolean

Sebuah _tipe boolean_ merepresentasikan kumpulan nilai Boolean yang
dilambangkan oleh konstan `true` dan `false`.
Tipe boolean dikenal sebagai `bool`;
ia adalah
link:/ref/spec#Type_definitions[tipe terdefinisi].


[#Numeric_types]
===  Tipe numerik

_Tipe numerik_ merepresentasikan kumpulan nilai integer atau _floating-point_.
Deklarasi dari tipe numerik, yang bergantung pada arsitektur, yaitu:

----
uint8       kumpulan semua unsigned  8-bit integer (0 sampai 255)
uint16      kumpulan semua unsigned 16-bit integer (0 sampai 65535)
uint32      kumpulan semua unsigned 32-bit integer (0 sampai 4294967295)
uint64      kumpulan semua unsigned 64-bit integer (0 sampai 18446744073709551615)

int8        kumpulan semua signed  8-bit integers (-128 sampai 127)
int16       kumpulan semua signed 16-bit integers (-32768 sampai 32767)
int32       kumpulan semua signed 32-bit integers (-2147483648 sampai 2147483647)
int64       kumpulan semua signed 64-bit integers (-9223372036854775808 sampai 9223372036854775807)

float32     kumpulan semua IEEE-754 32-bit bilangan floating-point
float64     kumpulan semua IEEE-754 64-bit bilangan floating-point

complex64   kumpulan semua bilangan complex dengan float32 pada bagian real dan imajiner
complex128  kumpulan semua bilangan complex dengan float64 pada bagian real dan imajiner

byte        alias untuk uint8
rune        alias untuk int32
----

Nilai dari _n_-bit integer yaitu _n_ bit lebarnya dan direpresentasikan
menggunakan
https://en.wikipedia.org/wiki/Two's_complement[aritmetika komplemen ganda].

Ada juga kumpulan tipe numerik yang ukurannya tergantung pada arsitektur:

----
uint     bisa 32 atau 64 bit
int      berukuran sama dengan uint
uintptr  unsigned integer cukup besar menyimpan bit dari nilai pointer
----

Untuk menghindari masalah portabilitas semua tipe numerik adalah
link:/ref/spec#Type_definitions[tipe terdefinisi]
dan makanya berbeda kecuali `byte`, yang merupakan
link:/ref/spec#Alias_declarations[alias]
dari `uint8`, dan `rune`, yang merupakan alias untuk `uint32`.
Konversi eksplisit dibutuhkan saat tipe numerik berbeda bertemu pada sebuah
ekspresi atau pernyataan.
Misalnya, `int32` dan `int` bukanlah tipe yang sama walaupun keduanya
berukuran sama pada arsitektur tertentu.


[#String_types]
===  Tipe string

_Tipe string_ merepresentasikan kumpulan nilai string.
Nilai sebuah string yaitu (bisa kosong) urutan dari byte.
Jumlah byte disebut juga panjang dari string dan tidak pernah negatif.
String adalah _immutable_ (tetap): sekali dibuat, maka tidak akan bisa lagi
diubah isinya.
Tipe string yaitu `string`; ia adalah
link:/ref/spec#Type_definitions[tipe terdefinisi].

Panjang dari string `s` dapat diketahui lewat fungsi bawaan
link:/ref/spec#Length_and_capacity[len].
Panjangnya akan konstan bila string tersebut adalah konstan.
Isi byte dari string dapat diakses dengan
link:/ref/spec#Index_expressions[indeks]
0 sampai `len(s)-1`.
Mengambil alamat byte pada string adalah ilegal;
jika `s[i]` adalah byte ke `i` dari string, maka `&s[i]` tidak valid.


[#Array_types]
===  Tipe array

Sebuah array yaitu urutan elemen dari sebuah tipe yang jumlahnya tetap.
Jumlah dari elemen disebut juga dengan panjang array dan tidak pernah negatif.

----
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .
----

Panjang array adalah bagian dari tipe array;
Ia harus berupa
link:/ref/spec#Constants[konstanta]
non-negatif yang
link:/ref/spec#Representability[direpresentasikan]
oleh nilai bertipe `int`.
Panjang dari array `a` dapat diketahui dengan fungsi bawaan
link:/ref/spec#Length_and_capacity[len].
Setiap elemen array dapat diakses lewat
link:/ref/spec#Index_expressions[indeks]
0 sampai `len(a)-1`.
Tipe array selalu satu dimensi namun bisa digabung untuk membentuk tipe
multi-dimensi.

----
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // sama dengan [2]([2]([2]float64))
----


[#Slice_types]
===  Tipe slice

Sebuah slice adalah penampung dari segmen bersambungan dari sebuah
_array dasar_ dan menyediakan akses ke elemen dari array tersebut.
Sebuah tipe slice menandakan kumpulan dari semua bagian dari array dari tipe
elemennya.
Jumlah elemen disebut dengan panjang slice dan tidak pernah negatif.
Nilai dari slice yang tidak diinisiasi yaitu `nil`.

----
SliceType = "[" "]" ElementType .
----

Panjang dari slice diketahui lewat fungsi bawaan
link:/ref/spec#Length_and_capacity[len];
tidak seperti array ia bisa berubah selama eksekusi.
Elemen slice bisa diakses lewat integer
link:/ref/spec#Index_expressions[indeks]
0 sampai `len(s)-1`.
Indeks slice dari elemen bisa kecil dari indeks dari elemen yang sama di array
dasarnya.

Sebuah slice, setelah diinisiasi, selalu berasosiasi dengan array dasar yang
menyimpan elemen-elemennya.
Oleh karena itu sebuah slice berbagi tempat penyimpanan dengan array-nya dan
dengan slice lain dari array yang sama;
sebaliknya, array yang berbeda merepresentasikan tempat penyimpanan yang
berbeda.

Array yang mendasari sebuah slice bisa diperlebar melebihi akhir dari slice.
Konsep ini dikenal dengan _kapasitas_: ia adalah jumlah panjang dari slice dan
panjang dari array-dasar slice;
Sebuah slice yang panjangnya lebih dari kapasitas bisa dibuat dengan
link:/ref/spec#Slice_expressions[_slicing_] (memotong)
yang baru dari slice asli.
Kapasitas dari slice `a` dapat diketahui menggunakan fungsi bawaan
link:/ref/spec#Length_and_capacity[`cap(a)`].

Slice baru bertipe `T` dapat diinisiasi menggunakan fungsi bawaan
link:/ref/spec#Making_slices_maps_and_channels[make],
yang menerima tipe slice dan parameter yang menentukan panjang, dan opsi
kapasitas.
Sebuah slice yang dibuat dengan `make` selalu mengalokasikan array yang baru
yang diacu oleh slice yang dikembalikan.
Sehingga, mengeksekusi

----
make([]T, length, capacity)
----

menghasilkan slice yang sama seperti membuat array dan
link:/ref/spec#Slice_expressions[memotongnya],
sehingga dua ekspresi berikut adalah sama:

----
make([]int, 50, 100)
new([100]int)[0:50]
----

Seperti halnya array, slice selalu satu-dimensi namun bisa bergabung membentuk
objek dengan dimensi lebih tinggi.
Lewat array dari array, array di dalamnya, selalu memiliki panjang yang sama;
namun dengan slice dari slice (atau array dari slice), panjang di dalamnya
bisa beragam secara dinamis.
Lebih lanjut, slice paling dalam harus diinisiasi secara sendiri-sendiri.


[#Struct_types]
===  Tipe struct

Sebuah struct yaitu urutan dari elemen bernama, disebut field, tiap-tiap field
memiliki nama dan tipe.
Nama field bisa secara eksplisit (IdentifierList) atau secara implisit
(EmbeddedField).
Dalam sebuah struct, nama field yang tidak
link:/ref/spec#Blank_identifier[kosong]
haruslah
link:/ref/spec#Uniqueness_of_identifiers[unik].

----
StructType    = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
EmbeddedField = [ "*" ] TypeName .
Tag           = string_lit .
----

----
// Sebuah struct kosong.
struct {}

// Sebuah struct dengan 6 field.
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
----

Field dengan tipe namun tanpa nama disebut dengan _field tertanam_.
Field tertanam haruslah tipe bernama `T` atau sebagai pointer ke tipe bernama
yang bukan interface `*T`, dan `T` itu sendiri bisa saja bukan tipe pointer.
Nama tipe pada field tertanam berlaku sebagai nama field.

----
// Sebuah struct dengan empat field tertanam bertipe T1, *T2, P.T3 dan *P.T4
struct {
	T1        // nama fieldnya yaitu T1
	*T2       // nama fieldnya yaitu T2
	P.T3      // nama fieldnya yaitu T3
	*P.T4     // nama field nya yaitu T4
	x, y int  // nama field nya yaitu x dan y
}
----

Deklarasi berikut ilegal karena nama field harus unik dalam sebuah tipe
struct:

----
struct {
	T     // konflik dengan field tertanam *T dan *P.T
	*T    // konflik dengan field tertanam T dan *P.T
	*P.T  // konflik dengan field tertanam T dan *T
}
----

Sebuah field atau
link:/ref/spec#Method_declarations[method]
`f` dari field tertanam dalam sebuah struct `x` disebut _dipromosikan_ jika
`x.f` adalah
link:/ref/spec#Selectors[selektor]
yang legal yang menandakan field atau method `f` tersebut.

Field yang dipromosikan berlaku seperti field biasa kecuali ia tidak bisa
digunakan sebagai nama field di dalam
link:/ref/spec#Composite_literals[literal komposit]
dari struct.

Diberikan sebuah tipe struct `S` dan
link:/ref/spec#Type_definitions[tipe terdefinisi] `T`,
method-method yang dipromosikan yang masuk ke dalam kumpulan method dari
struct `S` yaitu:

*  Jika `S` berisi field tertanam `T`,
   link:/ref/spec#Method_sets[kumpulan method]
   dari `S` dan `*S` mengikutkan method-method promosi dari `T`.
   Kumpulan method dari `*S` juga mengikutkan method promosi dari `*T`.

*  Jika `S` berisi field tertanam `T`, kumpulan method dari `S` dan `*S`
   keduanya mengikutkan method promosi dari `T` atau `*T`.

Deklarasi field bisa ditambah dengan literal string _tag_, yang menjadi
atribut dari field.
Tag kosong berarti tidak ada tag.
Tag bisa diakses lewat
link:/pkg/reflect/#StructTag[interface refleksi]
dan ambil bagian dalam
link:/ref/spec#Type_identity[identitas tipe]
dari struct.

----
struct {
	x, y float64 ""  // tag kosong sama dengan tanpa tag.
	name string  "string apa pun dibolehkan sebagai tag"
	_    [4]byte "ceci n'est pas un champ de structure"
}

// Sebuah struct untuk TimeStamp pada protocol buffer.
// String tag mendefinisikan field angka untuk protocol buffer;
// hal ini mengikuti konvensi yang dijelaskan oleh paket reflect.
struct {
	microsec  uint64 `protobuf:"1"`
	serverIP6 uint64 `protobuf:"2"`
}
----

[#Pointer_types]
===  Tipe pointer

Tipe pointer menandakan kumpulan semua pointer terhadap
link:/ref/spec#Variables[variabel]
dari tipe yang diberikan, disebut juga dengan _tipe dasar_ dari pointer.
Nilai dari pointer yang tidak diinisiasi adalah `nil`.

----
PointerType = "*" BaseType .
BaseType    = Type .
----

----
*Point
*[4]int
----


[#Function_types]
===  Tipe fungsi

Tipe fungsi menandakan kumpulan semua fungsi dengan tipe parameter dan
kembalian yang sama.
Nilai dari variabel bertipe fungsi yang tidak diinisiasi yaitu `nil`.

----
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
----

Dalam parameter atau kembalian, nama (IdentifierList) haruslah ada atau tidak
ada sama sekali.
Jika ada, setiap nama mengacu untuk satu item (parameter atau kembalian) dari
tipe dan semua nama haruslah
link:/ref/spec#Uniqueness_of_identifiers[unik].
Jika tanpa nama, setiap tipe merepresentasikan satu item untuk tipe tersebut.
Daftar parameter dan kembalian selalu dalam tanda kurung kecuali pada
kembalian tunggal tanpa nama, ia bisa ditulis tanpa tanda kurung.

Parameter terakhir dalam penanda fungsi bisa memiliki tipe yang dimulai dengan
"..." .
Fungsi dengan parameter tersebut disebut _variadic_ dan bisa dipanggil tanpa
atau lebih argumen dengan tipe yang sama.

----
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
----


[#Interface_types]
===  Tipe interface

Tipe interface menspesifikasikan
link:/ref/spec#Method_sets[sekumpulan method]
yang disebut dengan _interface_.
Sebuah variabel bertipe interface dapat menyimpan tipe apa pun asalkan
memiliki kumpulan method yang dimiliki oleh interface tersebut.
Tipe tersebut dikatakan _mengimplementasikan interface_.
Nilai dari variabel interface yang tidak diinisiasi adalah `nil`.

----
InterfaceType      = "interface" "{" { MethodSpec ";" } "}" .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
----

Dalam tipe interface, setiap method haruslah memiliki nama yang
link:/ref/spec#Uniqueness_of_identifiers[unik]
dan tidak-
link:/ref/spec#Blank_identifier[kosong].

----
// Sebuah interface berkas sederhana.
interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
	Close()
}
----

Satu atau lebih tipe yang berbeda dapat mengimplementasikan sebuah interface.
Misalnya, jika dua tipe `S1` dan `S2` memiliki sekumpulan method

----
func (p T) Read(b Buffer) bool { return … }
func (p T) Write(b Buffer) bool { return … }
func (p T) Close() { … }
----

(yang mana `T` bisa `S1` atau `S2`) maka interface `File` dikatakan
diimplementasikan oleh `S1` dan `S2`, walaupun `S1` dan `S2` bisa saja punya
method yang lain.

Sebuah tipe bisa mengimplementasikan satu atau lebih interface yang berbeda.
Misalnya, semua tipe mengimplementasikan _interface kosong_:

----
interface{}
----

Hal yang sama, pada spesifikasi interface berikut, yang muncul dalam
link:/ref/spec#Type_declarations[deklarasi tipe]
yang mendefinisikan sebuah interface bernama `Locker`:

----
type Locker interface {
	Lock()
	Unlock()
}
----

Jika `S1` dan `S2` juga mengimplementasikan

----
func (p T) Lock() { … }
func (p T) Unlock() { … }
----

maka mereka juga mengimplementasikan interface `Locker` dan juga interface
`File`.

Sebuah interface `T` bisa menanam tipe interface bernama `E`.
Hal ini disebut _penanaman_ interface `E` dalam `T`;
penanaman interface berarti menambahkan semua method (yang diekspor dan tidak
diekspor) dari `E` ke interface `T`.

----
type ReadWriter interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
}

type File interface {
	ReadWriter  // sama dengan menambahkan method-method dari ReadWriter
	Locker      // sama dengan menambahkan method-method dari Locker
	Close()
}

type LockedFile interface {
	Locker
	File        // ilegal: Lock, Unlock tidak unik
	Lock()      // ilegal: Lock tidak unik
}
----

Interface bertipe `T` tidak bisa secara rekursi menanam dirinya sendiri atau
interface lain yang menanam `T`.

----
// ilegal: Bad tidak bisa menanam dirinya sendiri
type Bad interface {
	Bad
}

// ilegal: Bad1 tidak bisa menanam dirinya sendiri menggunakan Bad2
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
----

[#Map_types]
===  Tipe map

Sebuah map adalah gabungan tak urut dari elemen dari satu tipe, yang
disebut tipe elemen, yang memiliki indeks berupa sekumpulan _key_ unik dari
tipe lainnya, disebut tipe key.
Nilai dari map yang tidak diinisiasi yaitu `nil`.

----
MapType     = "map" "[" KeyType "]" ElementType .
KeyType     = Type .
----

link:/ref/spec#Comparison_operators[Operator pembanding] `==`
dan `!=` haruslah terdefinisi untuk operan dari tipe key;
oleh karena itu tipe key tidak bisa berupa fungsi, map, atau slice.
Jika tipe key adalah sebuah tipe interface, maka operator pembanding harus
terdefinisi untuk nilai key dinamis;
jika tidak akan menyebabkan
link:/ref/spec#Run_time_panics[run-time panic].

----
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}
----

Jumlah elemen map disebut panjang.
Untuk map `m`, jumlahnya bisa diambil dengan fungsi bawaan
link:/ref/spec#Length_and_capacity[len]
dan ia bisa berubah selama eksekusi.
Elemen bisa ditambah selama eksekusi menggunakan
link:/ref/spec#Assignments[penempatan]
dan diambil dengan
link:/ref/spec#Index_expressions[ekspresi indeks];
dan elemen bisa dihapus dengan fungsi bawaan
link:/ref/spec#Deletion_of_map_elements[delete].

Nilai map yang baru dan kosong dibuat dengan fungsi bawaan
link:/ref/spec#Making_slices_maps_and_channels[make],
yang menerima tipe map dan kapasitas opsional sebagai argumen:

----
make(map[string]int)
make(map[string]int, 100)
----

Kapasitas awal tidak ada batas ukurannya: map berkembang untuk mengakomodasi
sejumlah item yang disimpannya, kecuali pada map yang `nil`.
Map yang `nil` sama dengan map kosong kecuali ia tidak bisa ditambahkan dengan
elemen.


[#Channel_types]
===  Tipe channel

Sebuah channel menyediakan sebuah mekanisme untuk
link:/ref/spec#Go_statements[mengeksekusi fungsi secara konkuren]
untuk berkomunikasi dengan
link:/ref/spec#Send_statements[mengirim]
dan
link:/ref/spec#Receive_operator[menerima]
nilai dari tipe elemen yang ditentukan.
Nilai dari channel yang tidak diinisiasi yaitu `nil`.

----
ChannelType = ( "chan" | "chan" "<-" | "<-" "chan" ) ElementType .
----

Operator opsional `<-` menspesifikasikan _arah_ channel, _kirim_ atau
_terima_.
Jika tidak ada arah yang diberikan, maka channel adalah _bidirectional_ (dua
arah).
Sebuah channel bisa dibatasi hanya untuk mengirim atau menerima saja dengan
link:/ref/spec#Assignments[penempatan]
atau
link:/ref/spec#Conversions[konversi]
eksplisit.

----
chan T          // bisa digunakan untuk mengirim dan menerima nilai bertipe T
chan<- float64  // hanya bisa digunakan mengirim float64
<-chan int      // hanya bisa menerima int
----

Operator `<-` berhubungan dengan `chan` yang paling kiri:

----
chan<- chan int    // sama dengan chan<- (chan int)
chan<- <-chan int  // sama dengan chan<- (<-chan int)
<-chan <-chan int  // sama dengan <-chan (<-chan int)
chan (<-chan int)
----

Inisiasi nilai channel yang baru bisa dibuat dengan fungsi bawaan
link:/ref/spec#Making_slices_maps_and_channels[make]
yang menerima tipe channel dan _kapasitas_ opsional sebagai argumen:

----
make(chan int, 100)
----

Kapasitas, atau jumlah elemen, mengatur ukuran _buffer_ dalam channel.
Jika kapasitasnya kosong atau tidak ada, channel adalah tanpa _buffer_ dan
komunikasi akan sukses saat pengirim dan penerima telah siap.
Sebaliknya, bila kapasitas tidak kosong, maka channel adalah ber-_buffer_
dan komunikasi akan sukses tanpa ditahan jika _buffer_ tidak penuh (mengirim)
atau tidak kosong (menerima).
Channel yang `nil` tidak akan pernah bisa berkomunikasi.

Channel bisa ditutup dengan fungsi bawaan
link:/ref/spec#Close[close].
Bentuk penempatan banyak-nilai dari
link:/ref/spec#Receive_operator[operator penerima]
melaporkan apakah nilai yang diterima dikirim sebelum channel ditutup.

Sebuah channel bisa digunakan untuk
link:/ref/spec#Send_statements[mengirim],
link:/ref/spec#Receive_operator[menerima],
dan memanggil fungsi bawaan
link:/ref/spec#Length_and_capacity[cap]
dan
link:/ref/spec#Length_and_capacity[len]
oleh sejumlah goroutine berbeda tanpa perlu sinkronisasi.
Channel bersifat antrean first-in-first-out (yang pertama masuk, yang pertama
keluar).
Misalnya, jika sebuah goroutine mengirim nilai ke channel dan goroutine kedua
menerimanya, nilai diterima sesuai urutan yang dikirim.


[#Properties_of_types_and_values]
==  Properti dari tipe dan nilai


[#Type_identity]
===  Identitas tipe

Dua buah tipe akan _identik_ atau _berbeda_.

link:/ref/spec#Type_definitions[Tipe terdefinisi]
selalu berbeda dengan tipe lainnya.
Sebaliknya, dua tipe adalah identik jika tipe
link:/ref/spec#Types[dasar]
mereka secara struktural sama;
yaitu, memiliki struktur literal yang sama dan komponen yang
berhubungan memiliki tipe yang sama.
Secara lebih rinci:

*  Dua tipe array adalah identik jika mereka punya tipe elemen dan panjang
   yang sama.
*  Dua tipe slice adalah identik jika mereka punya tipe elemen yang sama.
*  Dua tipe struct adalah identik jika mereka memiliki urutan field yang sama,
   dan jika field-field tersebut memiliki nama. tipe, dan tag yang sama.
   Nama field yang
   link:/ref/spec#Exported_identifiers[tidak diekspor]
   dari paket yang berbeda selalu menghasilkan tipe struct yang tidak identik.
*  Dua tipe pointer adalah identik jika mereka memiliki tipe dasar yang sama.
*  Dua tipe fungsi adalah identik jika mereka memiliki jumlah parameter dan
   kembalian yang sama, dengan tipe parameter dan kembalian yang sama, dan
   bila kedua fungsi adalah _variadic_ atau tidak sama sekali.
   Nama pada parameter dan kembalian tidak harus sama.
*  Dua tipe interface adalah identik jika mereka memiliki kumpulan method
   dengan nama yang sama dan tipe fungsi yang sama.
   Nama method yang
   link:/ref/spec#Exported_identifiers[tidak diekspor]
   dari paket yang berbeda akan selalu menghasilkan tipe yang tidak identik.
   Urutan dari method tidak berpengaruh.
*  Dua tipe map adalah identik jika mereka memiliki tipe key dan elemen yang
   sama.
*  Dua tipe channel adalah identik jika mereka memiliki tipe elemen dan arah
   yang sama.

Diberikan deklarasi berikut,

----
type (
	A0 = []string
	A1 = A0
	A2 = struct{ a, b int }
	A3 = int
	A4 = func(A3, float64) *A0
	A5 = func(x int, _ float64) *[]string
)

type (
	B0 A0
	B1 []string
	B2 struct{ a, b int }
	B3 struct{ a, c int }
	B4 func(int, float64) *B0
	B5 func(x int, y float64) *A1
)

type	C0 = B0
----

tipe-tipe berikut adalah identik:

----
A0, A1, dan []string
A2 dan struct{ a, b int }
A3 dan int
A4, func(int, float64) *[]string, dan A5

B0 dan C0
[]int dan []int
struct{ a, b *T5 } dan struct{ a, b *T5 }
func(x int, y float64) *[]string, func(int, float64) (result *[]string), dan A5
----

`B0` dan `B1` berbeda karena mereka adalah tipe baru yang dibuat dengan
link:/ref/spec#Type_definitions[definisi tipe]
yang berbeda;
`func(int, float64) *B0` dan `func(x int, y float64) *[]string`
adalah berbeda karena `B0` berbeda dari `[]string`.


[#Assignability]
===  _Assignability_ (Penempatan)

Sebuah nilai `x` bisa _ditempatkan_ ke sebuah
link:/ref/spec#Variables[variabel]
bertipe `T` ("x bisa diisi ke T") jika salah satu kondisi berikut berlaku:

*  tipe x identik dengan `T`.
*  tipe x yaitu `V`, `V` dan `T` memiliki
   link:/ref/spec#Types[tipe dasar]
   yang sama dan paling tidak salah satu dari `V` atau `T` bukanlah
   tipe
   link:/ref/spec#Type_definitions[tipe terdefinisi].
*  `T` adalah tipe interface dan `x`
   link:/ref/spec#Interface_types[mengimplementasikan]
   `T`
*  `x` adalah nilai channel dua arah, `T` bertipe channel, bila tipe `x` dari
   yaitu `V` dan `T` memiliki tipe elemen yang sama, dan paling tidak salah
   satu dari `V` atau `T` bukanlah tipe terdefinisi.
*  `x` adalah `nil` dan `T` bertipe pointer, fungsi, slice, map, channel, atau
   interface.
*  `x` adalah sebuah
   link:/ref/spec#Constants[konstan]
   link:/ref/spec#Representability[direpresentasikan]
   dengan nilai bertipe `T`.


[#Representability]
===  _Representability_

Sebuah
link:/ref/spec#Constants[konstan]
`x` bisa direpresentasikan oleh sebuah nilai bertipe `T` jika salah satu
kondisi berikut berlaku:

*  `x` ada dalam kumpulan nilai
   link:/ref/spec#Types[yang ditentukan]
   oleh `T`.
*  `T` bertipe _floating-point_ dan `x` bisa dibulatkan ke presisi `T` tanpa
   _overflow_.
   Pembulatan menggunakan aturan pembulatan-genap dari IEEE 754 namun dengan
   IEEE nol negatif disederhanakan menjadi unsigned nol.
   Ingatlah bahwa nilai konstan tidak pernah menghasilkan IEEE nol negatif,
   NaN, atau tanpa batas.
*  `T` bertipe complex, dan
   link:/ref/spec#Complex_numbers[komponen] x `real(x)` dan `imag(x)` bisa
   direpresentasikan oleh nilai tipe komponen dari `T` (`float32` atau
   `float64`).

----
x                   T           x bisa direpresentasikan oleh nilai T karena

'a'                 byte        97 ada dalam kumpulan nilai byte
97                  rune        rune adalah alias untuk int32, dan 97 ada dalam kumpulan integer 32-bit
"foo"               string      "foo" ada dalam kumpulan nilai string
1024                int16       1024 ada dalam kumpulan integer 16-bit
42.0                byte        42 ada dalam kumpulan unsigned integer 8-bit
1e10                uint64      10000000000 ada dalam kumpulan unsigned integer 64-bit
2.718281828459045   float32     2.718281828459045 dibulatkan ke 2.7182817 yang ada dalam kumpulan nilai float32
-1e-1000            float64     -1e-1000 dibulatkan ke IEEE -0.0 yang kemudian disederhanakan menjadi 0.0
0i                  int         0 adalah nilai integer
(42 + 0i)           float32     42.0 (dengan bagian imajiner nol) ada dalam kumpulan nilai float32
----

----
x                   T           x tidak direpresentasikan oleh nilai T karena

0                   bool        0 tidak ada dalam kumpulan nilai boolean
'a'                 string      'a' adalah rune, ia tidak ada dalam kumpulan nilai string
1024                byte        1024 bukan berada dalam kumpulan unsigned integer 8-bit
-1                  uint16      -1 bukan berada dalam kumpulan unsigned integer 16-bit
1.1                 int         1.1 bukanlah nilai integer
42i                 float32     (0 + 42i) bukan berada dalam kumpulan nilai float32
1e1000              float64     1e1000 menjadi overflow ke IEEE +Inf setelah pembulatan
----


[#Blocks]
==  Blok

Sebuah blok yaitu seurutan deklarasi dan perintah, yang bisa saja kosong, di
antara tanda kurung kurawal.

----
Block = "{" StatementList "}" .
StatementList = { Statement ";" } .
----

Selain blok eksplisit dalam kode, ada beberapa blok implisit:

.  _blok universal_ melingkupi semua teks kode Go
.  Setiap
   link:/ref/spec#Packages[paket]
   memiliki sebuah _blok paket_ yang berisi semua teks sumber kode Go untuk
   paket tersebut
.  Setiap berkas memiliki sebuah _blok berkas_ berisi teks sumber kode Go
   dalam berkas tersebut
.  Setiap perintah
   link:/ref/spec#If_statements["if"],
   link:/ref/spec#For_statements["for"], dan
   link:/ref/spec#Switch_statements["switch"]
   dianggap berada dalam blok implisit-nya sendiri.
.  Setiap "case" di dalam perintah
   link:/ref/spec#Switch_statements["switch"]
   atau
   link:/ref/spec#Select_statements["select"]
   bersifat sebagai blok implisit.

Sekumpulan blok yang bersarang mempengaruhi
link:/ref/spec#Declarations_and_scope[skop].


[#Declarations_and_scope]
==  Deklarasi dan skop

Sebuah _deklarasi_ mengikat pengidentifikasi yang tidak
link:/ref/spec#Blank_identifier[kosong]
terhadap sebuah
link:/ref/spec#Constant_declarations[konstan],
link:/ref/spec#Type_declarations[tipe],
link:/ref/spec#Variable_declarations[variabel],
link:/ref/spec#Function_declarations[fungsi],
link:/ref/spec#Labeled_statements[label], atau
link:/ref/spec#Import_declarations[paket].
Setiap identifikasi dalam sebuah program haruslah dideklarasikan.
Tidak ada pengidentifikasi yang bisa dideklarasikan dua kali dalam blok yang
sama, dan tidak ada pengidentifikasi bisa dideklarasikan dalam blok berkas dan
paket.

link:/ref/spec#Blank_identifier[Pengidentifikasi kosong]
bisa digunakan seperti pengidentifikasi lainnya dalam sebuah deklarasi, namun
tidak mengakibatkan pengikatan sehingga tidak dideklarasi.
Dalam blok paket, pengidentifikasi `init` hanya bisa digunakan untuk deklarasi
link:/ref/spec#Package_initialization[fungsi `init`],
dan seperti pengidentifikasi kosong ia tidak menghasilkan pengikatan yang
baru.

----
Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
----

_Ruang lingkup_ dari sebuah deklarasi pengidentifikasi yaitu betas dari teks
sumber kode di mana pengidentifikasi menyatakan konstan, tipe, variabel,
fungsi, label, atau paket yang ditentukan.

Go secara leksikal dibatasi menggunakan
link:/ref/spec#Blocks[blok-blok]:

1.  Skop dari
    link:/ref/spec#Predeclared_identifiers[pengidentifikasi pra-deklarasi]
    yaitu blok universal.
2.  Skop dari pengidentifikasi yang menyatakan sebuah konstan, tipe, variabel,
    atau fungsi (tetapi tidak method) yang dideklarasikan pada bagian atas
    (di luar fungsi apa pun) adalah blok paket.
3.  Skop dari nama paket yang diimpor yaitu blok berkas yang berisi deklarasi
    impor.
4.  Skop dari pengidentifikasi yang menyatakan penerima method, parameter
    fungsi, atau variabel kembalian yaitu badan dari fungsi.
5.  Skop dari konstan atau variabel yang dideklarasikan dalam fungsi dimulai
    dari ConstSpec atau VarSpec (ShortVarDecl untuk deklarasi variabel
    singkat) dan berakhir pada blok yang mengandungnya.
6.  Skop dari pengidentifikasi tipe yang dideklarasikan dalam sebuah fungsi
    dimulai dari pengidentifikasi dalam TypeSpec dan berakhir pada blok yang
    mengandungnya.

Pengidentifikasi yang dideklarasikan dalam sebuah blok bisa dideklarasikan
kembali di dalam blok sebelah dalam.
Saat pengidentifikasi dari deklarasi di dalam skop, ia menyatakan entitas yang
dideklarasikan oleh deklarasi di dalamnya.

link:/ref/spec#Package_clause[Klausa paket] bukanlah sebuah deklarasi;
nama paket tidak muncul dalam skop manapun.
Tujuan klausa paket yaitu untuk mengidentifikasi berkas berada dalam
link:/ref/spec#Packages[paket]
yang sama dan untuk menentukan nama paket untuk deklarasi impor.


[#Label_scopes]
===  Skop label

Label dideklarasikan oleh
link:/ref/spec#Labeled_statements[perintah label]
dan digunakan dalam perintah
link:/ref/spec#Break_statements["break"],
link:/ref/spec#Continue_statements["continue"],
dan
link:/ref/spec#Goto_statements["goto"].
Adalah ilegal mendefinisikan sebuah label yang tidak pernah digunakan.
Berbeda dengan pengidentifikasi lainnya, label tidaklah dibatasi oleh skip dan
tidak konflik dengan pengidentifikasi yang bukan label.
Skop dari label yaitu badan dari fungsi di mana ia dideklarasikan dan tidak
mengikutkan badan dari fungsi yang bersarang.


[#Blank_identifier]
===  Pengidentifikasi kosong

_Pengidentifikasi kosong_ direpresentasikan oleh karakter garis bawah `_`.
Ia berfungsi sebagai penampung anonim bukan sebagai pengidentifikasi biasa
(yang bukan kosong) dan memiliki arti khusus dalam
link:/ref/spec#Declarations_and_scope[deklarasi],
seperti sebuah
link:/ref/spec#Operands[operan],
dan dalam
link:/ref/spec#Assignments[penempatan].


[#Predeclared_identifiers]
===  Pengidentifikasi pradeklarasi

Pengidentifikasi berikut secara implisit dideklarasikan dalam
link:/ref/spec#Blocks[blok universal]:

----
Tipe:
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

Konstan:
	true false iota

Nilai kosong:
	nil

Fungsi:
	append cap close complex copy delete imag len
	make new panic print println real recover
----


[#Exported_identifiers]
===  Pengidentifikasi yang diekspor

Sebuah pengidentifikasi bisa _diekspor_ untuk membolehkan akses kepadanya dari
paket lainnya.
Pengidentifikasi diekspor jika:

1.  Karakter pertama dari nama pengidentifikasi adalah huruf besar Unicode
    (kelas Unicode "Lu"); dan
2.  Pengidentifikasi dideklarasikan dalam
    link:/ref/spec#Blocks[blok paket]
    atau ia merupakan
    link:/ref/spec#Struct_types[nama field]
    atau
    link:/ref/spec#MethodName[nama method].

Pengidentifikasi lainnya tidak diekspor.


[#Uniqueness_of_identifiers]
===  Keunikan pengidentifikasi

Diberikan sekumpulan pengidentifikasi, sebuah pengidentifikasi dikatakan
_unik_ jika ia _berbeda_ dari yang lainnya dalam kumpulan tersebut.
Dua pengidentifikasi adalah berbeda jika mereka dieja secara berbeda, atau
jika mereka muncul di
link:/ref/spec#Packages[paket]
yang berbeda dan tidak
link:/ref/spec#Exported_identifiers[diekspor].
Selain itu, mereka adalah pengidentifikasi yang sama.


[#Constant_declarations]
===  Deklarasi konstan

Deklarasi konstan mengikat sejumlah pengidentifikasi (nama-nama dari konstan)
terhadap nilai dari daftar dari
link:/ref/spec#Constant_expressions[ekspresi konstan].
Jumlah pengidentifikasi harus sama dengan jumlah ekspresi, dan
pengidentifikasi ke-_n_ di bagian kiri terikat ke nilai dari ekspresi ke-_n_
di bagian kanan.

----
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .
----

Jika tipe didefinisikan, semua konstan memakai tipe tersebut, dan ekspresi
nilai haruslah
link:/ref/spec#Assignability[dapat di-assign]
ke tipe tersebut.
Jika tipe diindahkan, maka konstan memiliki tipe berdasarkan ekspresi.
Jika nilai ekspresi adalah
link:/ref/spec#Constants[konstan]
tanpa tipe, maka konstan tetap tanpa tipe dan pengidentifikasi konstan
menyatakan nilai konstan.
Misalnya, jika ekspresi adalah abjad _floating-point_, pengidentifikasi
konstan menyatakan sebuah konstan _floating-point_, bahkan bila bagian pecahan
adalah nol.

----
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // konstan floating-point tanpa tipe
const (
	size int64 = 1024
	eof        = -1  // konstan integer tanpa tipe
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", konstan integer dan
string tanpa tipe
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
----

Dalam deklarasi `const` dengan tanda kurung, daftar ekspresi bisa diindahkan
kecuali ConstSpec yang pertama.
Daftar kosong seperti ini sama saja dengan penggantian tekstual dari daftar
ekspresi pertama yang tidak kosong dan tipenya jika ada.
Mengindahkan daftar ekspresi maka sama saja dengan mengulang daftar
sebelumnya.
Jumlah pengidentifikasi harus sama dengan jumlah ekspresi pada daftar
sebelumnya.
Bersama dengan
link:/ref/spec#Iota[`iota` konstan generator]
mekanisme ini membolehkan deklarasi ringan dari nilai berurutan:

----
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // this constant is not exported
)
----

[#Iota]
===  Iota

Di dalam sebuah
link:/ref/spec#Constant_declarations[deklarasi konstan],
pengidentifikasi `iota` merepresentasikan
link:/ref/spec#Constants[konstan]
integer tanpa-tipe beriringan.
Nilainya yaitu indeks dari
link:/ref/spec#ConstSpec[ConstSpec]
dalam deklarasi konstan tersebut, dimulai dari nol.
Ia bisa digunakan untuk membentuk sekumpulan konstan yang berhubungan:

----
const (
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 << iota  // a == 1  (iota == 0)
	b = 1 << iota  // b == 2  (iota == 1)
	c = 3          // c == 3  (iota == 2, tidak terpakai)
	d = 1 << iota  // d == 8  (iota == 3)
)

const (
	u         = iota * 42  // u == 0     (konstan integer tanpa tipe)
	v float64 = iota * 42  // v == 42.0  (konstan float64)
	w         = iota * 42  // w == 84    (konstan integer tanpa tipe)
)

const x = iota  // x == 0
const y = iota  // y == 0
----

Secara definisi, penggunaan `iota` berulang kali di dalam ConstSpec yang sama
memiliki nilai yang sama:

----
const (
	bit0, mask0 = 1 << iota, 1<<iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)
	bit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)
	_, _                                  //                        (iota == 2, tak terpakai)
	bit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3)
)
----

Contoh terakhir menggunakan
link:/ref/spec#Constant_declarations[pengulangan implisit]
dari daftar ekspresi yang tidak kosong.


[#Type_declarations]
===  Deklarasi tipe

Sebuah deklarasi tipe mengikat pengidentifikasi, _name tipe_, ke sebuah
link:/ref/spec#Types[tipe]
Deklarasi tipe ada dua bentuk: deklarasi alias dan definisi tipe.

----
TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec = AliasDecl | TypeDef .
----

====  Deklarasi alias

Deklarasi alias mengikat pengidentifikasi ke tipe yang diberikan.

----
AliasDecl = identifier "=" Type .
----

Dalam
link:/ref/spec#Declarations_and_scope[skop]
pengidentifikasi, ia berfungsi sebagai _alias_ dari tipe.

----
type (
	nodeList = []*Node  // nodeList dan []*Node adalah tipe yang identik
	Polar    = polar    // Polar dan polar menyatakan tipe yang identik
)
----

====  Definisi tipe

Sebuah definisi tipe membuat tipe yang baru dan berbeda dengan
link:/ref/spec#Types[tipe dasar]
dan operasi yang sama dengan tipe yang diberikan, dan mengikat
pengidentifikasi padanya.

----
TypeDef = identifier Type .
----

Tipe yang baru disebut _tipe terdefinisi_.
Ia
link:/ref/spec#Type_identity[berbeda]
dengan tipe lainnya, termasuk dari tipe yang membentuknya.

----
type (
	Point struct{ x, y float64 }  // Point dan struct{ x, y float64 }
	                              // adalah tipe yang berbeda.
	polar Point                   // polar dan Point menyatakan tipe yang
	                              // berbeda.
)

type TreeNode struct {
	left, right *TreeNode
	value *Comparable
}

type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
----

Tipe terdefinisi bisa memiliki
link:/ref/spec#Method_declarations[method]
yang berasosiasi dengannya.
Ia tidak mewariskan method apa pun dari tipe yang diikat, namun
link:/ref/spec#Method_sets[kumpulan method]
dari tipe interface atau elemen dari tipe komposit tidak berubah:

----
// Mutex adalah tipe data dengan dua method, Lock dan Unlock.
type Mutex struct         { /* field dari Mutex */ }
func (m *Mutex) Lock()    { /* implementasi Lock */ }
func (m *Mutex) Unlock()  { /* implementasi Unlock */ }

// NewMutex memiliki komposisi yang sama dengan Mutex namun set method-nya
// kosong.
type NewMutex Mutex

// Kumpulan method dari tipe dasar PtrMutex yaitu *Mutex tetap tidak berubah,
// namun kumpulan method dari PtrMutex adalah kosong.
type PtrMutex *Mutex

// Kumpulan method dari *PrintableMutex berisi method Lock dan Unlock terikat
// dari field tertanamnya Mutex.
type PrintableMutex struct {
	Mutex
}

// MyBlock yaitu tipe interface yang memiliki kumpulan method yang sama dengan
// Block.
type MyBlock Block
----

Definisi tipe bisa digunakan untuk mendefinisikan tipe boolean, numerik, atau
string yang berbeda dan mengasosiasikan method dengan tipe tersebut:

----
type TimeZone int

const (
	EST TimeZone = -(5 + iota)
	CST
	MST
	PST
)

func (tz TimeZone) String() string {
	return fmt.Sprintf("GMT%+dh", tz)
}
----


[#Variable_declarations]
===  Deklarasi variabel

Deklarasi variabel membuat satu atau lebih
link:/ref/spec#Variables[variabel],
mengikat pengidentifikasi yang berkorespondensi kepadanya, dan memberikan
setiap tiap-tiapnya sebuah tipe dan nilai awal.

----
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
----

----
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // pencarian map; hanya tertarik pada "found"
----

Jika sebuah daftar ekspresi diberikan, maka variabel diinisiasi dengan
ekspresi mengikuti aturan-aturan
link:/ref/spec#Assignments[penempatan].
Selain itu, setiap variabel diinisiasi dengan
link:/ref/spec#The_zero_value[nilai kosong]
nya.

Jika sebuah tipe diberikan, setiap variabel diberikan tipe tersebut.
Selain itu, setiap variabel diberikan tipe dari nilai inisiasi pada
penempatan.
Jika nilai tersebut sebuah konstan tak bertipe, maka pertama kali ia secara
implisit
link:/ref/spec#Conversions[dikonversi]
ke
link:/ref/spec#Constants[tipe defaultnya];
misalnya, jika variabel adalah nilai boolean tanpa tipe, maka ia secara
implisit dikonversi ke tipe `bool`.
Nilai `nil` tidak bisa digunakan untuk menginisiasi sebuah variabel tanpa tipe
eksplisit.

----
var d = math.Sin(0.5)  // d adalah float64
var i = 42             // i adalah int
var t, ok = x.(T)      // t adalah T, ok adalah bool
var n = nil            // ilegal
----

Batasan implementasi: _Compiler_ bisa mengilegalkan deklarasi variabel di
dalam
link:/ref/spec#Function_declarations[badan fungsi]
jika variabel tersebut tidak pernah digunakan.


[##Short_variable_declarations]
===  Deklarasi variabel singkat

_Deklarasi variabel singkat_ menggunakan sintaks:

----
ShortVarDecl = IdentifierList ":=" ExpressionList .
----

Ia merupakan cara cepat
link:/ref/spec#Variable_declarations[mendeklarasikan variabel]
dengan ekspresi inisiasi tanpa tipe:

----
"var" IdentifierList = ExpressionList .
----

----
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w, _ := os.Pipe()  // os.Pipe() mengembalikan pasangan File dan error
_, y, _ := coord(p)   // coord() mengembalikan tiga nilai; yang diambil hanya koordinat y
----

Tidak seperti deklarasi variabel, deklarasi variabel singkat bisa
_mendeklarasi ulang_ variabel setelah ia dideklarasikan sebelumnya di dalam
blok yang sama (atau dari daftar parameter jika blok adalah badan fungsi)
dengan tipe yang sama, dan paling tidak salah satu dari variabel yang tidak
link:/ref/spec#Blank_identifier[kosong]
adalah variabel baru.
Akibatnya, deklarasi ulang hanya dapat muncul dalam sebuah deklarasi singkat
multi-variabel.
Deklarasi ulang tidak menyebabkan munculnya variabel baru; ia hanya
menempatkan nilai baru ke variabel aslinya.

----
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // deklarasi ulang pada offset
a, a := 1, 2                              // ilegal: deklarasi ganda dari a
                                          // atau tidak ada variabel baru bila
					  // a dideklarasikan sebelumnya.
----

Deklarasi variabel singkat hanya bisa muncul dalam fungsi.
Dalam beberapa konteks seperti inisiasi untuk perintah
link:/ref/spec#If_statements["if"],
link:/ref/spec#For_statements["for"], atau
link:/ref/spec#Switch_statements["switch"],
mereka dapat digunakan untuk mendeklarasikan variabel lokal sementara.


[#Function_declarations]
===  Deklarasi fungsi

Deklarasi fungsi mengikat pengidentifikasi, _nama fungsi_, ke sebuah fungsi.

----
FunctionDecl = "func" FunctionName Signature [ FunctionBody ] .
FunctionName = identifier .
FunctionBody = Block .
----

Jika
link:/ref/spec#Function_types[fungsi]
mengembalikan nilai, daftar perintah pada badan fungsi harus berakhir dengan
link:/ref/spec#Terminating_statements[perintah terminasi].

----
func IndexRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	// tidak valid: perintah return tidak ada.
}
----

Deklarasi fungsi bisa tanpa badan.
Deklarasi seperti ini menyediakan _signature_ untuk sebuah fungsi yang
diimplementasikan di luar Go, seperti rutin _assembly_.

----
func min(x int, y int) int {
	if x < y {
		return x
	}
	return y
}

func flushICache(begin, end uintptr)  // diimplementasikan di luar.
----


[#Method_declarations]
===  Deklarasi method

Sebuah method yaitu sebuah
link:/ref/spec#Function_declarations[fungsi]
dengan sebuah _receiver_ (penerima).
Deklarasi method mengikat pengidentifikasi, _nama method_, terhadap sebuah
method, dan mengasosiasikan method tersebut dengan _tipe dasar_ _receiver_.

----
MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .
Receiver   = Parameters .
----

Si _receiver_ dispesifikasikan lewat bagian parameter sebelum nama method.
Bagian parameter tersebut harus mendeklarasikan sebuah parameter tunggal, yang
disebut juga dengan _receiver_.
Tipe _receiver_ haruslah tipe
link:/ref/spec#Type_definitions[terdefinisi]
`T` atau sebuah pointer ke tipe terdefinisi `T`.
`T` disebut juga _tipe dasar receiver_.
Tipe dasar _receiver_ tidak bisa berupa tipe pointer atau interface dan ia
harus didefinisikan di dalam paket yang sama dengan method.
Method tersebut dikatakan _terikat_ dengan tipe dasar _receiver_ dan nama
method hanya dapat dipanggil oleh
link:/ref/spec#Selectors[selector]
untuk tipe `T` atau `*T`.

Pengidentifikasi _receiver_ haruslah
link:/ref/spec#Uniqueness_of_identifiers[unik]
dalam penanda method.
Jika nilai _receiver_ tidak dipakai di dalam badan method, maka
pengidentifikasinya bisa dihilangkan dalam deklarasi.
Hal yang sama berlaku secara umum terhadap parameter dari fungsi dan method.

Untuk tipe dasar yang sama, nama-nama dari method haruslah unik.
Jika tipe dasar adalah sebuah
link:/ref/spec#Struct_types[tipe struct],
nama method dan field haruslah berbeda.

Diberikan sebuah tipe `Point`, deklarasi berikut

----
func (p *Point) Length() float64 {
	return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
	p.x *= factor
	p.y *= factor
}
----

mengikat method `Length()` dan `Scale()`, dengan _receiver_ bertipe `*Point`,
terhadap tipe dasar `Point`.

Tipe dari sebuah method yaitu tipe dari fungsi dengan _receiver_ sebagai
argumen yang pertama.
Misalnya, method `Scale()` bertipe

----
func(p *Point, factor float64)
----

Namun, fungsi yang dideklarasikan seperti di atas bukanlah sebuah method.


[#Expressions]
==  Ekspresi

Sebuah ekspresi menentukan komputasi dari sebuah nilai dengan menerapkan
operator dan fungsi terhadap operan.


#Operands
===  Operan-operan

Operan menyatakan nilai elementer dalam sebuah ekspresi.
Sebuah operan bisa jadi abjad, sebuah pengindentifikasi bukan-
link:/ref/spec#Blank_identifier[kosong] (bisa saja
/ref/spec#Qualified_identifiers[terbatas])
yang menyatakan sebuah
link:/ref/spec#Constant_declarations[konstan],
link:/ref/spec#Variable_declarations[variabel],
atau
link:/ref/spec#Function_declarations[fungsi],
atau ekspresi dalam tanda kurung.

http://127.0.0.1:6060/ref/spec#Blank_identifier[Pengidentifikasi kosong]
bisa muncul sebaga operan hanya pada bagian kiri dari sebuah
http://127.0.0.1:6060/ref/spec#Assignments[penempatan].

----
Operand     = Literal | OperandName | "(" Expression ")" .
Literal     = BasicLit | CompositeLit | FunctionLit .
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
OperandName = identifier | QualifiedIdent.
----


[#Qualified_identifiers]
===  Pengidentifikasi terbatas

Sebuah pengidentifikasi terbatas yaitu sebuah pengidentifikasi yang dibatasi
oleh awalan nama paket.
Nama paket dan pengidentifikasi haruslah tidak
http://127.0.0.1:6060/ref/spec#Blank_identifier[kosong].

----
QualifiedIdent = PackageName "." identifier .
----

Pengidentifikasi terbatas mengakses pengidentifikasi di paket yang berbeda,
yang harus
http://127.0.0.1:6060/ref/spec#Import_declarations[diimpor].
Si pengidentifikasi haruslah
http://127.0.0.1:6060/ref/spec#Exported_identifiers[diekspor]
dan dideklarasikan dalam
http://127.0.0.1:6060/ref/spec#Blocks[blok paket]
dari paket tersebut.

----
math.Sin	// menyatakan fungsi Sin dalam paket math.
----

[#Composite_literals]
===  Abjad komposit

Abjad komposit membentuk nilai-nilai untuk struct, array, slice, dan map; dan
membuat sebuah nilai baru setiap kali ia dievaluasi.
Ia dibentuk dari tipe dari abjad diikuti oleh daftar elemen yang dibatasi oleh
kurung kurawal.
Setiap elemen bisa diawali dengan kunci yang berkorespondensi.

----
CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName .
LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
ElementList   = KeyedElement { "," KeyedElement } .
KeyedElement  = [ Key ":" ] Element .
Key           = FieldName | Expression | LiteralValue .
FieldName     = identifier .
Element       = Expression | LiteralValue .
----

Tipe dasar dari LiteralType haruslah sebuah tipe struct, array, slice, atau
map (gramatika memaksa batasan ini kecuali bisa tipe diberikan sebagai sebuah
TypeName).
Tipe dari elemen dan kunci harus bisa
http://127.0.0.1:6060/ref/spec#Assignability[ditempatkan]
ke tipe field, elemen, dan kunci dari tipe abjad yang bersangkutan;
tidak ada konversi tambahan.
Kunci diinterpretasikan sebagai sebuah nama field untuk abjad struct, sebuah
indeks pada abjad array dan slice, dan sebuah kunci untuk abjad map.
Untuk abjad map, semua elemen harus memiliki sebuah kunci.
Adalah sebuah kesalahan bila menspesifikasikan beragam lemen dengan nama field
yang sama atau nilai key menggunakan konstan.
Untuk kunci map yang tidak-konstan, lihat bagian pada
http://127.0.0.1:6060/ref/spec#Order_of_evaluation[urutan evaluasi].

Untuk abjad struct aturan-aturan berikut berlaku:

*  Sebuah kunci haruslah nama field yang dideklarasikan dalam tipe struct.
*  Daftar elemen yang tidak memiliki kunci haruslah mendaftarkan setiap elemen
   pada field struct dengan urutan sebagaimana ia dideklarasikan.
*  Jika elemen memiliki key, maka semua elemen haruslah memiliki key.
*  Daftar elemen yang mengandung kunci tidak harus memiliki elemen untuk
   setiap field struct.
   Field yang diindahkan akan mendapatkan nilai kosong untuk field tersebut.
*  Abjad bisa mengindahkan daftar elemen; abjad tersebut dievaluasi menjadi
   nilai kosong untuk tipenya.
*  Adalah sebuah kesalahan bila menspesifikasikan sebuah elemen untuk field
   yang tidak diekspor dari sebuah struct yang dimiliki oleh paket yang
   berbeda.

Diberikan deklarasi berikut

----
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
----

kita bisa menulis

----
origin := Point3D{}                            // nilai kosong untuk Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // nilai kosong untuk line.q.x
----

Untuk array dan slice, aturan-aturan berikut berlaku:

*  Setiap elemen memiliki indeks integer yang menandakan posisinya dalam
   array.
*  Sebuah elemen dengan sebuah kunci menggunakan kunci tersebut sebagai
   indeksnya.
   Kunci tersebut haruslah konstan bukan-negatif yang
   http://127.0.0.1:6060/ref/spec#Representability[dapat direpresentasikan]
   oleh nilai bertipe `int`; dan jika ia bertipe maka harus bertipe integer.
*  Sebuah elemen tanpa kunci menggunakan indeks elemen sebelumnya ditambah
   satu.
   Jika elemen pertama tanpa kunci, indeksnya adalah nol.

http://127.0.0.1:6060/ref/spec#Address_operators[Mengambil alamat
dari abjad komposit menghasilkan sebuah pointer ke sebuah
http://127.0.0.1:6060/ref/spec#Variables[variabel]
unik yang diinisiasi dengan nilai literal.

----
var pointer *Point3D = &Point3D{y: 1000}
----


