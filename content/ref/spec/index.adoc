=  Spesifikasi Bahasa Pemrograman Go
:toc:

==  Versi 2018 November 16

[#Introduction]
==  Pendahuluan

Dokumen ini adalah referensi manual untuk bahasa pemrograman Go.
Untuk informasi dan dokumentasi lainnya lihat
https://golang.org[golang.org (Inggris)]
atau
link:/[golang-id.org (Indonesia)].

Go adalah bahasa pemrograman yang dirancang untuk pemrograman sistem.
Go adalah bahasa dengan tipe yang kuat dan dengan _garbage-collection_ dan
mendukung pemrograman konkuren secara eksplisit.
Program dibangun dari paket-paket, yang membolehkan ketergantungan
paket secara efisien.

Tata-bahasa dari Go padat dan teratur, membuatnya mudah untuk dianalisis oleh
perkakas-perkakas otomatis seperti lingkungan pengembangan integrasi (IDE).


[#Notation]
===  Notasi

Spesifikasi sintaksis menggunakan _Extended Backus-Naur Form_ (EBNF):

----
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
----

_Production_ adalah ekspresi yang dibangun dari sekumpulan _term_ dan operator
pendukung berikut, secara berurut:

----
|   alternasi
()  pengelompokan
[]  opsi (0 atau 1 kali)
{}  pengulangan (0 sampai n kali)
----

Nama `production_name` dengan huruf kecil digunakan untuk mengidentifikasi
token leksikal.
`production_name` dengan _CamelCase_ adalah _non-terminal_ (tidak berakhir).
Token leksikal dibungkus dalam tanda kutip ganda " " atau kutip terbalik ````.

Bentuk `a … b` merepresentasikan kumpulan huruf alternatif dari `a` sampai
`b`.
Elipsis horizontal `…` juga digunakan dalam spesifikasi ini
untuk secara informal menandakan enumerasi atau kode yang dipotong.
Karakter `…` (berlawanan dengan tiga karakter ...) bukanlah token dari
bahasa Go.

[#Source_code_representation]
==  Representasi sumber kode

Sumber kode adalah teks Unicode dalam
https://id.wikipedia.org/wiki/UTF-8[UTF-8].
Teks tersebut tidak kanonis, sehingga titik kode dengan aksen berbeda dengan
karakter yang sama yang dibangun dari menggabungkan sebuah aksen dan sebuah
huruf;
keduanya dianggap sebagai dua titik kode.
Demi kemudahan, dokumen ini menggunakan istilah _karakter_ untuk mengacu pada
titik kode Unicode dalam teks sumber kode.

Setiap titik kode berbeda satu dengan yang lainnya; misalnya, huruf besar dan
kecil adalah karakter yang berbeda.

Batasan implementasi: Untuk kompatibilitas dengan perkakas lainnya, _compiler_
mungkin tidak membolehkan karakter NUL (U+0000) dalam teks sumber kode.

Batasan implementasi: Untuk kompatibilitas dengan perkakas lainnya, _compiler_
bisa mengindahkan penanda urutan byte untuk _UTF-8-encoded_ (U+FEFF) jika ia
adalah titik kode Unicode pertama dalam teks sumber kode.
Penanda urutan _byte_ bisa saja tidak dibolehkan dalam sumber kode.

[#Characters]
===  Karakter

Istilah berikut digunakan untuk menandakan kelas karakter Unicode tertentu:

----
newline        = /* titik kode Unicode U+000A untuk baris baru */ .
unicode_char   = /* titik kode Unicode apa pun kecuali baris baru */ .
unicode_letter = /* titik kode Unicode dikelompokkan sebagai "Letter" (huruf) */ .
unicode_digit  = /* titik kode Unicode dikelompokkan sebagai "Number, decimal digit" */ .
----

https://www.unicode.org/versions/Unicode8.0.0/[The Unicode Standard 8.0],
Bagian 4.5 "General Category" mendefinisikan sekumpulan kategori karakter.
Go mengenali semua karakter dalam kategori Letter berikut Lu, Ll, Lt, Lm, atau
Lo sebagai huruf Unicode, dan yang berada dalam kategori Number Nd sebagai
angka Unicode.

[#Letters_and_digits]
===  Huruf dan angka

Karakter garis bawah `_` (U+005F) dianggap sebagai huruf.

----
letter        = unicode_letter | "_" .
decimal_digit = "0" … "9" .
octal_digit   = "0" … "7" .
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .
----


[#Lexical_elements]
==  Elemen leksikal

[#Comments]
===  Komentar

Komentar berfungsi sebagai dokumentasi program.
Ada dua bentuk komentar:

.  _Komentar baris_ dimulai dengan urutan karakter `//` dan berakhir pada
   ujung baris.
.  _Komentar umum_ dimulai dengan urutan karakter `/*` dan berakhir dengan
   urutan karakter `*/` yang pertama.

Komentar tidak boleh dimulai dalam sebuah
<<Rune_literals,rune>>
atau
<<String_literals,string>>,
atau di dalam komentar yang lain.
Komentar umum tanpa baris baru berarti memiliki sebuah spasi.
Komentar lainnya akan diartikan berada pada baris baru.


[#Tokens]
===  Token

Token-token membentuk kosakata dari bahasa Go.
Ada empat kelas token: _identifiers_ (pengidentifikasi), _keywords_
(kata-kunci), _operators dan punctuation_ (operator dan tanda baca),
dan _literal_ (literal).
Karakter kosong yang dibentuk dari spasi (U+0020), tab horizontal (U+0009),
_carriage returns_ (U+0009), dan baris baru (U+000A), diindahkan kecuali ia
memisahkan token-token yang bila digabungkan menjadi sebuah token.
Juga, sebuah baris baru atau akhir dari berkas bisa memicu
<<Semicolons,titik-koma>>.
Saat memecah input menjadi token-token, token selanjutnya adalah urutan
karakter terpanjang yang membentuk sebuah token yang valid.

[#Semicolons]
===  Titik-koma

Tata-bahasa formal menggunakan titik-koma ";" sebagai penanda akhir pada
beberapa pernyataan.
Program Go bisa menghilangkan titik-koma tersebut menggunakan dua aturan
berikut:

.  Saat input terpecah menjadi token-token, sebuah titik-koma secara otomatis
   langsung ditambahkan ke dalam aliran token setelah token terakhir pada
   sebuah baris jika token tersebut adalah

   *  sebuah <<Identifiers,pengidentifikasi>>
   *  sebuah <<Integer_literals,integer>>,
      <<Floating-point_literals,floating-point>>, <<Rune_literals,rune>>,
      atau <<String_literals,string>>
   *  salah satu <<Keywords,kata-kunci>> `break`, `continue`, `fallthrough`,
      atau `return`
   *  salah satu <<Operators_and_punctuation,operator dan tanda baca>> `++`,
      `--`, `)`, `]`, atau `}`

.  Untuk membolehkan perintah yang kompleks menghabiskan satu baris,
   titik-koma bisa dihilangkan sebelum ditutup oleh ")" atau "}"

Untuk merefleksikan penggunaan idiomatis, contoh kode dalam dokumen ini tidak
menggunakan titik-koma menggunakan aturan di atas.


[#Identifiers]
===  Pengidentifikasi

Pengidentifikasi memberi nama entitas seperti variabel dan tipe.
Sebuah pengidentifikasi adalah sebuah urutan satu atau lebih huruf dan angka.
Karakter pertama dalam sebuah pengidentifikasi haruslah huruf.

----
identifier = letter { letter | unicode_digit } .
----

----
a
_x9
ThisVariableIsExported
αβ
----

Beberapa pengidentifikasi
<<Predeclared_identifiers,telah dideklarasikan sebelumnya>>.

[#Keywords]
===  Kata kunci

Kata kunci berikut telah disiapkan dan tidak bisa digunakan sebagai
pengidentifikasi:

----
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
----

[#Operators_and_punctuation]
===  Operator dan tanda baca

Urutan karakter berikut merepresentasikan
<<Operators,operator>>
(termasuk <<assign_op,operator penempatan>>)
dan tanda baca:

----
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=
----

[#Integer_literals]
===  Literal integer

Literal integer adalah urutan angka merepresentasikan sebuah
<<Constants,konstan integer>>.
Beberapa opsi prefiks menyatakan basis non-desimal: `0` untuk oktal, `0x`
atau `0x` untuk heksadesimal.
Dalam literal heksadesimal, huruf `a-f` dan `A-F` merepresentasikan nilai antara
10 sampai 155.

----
int_lit     = decimal_lit | octal_lit | hex_lit .
decimal_lit = ( "1" … "9" ) { decimal_digit } .
octal_lit   = "0" { octal_digit } .
hex_lit     = "0" ( "x" | "X" ) hex_digit { hex_digit } .
----

----
42
0600
0xBadFace
170141183460469231731687303715884105727
----


[#Floating-point_literals]
===  Literal _floating-point_

Literal _floating-point_ adalah representasi desimal dari
<<Constants,konstan floating-point>>.
Ia memiliki bagian integer, titik desimal, bagian pecahan, dan bagian
eksponen.
Bagian integer dan pecahan terdiri dari angka desimal;
bagian eksponen yaitu `e` atau `E` diikuti dengan nilai eksponen.
Salah satu bagian integer atau pecahan bisa diindahkan;
salah satu bagian pecahan atau eksponen bisa diindahkan juga.

----
float_lit = decimals "." [ decimals ] [ exponent ] |
            decimals exponent |
            "." decimals [ exponent ] .
decimals  = decimal_digit { decimal_digit } .
exponent  = ( "e" | "E" ) [ "+" | "-" ] decimals .
----

----
0.
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
----


[#Imaginary_literals]
===  Literal imajiner

Literal imajiner merepresentasikan bagian imajiner dari
<<Constants,konstan kompleks>>.
Ia terdiri dari literal
<<Integer_literals,integer>>
atau
<<Floating-point_literals,floating-point>>
diikuti oleh huruf kecil `i`.
Nilai dari literal imajiner yaitu nilai dari literal integer atau floating-point
dikalikan dengan unit imajiner _i_.

----
imaginary_lit = (decimal_digits | int_lit | float_lit) "i" .
----

Untuk kompatibilitas, bagian integer dari literal imajiner yang
semuanya terdiri dari angka desimal (dan kemungkinan garis bawah) dianggap
sebagai integer desimal, walaupun dimulai dengan `0`.

----
0i
0123i         // == 123i untuk kompatibilitas
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
0x1p-2i       // == 0x1p-2 * 1i == 0.25i
----


[#Rune_literals]
===  Literal rune

Literal rune merepresentasikan sebuah
<<Constants, konstan rune>>,
sebuah nilai integer yang mengidentifikasi sebuah kode poin Unicode.
Literal rune diekspresikan dengan satu atau lebih karakter yang ditutup dengan
tanda kutip tunggal, seperti `'x'` atau `'\n'`.
Di dalam tanda kutip tersebut, karakter apa pun dapat ditulis kecuali baris
baru dan tanda kutip tunggal itu sendiri.
Sebuah karakter dengan kutip merepresentasikan nilai Unicode dari karakter itu
sendiri, sementara seurutan karakter yang dimulai dengan garis miring terbalik
(_backslash_) akan ditulis nilainya menjadi beragam format.

Bentuk sederhana dari rune merepresentasikan karakter tunggal antara tanda
kutip; secara teks sumber kode dari Go adalah karakter Unicode yang ditulis
dalam UTF-8, multipel UTF-8 byte bisa merepresentasikan sebuah nilai integer.
Misalnya, literal `'a'` menyimpan sebuah byte yang merepresentasikan sebuah
literal `a`, Unicode U+0061, dengan nilai `0x61`; sementara `'ä'` menyimpan dua
byte (`0xc3 0xa4`) yang merepresentasikan literal a-dwititik, U+00E4, nilai
`0xe4`.

Beberapa _backslash_ membolehkan nilai beragam ditulis sebagai teks ASCII.
Ada empat cara untuk merepresentasikan nilai integer sebagai konstan
numerik: `\x` diikuti dengan dua digit heksadesimal; `\u` diikuti dengan empat
digit heksadesimal; `\U` diikuti dengan delapan heksadesimal, dan _backslash_
kosong `\` diikuti dengan tiga digit oktal.
Pada setiap kasus tersebut nilai dari literal adalah nilai yang
direpresentasikan oleh digit pada basis yang berhubungan.

Walaupun representasi tersebut semua hasilnya adalah sebuah integer, mereka
memiliki rentang yang berbeda.
Oktal harus merepresentasikan sebuah nilai antara 0 dan 255 secara inklusif.
Heksadesimal memenuhi kondisi ini secara konstruksi.
`\u` dan `\U` merepresentasikan kode poin Unicode sehingga beberapa nilai
adalah ilegal, khususnya nilai di atas `0x10FFFF` dan _surrogate half_
(bagian setengah atas dari empat heksadesimal).

Setelah tanda _backslash_, beberapa karakter tunggal merepresentasikan nilai
spesial:

----
\a   U+0007 alert atau bel
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed atau newline
\r   U+000D carriage return
\t   U+0009 tab horizontal
\v   U+000b tab vertikal
\\   U+005c backslash (garis miring terbalik)
\'   U+0027 tanda kutip tunggal (valid hanya pada literal rune)
\"   U+0022 tanda kutip ganda (valid hanya pada literal string)
----

Urutan karakter lain yang dimulai dengan sebuah _backslash_ adalah ilegal di
dalam literal rune.

----
rune_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
----

----
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // literal rune berisi sebuah karakter kutip
'aa'         // ilegal: terlalu banyak karaketer
'\xa'        // ilegal: terlalu sedikit digit heksadesimal
'\0'         // ilegal: terlalu sedikit digit oktal
'\uDFFF'     // ilegal: setengah
'\U00110000' // ilegal: invalid Unicode
----


[#String_literals]
===  Literal string

Literal string merepresentasikan
<<Constants,konstan string>>
yang didapat dari menggabungkan seurutan karakter-karakter.
Ada dua bentuk string: literal string mentah dan literal string interpretasi.

Literal string mentah yaitu seurutan karakter antara kutip terbalik (aksen
nontirus), seperti dalam ````foo```` .
Di antara tanda kutip terbalik, karakter apa pun dapat muncul kecuali tanda
kutip terbalik itu sendiri.
Nilai dari literal string mentah tersebut yaitu string yang terdiri dari
karakter-karakter yang tidak diinterpretasi (implisit UTF-8) di antara tanda
kutip;
pada khususnya, _backslash_ tidak berfungsi dan string bisa memiliki baris
baru.
Karakter _carriage return_ (`'\r'`) di dalam literal string mentah diindahkan
dari nilai string mentah.

Literal string interpretasi yaitu seurutan karakter antara tanda kutip ganda,
seperti dalam`"bar"`.
Di antara tanda kutip, karakter apa pun bisa muncul kecuali baris baru dan
tanda kutip ganda lepas (tanpa _backslash_).
Teks antara tanda kutip membentuk nilai dari literal, dengan _backslash_
diartikan seperti halnya dalam
<<Rune_literals,literal rune>>
(kecuali `\'` adalah ilegal dan `\"` adalah legal), dengan batasan-batasan
yang sama.
Tiga-digit oktal (_\nnn_) dan dua-digit heksadesimal (\x_nn_)
merepresentasikan _byte_ individu dari string;
karakter lepas lainnya merepresentasikan _encoding_ UTF-8 (bisa jadi
multi-byte) dari _karakter-karakter_ tersebut.
Maka di dalam literal string, `\377` dan `\xFF` merepresentasikan nilai
`0xFF`=255, sementara `ÿ, `\u00FF`, `\U000000FF` dan `\xc3\xbf`
merepresentasikan dua byte `0xc3 0xbf` dari _encoding_ karakter UTF-8  U+00FF.

----
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .
----

----
`abc`                // sama dengan "abc"
`\n
\n`                  // sama dengan "\\n\n\\n"
"\n"
"\""                 // sama dengan `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"             // ilegal: _surrogate half_
"\U00110000"         // ilegal: invalid kode poin Unicode
----

Contoh berikut merepresentasikan string yang sama:

----
"日本語"                                 // UTF-8 input teks
`日本語`                                // UTF-8 input teks sebagai literal mentah
"\u65e5\u672c\u8a9e"                    // kode poin Unicode eksplisit
"\U000065e5\U0000672c\U00008a9e"        // kode poin Unicode eksplisit
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // UTF-8 byte eksplisit
----

Jika sumber kode merepresentasikan sebuah karakter sebagai dua kode poin,
seperti sebuah gabungan bentuk mengikutkan aksen dan sebuah huruf, hasilnya
akan eror jika ditempatkan dalam sebuah literal rune (karena bukanlah kode poin
tunggal), dan akan muncul sebagai dua kode poin jika ditempatkan dalam literal
string.


[#Constants]
==  Konstan

Ada _konstan boolean_, _konstan rune_, _konstan integer_,
_konstan floating-point_, _konstan complex_, dan _konstan string_.
Konstan rune, integer, _floating-point_, dan complex secara kolektif disebut
dengan _konstan numerik_.

Nilai sebuah konstan direpresentasikan oleh sebuah literal
<<Rune_literals,rune>>,
<<Integer_literals,integer>>,
<<Floating-point_literals, floating-point>>,
<<Imaginary_literals,imajiner>>, atau
<<String_literals,string>>,
sebuah pengidentifikasi yang menyatakan sebuah konstan,
sebuah
<<Constant_expressions, ekspresi konstan>>,
sebuah
<<Conversions, konversi>>
dengan hasil sebuah konstan, atau nilai hasil dari fungsi bawaan seperti
`unsafe.Sizeof` yang diterapkan terhadap nilai apa pun, `cap` atau `len` yang
diterapkan pada
<<Length_and_capacity,beberapa ekspresi>>,
`real` dan `imag` yang diterapkan pada konstan complex dan
`complex` yang diterapkan pada konstan numerik.
Nilai boolean direpresentasikan dengan konstan `true` dan `false`.
Identifikasi
<<Iota,iota>>
menyatakan konstan integer.

Secara umum, konstan complex adalah sebuah bentuk dari
<<Constant_expressions, ekspresi konstan>>
dan didiskusikan di bagian tersebut.

Konstan numerik merepresentasikan nilai eksak dari presisi beragam dan
tidak _overflow_.
Karena itu, tidak ada konstan yang menyatakan nilai negatif nol IEEE-754,
_infinity_, dan nilai bukan-angka.

Konstan bisa <<Types, bertipe>> atau tak bertipe.
Konstan harfiah, `true`, `false`, `iota`, dan beberapa
<<Constant_expressions, ekspresi konstan>>
yang berisi hanya operan konstan tanpa tipe adalah konstan tak bertipe.

Sebuah konstan bisa diberikan tipe secara eksplisit dengan
<<Constant_declarations,deklarasi konstan>> atau
<<Conversions, konversi>>, atau secara implisit bila digunakan dalam
sebuah
<<Variable_declarations,deklarasi variabel>>
atau dalam sebuah
<<Assignments, penempatan>>
atau sebagai sebuah operan dalam sebuah
<<Expressions, ekspresi>>.
Jika nilai konstan tidak dapat
<<Representability, direpresentasikan>> sebagai sebuah nilai dari
tipe maka ia akan eror.

Konstan tak bertipe memiliki _tipe bawaan_ yaitu tipe yang mana konstan
secara implisit dikonversi dalam konteks di mana nilai bertipe dibutuhkan,
misalnya,
dalam
<<Short_variable_declarations, deklarasi variabel singkat>>
seperti `i := 0` yang mana tidak ada tipe eksplisit.
Tipe bawaan dari konstan tak bertipe adalah `bool`, `rune`, `int`, `float64`,
`complex128` atau `string`, bergantung kepada apakah ia adalah sebuah konstan
boolean, rune, integer, _floating-point_, complex, atau string.

Batasan implementasi: Walaupun konstan numerik memiliki presisi beragam
dalam bahasa Go, _compiler_ bisa saja mengimplementasikan mereka menggunakan
representasi internal dengan presisi terbatas.
Dengan kata lain, setiap implementasi harus:

*  Merepresentasikan konstan integer paling tidak 256 bit.
*  Merepresentasikan konstan _floating-point_, termasuk bagian dari
   konstan complex, dengan mantisa setidaknya 256 bit dan sebuah eksponen
   binary _signed_ setidaknya 16 bit.
*  Kembalikan eror bila tidak bisa merepresentasikan konstan integer secara
   tepat.
*  Kembalikan eror bila tidak bisa merepresentasikan sebuah konstan
   _floating-point_ atau complex karena _overflow_.
*  Bulatkan ke konstan terdekat yang dapat direpresentasikan jika tidak bisa
   merepresentasikan konstan _floating-point_ atau complex dikarenakan limit
   atau presisi.

Kebutuhan-kebutuhan di atas berlaku baik terhadap konstan harfiah dan
terhadap hasil dari mengevaluasi
<<Constant_expressions, ekspresi konstan>>.


[#Variables]
==  Variabel

Sebuah variabel adalah sebuah lokasi penampung untuk menyimpan sebuah _nilai_.
Kumpulan dari nilai yang diperbolehkan ditentukan oleh <<Types,tipe>>
variabel.

Sebuah
<<Variable_declarations, deklarasi variabel>> atau penanda dari
<<Function_declarations, deklarasi fungsi>> (pada parameter dan kembalian dari
fungsi), atau
<<Function_literals, fungsi literal>>
mencadangkan penampung untuk sebuah variabel bernama.
Memanggil fungsi bawaan
<<Allocation, new>>
atau mengambil alamat dari sebuah
<<Composite_literals, literal komposit>>
mengalokasikan penampung untuk sebuah variabel pada saat _runtime_.
Variabel anonim diacu lewat sebuah (bisa jadi implisit)
<<Address_operators, pointer tak-langsung>>.

Variabel berstruktur dari tipe
<<Array_types, array>>,
<<Slice_types, slice>>, dan
<<Struct_types, struct>>
memiliki elemen-elemen dan field-field yang bisa
<<Address_operators, diakses>>
secara individu.
Setiap elemen tersebut berlaku seperti sebuah variabel.

_Tipe statis_ (atau _tipe_) dari sebuah variabel yaitu tipe yang diberikan
saat deklarasi, tipe yang diberikan pada saat pemanggilan `new` atau
komposit literal, atau tipe dari sebuah elemen dari variabel berstruktur.
Variabel dari tipe interface memiliki _tipe dinamis_ berbeda, yaitu tipe
konkret dari nilai yang diberikan ke variabel pada saat _runtime_ (kecuali
bila nilainya adalah `nil`, yang berarti tak bertipe).
Tipe dinamis bisa beragam selama eksekusi namun nilai yang disimpan dalam
variabel interface selalu
<<Assignability, ditempatkan>>
ke tipe statis dari variabel.

----
var x interface{}  // x adalah nil dengan tipe statis interface{}
var v *T           // v bernilai nil, tipe statis *T
x = 42             // x bernilai 42 dan tipe dinamis int
x = v              // x bernilai (*T)(nil) dan tipe dinamis *T
----

Nilai variabel diambil dengan mengacu pada variabel dalam sebuah
<<Expressions, ekspresi>>;
nilai dari variabel yaitu nilai terakhir yang
<<Assignments, ditempatkan>>
ke variabel tersebut.
Jika sebuah variabel belum diberi nilai, nilainya adalah
<<The_zero_value, nilai kosong>>
dari tipe variabel.


[#Types]
==  Tipe

Sebuah tipe menentukan sekumpulan nilai berikut dengan operasi dan method
yang spesifik terhadap nilainya.
Sebuah tipe bisa ditulis dengan sebuah _nama tipe_, jika ada, atau
dispesifikasikan menggunakan _literal tipe_, yang membentuk sebuah tipe dari
tipe-tipe yang telah ada.

----
Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
	    SliceType | MapType | ChannelType .
----

Bahasa Go
<<Predeclared_identifiers, mendeklarasikan>>
beberapa nama tipe.
Nama tipe lainnya diperkenalkan lewat
<<Type_declarations, deklarasi tipe>>.
_Tipe komposit_ -- tipe array, struct, pointer, fungsi, interface, slice, map,
dan channel -- bisa dibangun menggunakan literal tipe.

Setiap tipe T memiliki _tipe dasar_: Jika `T` adalah salah satu tipe boolean,
numerik, string, literal; make tipe dasar dari `T` itu sendiri adalah `T`.
Selain itu, tipe dasar dari `T` yaitu tipe yang diberikan saat
<<Type_declarations, deklarasi>>.

----
type (
	A1 = string
	A2 = A1
)

type (
	B1 string
	B2 B1
	B3 []B1
	B4 B3
)
----

Tipe dasar dari `string`, `A1`, `A2`, `B1`, dan `B2` adalah `string`.
Tipe dasar dari `[]B1`, `B3`, dan `B4` yaitu `[]B1`.

[#Method_sets]
===  Kumpulan method

Sebuah tipe bisa memiliki _sekumpulan method_.
Kumpulan method dari
<<Interface_types, tipe interface>>
yaitu interface-nya sendiri.
Kumpulan method dari tipe `T` terdiri dari semua
<<Method_declarations, method-method>>
yang dideklarasikan pada penerima (_receiver_) tipe `T`.
Kumpulan method dari
<<Pointer_types, tipe pointer>>
`*T` yaitu semua method yang dideklarasikan dengan penerima `*T` atau `T` (ia
berisi juga kumpulan method dari `T`).
Aturan yang sama juga berlaku untuk struct yang berisi field-field yang
ditanam (_embed_), seperti yang dijelaskan dalam bagian
<<Struct_types, tipe struct>>.
Tipe apa pun memiliki kumpulan method kosong.
Di dalam sebuah kumpulan method, setiap method harus memiliki
<<MethodName, nama method>>
yang unik dan tidak kosong.

Kumpulan method dari sebuah tipe menentukan interface yang
<<Interface_types, diimplementasi>>
oleh tipe tersebut dan method tersebut bisa
<<Calls, dipanggil>>
menggunakan penerima dari tipe tersebut.


[#Boolean_types]
===  Tipe boolean

Sebuah _tipe boolean_ merepresentasikan kumpulan nilai Boolean yang
dilambangkan oleh konstan `true` dan `false`.
Tipe boolean dikenal sebagai `bool`;
ia adalah
<<Type_definitions, tipe terdefinisi>>.


[#Numeric_types]
===  Tipe numerik

_Tipe numerik_ merepresentasikan kumpulan nilai integer atau _floating-point_.
Deklarasi dari tipe numerik, yang bergantung pada arsitektur, yaitu:

----
uint8       kumpulan semua unsigned  8-bit integer (0 sampai 255)
uint16      kumpulan semua unsigned 16-bit integer (0 sampai 65535)
uint32      kumpulan semua unsigned 32-bit integer (0 sampai 4294967295)
uint64      kumpulan semua unsigned 64-bit integer (0 sampai 18446744073709551615)

int8        kumpulan semua signed  8-bit integers (-128 sampai 127)
int16       kumpulan semua signed 16-bit integers (-32768 sampai 32767)
int32       kumpulan semua signed 32-bit integers (-2147483648 sampai 2147483647)
int64       kumpulan semua signed 64-bit integers (-9223372036854775808 sampai 9223372036854775807)

float32     kumpulan semua IEEE-754 32-bit bilangan floating-point
float64     kumpulan semua IEEE-754 64-bit bilangan floating-point

complex64   kumpulan semua bilangan complex dengan float32 pada bagian real dan imajiner
complex128  kumpulan semua bilangan complex dengan float64 pada bagian real dan imajiner

byte        alias untuk uint8
rune        alias untuk int32
----

Nilai dari _n_-bit integer yaitu _n_ bit lebarnya dan direpresentasikan
menggunakan
https://en.wikipedia.org/wiki/Two's_complement[aritmetika komplemen ganda].

Ada juga kumpulan tipe numerik yang ukurannya tergantung pada arsitektur:

----
uint     bisa 32 atau 64 bit
int      berukuran sama dengan uint
uintptr  unsigned integer cukup besar menyimpan bit dari nilai pointer
----

Untuk menghindari masalah portabilitas semua tipe numerik adalah
<<Type_definitions, tipe terdefinisi>>
dan makanya berbeda kecuali `byte`, yang merupakan
<<Alias_declarations, alias>>
dari `uint8`, dan `rune`, yang merupakan alias untuk `uint32`.
Konversi eksplisit dibutuhkan saat tipe numerik berbeda bertemu pada sebuah
ekspresi atau pernyataan.
Misalnya, `int32` dan `int` bukanlah tipe yang sama walaupun keduanya
berukuran sama pada arsitektur tertentu.


[#String_types]
===  Tipe string

_Tipe string_ merepresentasikan kumpulan nilai string.
Nilai sebuah string yaitu (bisa kosong) urutan dari byte.
Jumlah byte disebut juga panjang dari string dan tidak pernah negatif.
String adalah _immutable_ (tetap): sekali dibuat, maka tidak akan bisa lagi
diubah isinya.
Tipe string yaitu `string`; ia adalah
<<Type_definitions, tipe terdefinisi>>.

Panjang dari string `s` dapat diketahui lewat fungsi bawaan
<<Length_and_capacity, len>>.
Panjangnya akan konstan bila string tersebut adalah konstan.
Isi byte dari string dapat diakses dengan
<<Index_expressions, indeks>>
0 sampai `len(s)-1`.
Mengambil alamat byte pada string adalah ilegal;
jika `s[i]` adalah byte ke `i` dari string, maka `&s[i]` tidak valid.


[#Array_types]
===  Tipe array

Sebuah array yaitu urutan elemen dari sebuah tipe yang jumlahnya tetap.
Jumlah dari elemen disebut juga dengan panjang array dan tidak pernah negatif.

----
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .
----

Panjang array adalah bagian dari tipe array;
Ia harus berupa
<<Constants, konstanta>>
non-negatif yang
<<Representability, direpresentasikan>>
oleh nilai bertipe `int`.
Panjang dari array `a` dapat diketahui dengan fungsi bawaan
<<Length_and_capacity,len>>.
Setiap elemen array dapat diakses lewat
<<Index_expressions,indeks>>
0 sampai `len(a)-1`.
Tipe array selalu satu dimensi namun bisa digabung untuk membentuk tipe
multi-dimensi.

----
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // sama dengan [2]([2]([2]float64))
----


[#Slice_types]
===  Tipe slice

Sebuah slice adalah penampung dari segmen bersambungan dari sebuah
_array dasar_ dan menyediakan akses ke elemen dari array tersebut.
Sebuah tipe slice menandakan kumpulan dari semua bagian dari array dari tipe
elemennya.
Jumlah elemen disebut dengan panjang slice dan tidak pernah negatif.
Nilai dari slice yang tidak diinisiasi yaitu `nil`.

----
SliceType = "[" "]" ElementType .
----

Panjang dari slice diketahui lewat fungsi bawaan
<<Length_and_capacity,len>>;
tidak seperti array ia bisa berubah selama eksekusi.
Elemen slice bisa diakses lewat integer
<<Index_expressions,indeks>>
0 sampai `len(s)-1`.
Indeks slice dari elemen bisa kecil dari indeks dari elemen yang sama di array
dasarnya.

Sebuah slice, setelah diinisiasi, selalu berasosiasi dengan array dasar yang
menyimpan elemen-elemennya.
Oleh karena itu sebuah slice berbagi tempat penyimpanan dengan array-nya dan
dengan slice lain dari array yang sama;
sebaliknya, array yang berbeda merepresentasikan tempat penyimpanan yang
berbeda.

Array yang mendasari sebuah slice bisa diperlebar melebihi akhir dari slice.
Konsep ini dikenal dengan _kapasitas_: ia adalah jumlah panjang dari slice dan
panjang dari array-dasar slice;
Sebuah slice yang panjangnya lebih dari kapasitas bisa dibuat dengan
<<Slice_expressions,slicing>> (memotong)
yang baru dari slice asli.
Kapasitas dari slice `a` dapat diketahui menggunakan fungsi bawaan
<<Length_and_capacity,`cap(a)`>>.

Slice baru bertipe `T` dapat diinisiasi menggunakan fungsi bawaan
<<Making_slices_maps_and_channels,make>>,
yang menerima tipe slice dan parameter yang menentukan panjang, dan opsi
kapasitas.
Sebuah slice yang dibuat dengan `make` selalu mengalokasikan array yang baru
yang diacu oleh slice yang dikembalikan.
Sehingga, mengeksekusi

----
make([]T, length, capacity)
----

menghasilkan slice yang sama seperti membuat array dan
<<Slice_expressions,memotongnya>>,
sehingga dua ekspresi berikut adalah sama:

----
make([]int, 50, 100)
new([100]int)[0:50]
----

Seperti halnya array, slice selalu satu-dimensi namun bisa bergabung membentuk
objek dengan dimensi lebih tinggi.
Lewat array dari array, array di dalamnya, selalu memiliki panjang yang sama;
namun dengan slice dari slice (atau array dari slice), panjang di dalamnya
bisa beragam secara dinamis.
Lebih lanjut, slice paling dalam harus diinisiasi secara sendiri-sendiri.


[#Struct_types]
===  Tipe struct

Sebuah struct yaitu urutan dari elemen bernama, disebut field, tiap-tiap field
memiliki nama dan tipe.
Nama field bisa secara eksplisit (IdentifierList) atau secara implisit
(EmbeddedField).
Dalam sebuah struct, nama field yang tidak
<<Blank_identifier,kosong>>
haruslah
<<Uniqueness_of_identifiers,unik>>.

----
StructType    = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
EmbeddedField = [ "*" ] TypeName .
Tag           = string_lit .
----

----
// Sebuah struct kosong.
struct {}

// Sebuah struct dengan 6 field.
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
----

Field dengan tipe namun tanpa nama disebut dengan _field tertanam_.
Field tertanam haruslah tipe bernama `T` atau sebagai pointer ke tipe bernama
yang bukan interface `*T`, dan `T` itu sendiri bisa saja bukan tipe pointer.
Nama tipe pada field tertanam berlaku sebagai nama field.

----
// Sebuah struct dengan empat field tertanam bertipe T1, *T2, P.T3 dan *P.T4
struct {
	T1        // nama fieldnya yaitu T1
	*T2       // nama fieldnya yaitu T2
	P.T3      // nama fieldnya yaitu T3
	*P.T4     // nama field nya yaitu T4
	x, y int  // nama field nya yaitu x dan y
}
----

Deklarasi berikut ilegal karena nama field harus unik dalam sebuah tipe
struct:

----
struct {
	T     // konflik dengan field tertanam *T dan *P.T
	*T    // konflik dengan field tertanam T dan *P.T
	*P.T  // konflik dengan field tertanam T dan *T
}
----

Sebuah field atau
<<Method_declarations,method>>
`f` dari field tertanam dalam sebuah struct `x` disebut _dipromosikan_ jika
`x.f` adalah
<<Selectors,selektor>>
yang legal yang menandakan field atau method `f` tersebut.

Field yang dipromosikan berlaku seperti field biasa kecuali ia tidak bisa
digunakan sebagai nama field di dalam
<<Composite_literals,literal komposit>>
dari struct.

Diberikan sebuah tipe struct `S` dan
<<Type_definitions,tipe terdefinisi>> `T`,
method-method yang dipromosikan yang masuk ke dalam kumpulan method dari
struct `S` yaitu:

*  Jika `S` berisi field tertanam `T`,
   <<Method_sets,kumpulan method>>
   dari `S` dan `*S` mengikutkan method-method promosi dari `T`.
   Kumpulan method dari `*S` juga mengikutkan method promosi dari `*T`.

*  Jika `S` berisi field tertanam `T`, kumpulan method dari `S` dan `*S`
   keduanya mengikutkan method promosi dari `T` atau `*T`.

Deklarasi field bisa ditambah dengan literal string _tag_, yang menjadi
atribut dari field.
Tag kosong berarti tidak ada tag.
Tag bisa diakses lewat
https://golang.org/pkg/reflect/#StructTag[interface refleksi]
dan ambil bagian dalam
<<Type_identity,identitas tipe>>
dari struct.

----
struct {
	x, y float64 ""  // tag kosong sama dengan tanpa tag.
	name string  "string apa pun dibolehkan sebagai tag"
	_    [4]byte "ceci n'est pas un champ de structure"
}

// Sebuah struct untuk TimeStamp pada protocol buffer.
// String tag mendefinisikan field angka untuk protocol buffer;
// hal ini mengikuti konvensi yang dijelaskan oleh paket reflect.
struct {
	microsec  uint64 `protobuf:"1"`
	serverIP6 uint64 `protobuf:"2"`
}
----

[#Pointer_types]
===  Tipe pointer

Tipe pointer menandakan kumpulan semua pointer terhadap
<<Variables,variabel>>
dari tipe yang diberikan, disebut juga dengan _tipe dasar_ dari pointer.
Nilai dari pointer yang tidak diinisiasi adalah `nil`.

----
PointerType = "*" BaseType .
BaseType    = Type .
----

----
*Point
*[4]int
----


[#Function_types]
===  Tipe fungsi

Tipe fungsi menandakan kumpulan semua fungsi dengan tipe parameter dan
kembalian yang sama.
Nilai dari variabel bertipe fungsi yang tidak diinisiasi yaitu `nil`.

----
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
----

Dalam parameter atau kembalian, nama (IdentifierList) haruslah ada atau tidak
ada sama sekali.
Jika ada, setiap nama mengacu untuk satu item (parameter atau kembalian) dari
tipe dan semua nama haruslah
<<Uniqueness_of_identifiers,unik>>.
Jika tanpa nama, setiap tipe merepresentasikan satu item untuk tipe tersebut.
Daftar parameter dan kembalian selalu dalam tanda kurung kecuali pada
kembalian tunggal tanpa nama, ia bisa ditulis tanpa tanda kurung.

Parameter terakhir dalam penanda fungsi bisa memiliki tipe yang dimulai dengan
"..." .
Fungsi dengan parameter tersebut disebut _variadic_ dan bisa dipanggil tanpa
atau lebih argumen dengan tipe yang sama.

----
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
----


[#Interface_types]
===  Tipe interface

Tipe interface menspesifikasikan
<<Method_sets,sekumpulan method>>
yang disebut dengan _interface_.
Sebuah variabel bertipe interface dapat menyimpan tipe apa pun asalkan
memiliki kumpulan method yang dimiliki oleh interface tersebut.
Tipe tersebut dikatakan _mengimplementasikan interface_.
Nilai dari variabel interface yang tidak diinisiasi adalah `nil`.

----
InterfaceType      = "interface" "{" { MethodSpec ";" } "}" .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
----

Dalam tipe interface, setiap method haruslah memiliki nama yang
<<Uniqueness_of_identifiers,unik>>
dan tidak-
<<Blank_identifier,kosong>>.

----
// Sebuah interface berkas sederhana.
interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
	Close()
}
----

Satu atau lebih tipe yang berbeda dapat mengimplementasikan sebuah interface.
Misalnya, jika dua tipe `S1` dan `S2` memiliki sekumpulan method

----
func (p T) Read(b Buffer) bool { return … }
func (p T) Write(b Buffer) bool { return … }
func (p T) Close() { … }
----

(yang mana `T` bisa `S1` atau `S2`) maka interface `File` dikatakan
diimplementasikan oleh `S1` dan `S2`, walaupun `S1` dan `S2` bisa saja punya
method yang lain.

Sebuah tipe bisa mengimplementasikan satu atau lebih interface yang berbeda.
Misalnya, semua tipe mengimplementasikan _interface kosong_:

----
interface{}
----

Hal yang sama, pada spesifikasi interface berikut, yang muncul dalam
<<Type_declarations,deklarasi tipe>>
yang mendefinisikan sebuah interface bernama `Locker`:

----
type Locker interface {
	Lock()
	Unlock()
}
----

Jika `S1` dan `S2` juga mengimplementasikan

----
func (p T) Lock() { … }
func (p T) Unlock() { … }
----

maka mereka juga mengimplementasikan interface `Locker` dan juga interface
`File`.

Sebuah interface `T` bisa menanam tipe interface bernama `E`.
Hal ini disebut _penanaman_ interface `E` dalam `T`;
penanaman interface berarti menambahkan semua method (yang diekspor dan tidak
diekspor) dari `E` ke interface `T`.

----
type ReadWriter interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
}

type File interface {
	ReadWriter  // sama dengan menambahkan method-method dari ReadWriter
	Locker      // sama dengan menambahkan method-method dari Locker
	Close()
}

type LockedFile interface {
	Locker
	File        // ilegal: Lock, Unlock tidak unik
	Lock()      // ilegal: Lock tidak unik
}
----

Interface bertipe `T` tidak bisa secara rekursi menanam dirinya sendiri atau
interface lain yang menanam `T`.

----
// ilegal: Bad tidak bisa menanam dirinya sendiri
type Bad interface {
	Bad
}

// ilegal: Bad1 tidak bisa menanam dirinya sendiri menggunakan Bad2
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
----

[#Map_types]
===  Tipe map

Sebuah map adalah gabungan tak urut dari elemen dari satu tipe, yang
disebut tipe elemen, yang memiliki indeks berupa sekumpulan _key_ unik dari
tipe lainnya, disebut tipe key.
Nilai dari map yang tidak diinisiasi yaitu `nil`.

----
MapType     = "map" "[" KeyType "]" ElementType .
KeyType     = Type .
----

<<Comparison_operators,Operator pembanding>> `==`
dan `!=` haruslah terdefinisi untuk operan dari tipe key;
oleh karena itu tipe key tidak bisa berupa fungsi, map, atau slice.
Jika tipe key adalah sebuah tipe interface, maka operator pembanding harus
terdefinisi untuk nilai key dinamis;
jika tidak akan menyebabkan
<<Run_time_panics,run-time panic>>.

----
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}
----

Jumlah elemen map disebut panjang.
Untuk map `m`, jumlahnya bisa diambil dengan fungsi bawaan
<<Length_and_capacity,len>>
dan ia bisa berubah selama eksekusi.
Elemen bisa ditambah selama eksekusi menggunakan
<<Assignments,penempatan>>
dan diambil dengan
<<Index_expressions,ekspresi indeks>>;
dan elemen bisa dihapus dengan fungsi bawaan
<<Deletion_of_map_elements,delete>>.

Nilai map yang baru dan kosong dibuat dengan fungsi bawaan
<<Making_slices_maps_and_channels,make>>,
yang menerima tipe map dan kapasitas opsional sebagai argumen:

----
make(map[string]int)
make(map[string]int, 100)
----

Kapasitas awal tidak ada batas ukurannya: map berkembang untuk mengakomodasi
sejumlah item yang disimpannya, kecuali pada map yang `nil`.
Map yang `nil` sama dengan map kosong kecuali ia tidak bisa ditambahkan dengan
elemen.


[#Channel_types]
===  Tipe channel

Sebuah channel menyediakan sebuah mekanisme untuk
<<Go_statements,mengeksekusi fungsi secara konkuren>>
untuk berkomunikasi dengan
<<Send_statements,mengirim>>
dan
<<Receive_operator,menerima>>
nilai dari tipe elemen yang ditentukan.
Nilai dari channel yang tidak diinisiasi yaitu `nil`.

----
ChannelType = ( "chan" | "chan" "<-" | "<-" "chan" ) ElementType .
----

Operator opsional `<-` menspesifikasikan _arah_ channel, _kirim_ atau
_terima_.
Jika tidak ada arah yang diberikan, maka channel adalah _bidirectional_ (dua
arah).
Sebuah channel bisa dibatasi hanya untuk mengirim atau menerima saja dengan
<<Assignments,penempatan>>
atau
<<Conversions,konversi>>
eksplisit.

----
chan T          // bisa digunakan untuk mengirim dan menerima nilai bertipe T
chan<- float64  // hanya bisa digunakan mengirim float64
<-chan int      // hanya bisa menerima int
----

Operator `<-` berhubungan dengan `chan` yang paling kiri:

----
chan<- chan int    // sama dengan chan<- (chan int)
chan<- <-chan int  // sama dengan chan<- (<-chan int)
<-chan <-chan int  // sama dengan <-chan (<-chan int)
chan (<-chan int)
----

Inisiasi nilai channel yang baru bisa dibuat dengan fungsi bawaan
<<Making_slices_maps_and_channels,make>>
yang menerima tipe channel dan _kapasitas_ opsional sebagai argumen:

----
make(chan int, 100)
----

Kapasitas, atau jumlah elemen, mengatur ukuran _buffer_ dalam channel.
Jika kapasitasnya kosong atau tidak ada, channel adalah tanpa _buffer_ dan
komunikasi akan sukses saat pengirim dan penerima telah siap.
Sebaliknya, bila kapasitas tidak kosong, maka channel adalah ber-_buffer_
dan komunikasi akan sukses tanpa ditahan jika _buffer_ tidak penuh (mengirim)
atau tidak kosong (menerima).
Channel yang `nil` tidak akan pernah bisa berkomunikasi.

Channel bisa ditutup dengan fungsi bawaan
<<Close,close>>.
Bentuk penempatan banyak-nilai dari
<<Receive_operator,operator penerima>>
melaporkan apakah nilai yang diterima dikirim sebelum channel ditutup.

Sebuah channel bisa digunakan untuk
<<Send_statements,mengirim>>,
<<Receive_operator,menerima>>,
dan memanggil fungsi bawaan
<<Length_and_capacity,cap>>
dan
<<Length_and_capacity,len>>
oleh sejumlah goroutine berbeda tanpa perlu sinkronisasi.
Channel bersifat antrean first-in-first-out (yang pertama masuk, yang pertama
keluar).
Misalnya, jika sebuah goroutine mengirim nilai ke channel dan goroutine kedua
menerimanya, nilai diterima sesuai urutan yang dikirim.


[#Properties_of_types_and_values]
==  Properti dari tipe dan nilai


[#Type_identity]
===  Identitas tipe

Dua buah tipe akan _identik_ atau _berbeda_.

<<Type_definitions,Tipe terdefinisi>>
selalu berbeda dengan tipe lainnya.
Sebaliknya, dua tipe adalah identik jika tipe
<<Types,dasar>>
mereka secara struktural sama;
yaitu, memiliki struktur literal yang sama dan komponen yang
berhubungan memiliki tipe yang sama.
Secara lebih rinci:

*  Dua tipe array adalah identik jika mereka punya tipe elemen dan panjang
   yang sama.
*  Dua tipe slice adalah identik jika mereka punya tipe elemen yang sama.
*  Dua tipe struct adalah identik jika mereka memiliki urutan field yang sama,
   dan jika field-field tersebut memiliki nama. tipe, dan tag yang sama.
   Nama field yang
   <<Exported_identifiers,tidak diekspor>>
   dari paket yang berbeda selalu menghasilkan tipe struct yang tidak identik.
*  Dua tipe pointer adalah identik jika mereka memiliki tipe dasar yang sama.
*  Dua tipe fungsi adalah identik jika mereka memiliki jumlah parameter dan
   kembalian yang sama, dengan tipe parameter dan kembalian yang sama, dan
   bila kedua fungsi adalah _variadic_ atau tidak sama sekali.
   Nama pada parameter dan kembalian tidak harus sama.
*  Dua tipe interface adalah identik jika mereka memiliki kumpulan method
   dengan nama yang sama dan tipe fungsi yang sama.
   Nama method yang
   <<Exported_identifiers,tidak diekspor>>
   dari paket yang berbeda akan selalu menghasilkan tipe yang tidak identik.
   Urutan dari method tidak berpengaruh.
*  Dua tipe map adalah identik jika mereka memiliki tipe key dan elemen yang
   sama.
*  Dua tipe channel adalah identik jika mereka memiliki tipe elemen dan arah
   yang sama.

Diberikan deklarasi berikut,

----
type (
	A0 = []string
	A1 = A0
	A2 = struct{ a, b int }
	A3 = int
	A4 = func(A3, float64) *A0
	A5 = func(x int, _ float64) *[]string
)

type (
	B0 A0
	B1 []string
	B2 struct{ a, b int }
	B3 struct{ a, c int }
	B4 func(int, float64) *B0
	B5 func(x int, y float64) *A1
)

type	C0 = B0
----

tipe-tipe berikut adalah identik:

----
A0, A1, dan []string
A2 dan struct{ a, b int }
A3 dan int
A4, func(int, float64) *[]string, dan A5

B0 dan C0
[]int dan []int
struct{ a, b *T5 } dan struct{ a, b *T5 }
func(x int, y float64) *[]string, func(int, float64) (result *[]string), dan A5
----

`B0` dan `B1` berbeda karena mereka adalah tipe baru yang dibuat dengan
<<Type_definitions,definisi tipe>>
yang berbeda;
`func(int, float64) *B0` dan `func(x int, y float64) *[]string`
adalah berbeda karena `B0` berbeda dari `[]string`.


[#Assignability]
===  _Assignability_ (Penempatan)

Sebuah nilai `x` bisa _ditempatkan_ ke sebuah
<<Variables,variabel>>
bertipe `T` ("x bisa diisi ke T") jika salah satu kondisi berikut berlaku:

*  tipe x identik dengan `T`.
*  tipe x yaitu `V`, `V` dan `T` memiliki
   <<Types,tipe dasar>>
   yang sama dan paling tidak salah satu dari `V` atau `T` bukanlah
   tipe
   <<Type_definitions,tipe terdefinisi>>.
*  `T` adalah tipe interface dan `x`
   <<Interface_types,mengimplementasikan>>
   `T`
*  `x` adalah nilai channel dua arah, `T` bertipe channel, bila tipe `x` dari
   yaitu `V` dan `T` memiliki tipe elemen yang sama, dan paling tidak salah
   satu dari `V` atau `T` bukanlah tipe terdefinisi.
*  `x` adalah `nil` dan `T` bertipe pointer, fungsi, slice, map, channel, atau
   interface.
*  `x` adalah sebuah
   <<Constants,konstan>>
   <<Representability,direpresentasikan>>
   dengan nilai bertipe `T`.


[#Representability]
===  _Representability_

Sebuah
<<Constants,konstan>>
`x` bisa direpresentasikan oleh sebuah nilai bertipe `T` jika salah satu
kondisi berikut berlaku:

*  `x` ada dalam kumpulan nilai
   <<Types,yang ditentukan>>
   oleh `T`.
*  `T` bertipe _floating-point_ dan `x` bisa dibulatkan ke presisi `T` tanpa
   _overflow_.
   Pembulatan menggunakan aturan pembulatan-genap dari IEEE 754 namun dengan
   IEEE nol negatif disederhanakan menjadi unsigned nol.
   Ingatlah bahwa nilai konstan tidak pernah menghasilkan IEEE nol negatif,
   NaN, atau tanpa batas.
*  `T` bertipe complex, dan
   <<Complex_numbers,komponen>> x `real(x)` dan `imag(x)` bisa
   direpresentasikan oleh nilai tipe komponen dari `T` (`float32` atau
   `float64`).

----
x                   T           x bisa direpresentasikan oleh nilai T karena

'a'                 byte        97 ada dalam kumpulan nilai byte
97                  rune        rune adalah alias untuk int32, dan 97 ada dalam kumpulan integer 32-bit
"foo"               string      "foo" ada dalam kumpulan nilai string
1024                int16       1024 ada dalam kumpulan integer 16-bit
42.0                byte        42 ada dalam kumpulan unsigned integer 8-bit
1e10                uint64      10000000000 ada dalam kumpulan unsigned integer 64-bit
2.718281828459045   float32     2.718281828459045 dibulatkan ke 2.7182817 yang ada dalam kumpulan nilai float32
-1e-1000            float64     -1e-1000 dibulatkan ke IEEE -0.0 yang kemudian disederhanakan menjadi 0.0
0i                  int         0 adalah nilai integer
(42 + 0i)           float32     42.0 (dengan bagian imajiner nol) ada dalam kumpulan nilai float32
----

----
x                   T           x tidak direpresentasikan oleh nilai T karena

0                   bool        0 tidak ada dalam kumpulan nilai boolean
'a'                 string      'a' adalah rune, ia tidak ada dalam kumpulan nilai string
1024                byte        1024 bukan berada dalam kumpulan unsigned integer 8-bit
-1                  uint16      -1 bukan berada dalam kumpulan unsigned integer 16-bit
1.1                 int         1.1 bukanlah nilai integer
42i                 float32     (0 + 42i) bukan berada dalam kumpulan nilai float32
1e1000              float64     1e1000 menjadi overflow ke IEEE +Inf setelah pembulatan
----


[#Blocks]
==  Blok

Sebuah blok yaitu seurutan deklarasi dan perintah, yang bisa saja kosong, di
antara tanda kurung kurawal.

----
Block = "{" StatementList "}" .
StatementList = { Statement ";" } .
----

Selain blok eksplisit dalam kode, ada beberapa blok implisit:

.  _blok universal_ melingkupi semua teks kode Go
.  Setiap
   <<Packages,paket>>
   memiliki sebuah _blok paket_ yang berisi semua teks sumber kode Go untuk
   paket tersebut
.  Setiap berkas memiliki sebuah _blok berkas_ berisi teks sumber kode Go
   dalam berkas tersebut
.  Setiap perintah
   <<If_statements,"if">>,
   <<For_statements,"for">>, dan
   <<Switch_statements,"switch">>
   dianggap berada dalam blok implisit-nya sendiri.
.  Setiap "case" di dalam perintah
   <<Switch_statements,"switch">>
   atau
   <<Select_statements,"select">>
   bersifat sebagai blok implisit.

Sekumpulan blok yang bersarang mempengaruhi
<<Declarations_and_scope,skop>>.


[#Declarations_and_scope]
==  Deklarasi dan skop

Sebuah _deklarasi_ mengikat pengidentifikasi yang tidak
<<Blank_identifier,kosong>>
terhadap sebuah
<<Constant_declarations,konstan>>,
<<Type_declarations,tipe>>,
<<Variable_declarations,variabel>>,
<<Function_declarations,fungsi>>,
<<Labeled_statements,label>>, atau
<<Import_declarations,paket>>.
Setiap identifikasi dalam sebuah program haruslah dideklarasikan.
Tidak ada pengidentifikasi yang bisa dideklarasikan dua kali dalam blok yang
sama, dan tidak ada pengidentifikasi bisa dideklarasikan dalam blok berkas dan
paket.

<<Blank_identifier,Pengidentifikasi kosong>>
bisa digunakan seperti pengidentifikasi lainnya dalam sebuah deklarasi, namun
tidak mengakibatkan pengikatan sehingga tidak dideklarasi.
Dalam blok paket, pengidentifikasi `init` hanya bisa digunakan untuk deklarasi
<<Package_initialization,fungsi `init`>>,
dan seperti pengidentifikasi kosong ia tidak menghasilkan pengikatan yang
baru.

----
Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
----

_Ruang lingkup_ dari sebuah deklarasi pengidentifikasi yaitu betas dari teks
sumber kode di mana pengidentifikasi menyatakan konstan, tipe, variabel,
fungsi, label, atau paket yang ditentukan.

Go secara leksikal dibatasi menggunakan
<<Blocks,blok-blok>>:

1.  Skop dari
    <<Predeclared_identifiers,pengidentifikasi pra-deklarasi>>
    yaitu blok universal.
2.  Skop dari pengidentifikasi yang menyatakan sebuah konstan, tipe, variabel,
    atau fungsi (tetapi tidak method) yang dideklarasikan pada bagian atas
    (di luar fungsi apa pun) adalah blok paket.
3.  Skop dari nama paket yang diimpor yaitu blok berkas yang berisi deklarasi
    impor.
4.  Skop dari pengidentifikasi yang menyatakan penerima method, parameter
    fungsi, atau variabel kembalian yaitu badan dari fungsi.
5.  Skop dari konstan atau variabel yang dideklarasikan dalam fungsi dimulai
    dari ConstSpec atau VarSpec (ShortVarDecl untuk deklarasi variabel
    singkat) dan berakhir pada blok yang mengandungnya.
6.  Skop dari pengidentifikasi tipe yang dideklarasikan dalam sebuah fungsi
    dimulai dari pengidentifikasi dalam TypeSpec dan berakhir pada blok yang
    mengandungnya.

Pengidentifikasi yang dideklarasikan dalam sebuah blok bisa dideklarasikan
kembali di dalam blok sebelah dalam.
Saat pengidentifikasi dari deklarasi di dalam skop, ia menyatakan entitas yang
dideklarasikan oleh deklarasi di dalamnya.

<<Package_clause,Klausa paket>> bukanlah sebuah deklarasi;
nama paket tidak muncul dalam skop manapun.
Tujuan klausa paket yaitu untuk mengidentifikasi berkas berada dalam
<<Packages,paket>>
yang sama dan untuk menentukan nama paket untuk deklarasi impor.


[#Label_scopes]
===  Skop label

Label dideklarasikan oleh
<<Labeled_statements,perintah label>>
dan digunakan dalam perintah
<<Break_statements,"break">>,
<<Continue_statements,"continue">>,
dan
<<Goto_statements,"goto">>.
Adalah ilegal mendefinisikan sebuah label yang tidak pernah digunakan.
Berbeda dengan pengidentifikasi lainnya, label tidaklah dibatasi oleh skip dan
tidak konflik dengan pengidentifikasi yang bukan label.
Skop dari label yaitu badan dari fungsi di mana ia dideklarasikan dan tidak
mengikutkan badan dari fungsi yang bersarang.


[#Blank_identifier]
===  Pengidentifikasi kosong

_Pengidentifikasi kosong_ direpresentasikan oleh karakter garis bawah `_`.
Ia berfungsi sebagai penampung anonim bukan sebagai pengidentifikasi biasa
(yang bukan kosong) dan memiliki arti khusus dalam
<<Declarations_and_scope,deklarasi>>,
seperti sebuah
<<Operands,operan>>,
dan dalam
<<Assignments,penempatan>>.


[#Predeclared_identifiers]
===  Pengidentifikasi pradeklarasi

Pengidentifikasi berikut secara implisit dideklarasikan dalam
<<Blocks,blok universal>>:

----
Tipe:
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

Konstan:
	true false iota

Nilai kosong:
	nil

Fungsi:
	append cap close complex copy delete imag len
	make new panic print println real recover
----


[#Exported_identifiers]
===  Pengidentifikasi yang diekspor

Sebuah pengidentifikasi bisa _diekspor_ untuk membolehkan akses kepadanya dari
paket lainnya.
Pengidentifikasi diekspor jika:

1.  Karakter pertama dari nama pengidentifikasi adalah huruf besar Unicode
    (kelas Unicode "Lu"); dan
2.  Pengidentifikasi dideklarasikan dalam
    <<Blocks,blok paket>>
    atau ia merupakan
    <<Struct_types,nama field>>
    atau
    <<MethodName,nama method>>.

Pengidentifikasi lainnya tidak diekspor.


[#Uniqueness_of_identifiers]
===  Keunikan pengidentifikasi

Diberikan sekumpulan pengidentifikasi, sebuah pengidentifikasi dikatakan
_unik_ jika ia _berbeda_ dari yang lainnya dalam kumpulan tersebut.
Dua pengidentifikasi adalah berbeda jika mereka dieja secara berbeda, atau
jika mereka muncul di
<<Packages,paket>>
yang berbeda dan tidak
<<Exported_identifiers,diekspor>>.
Selain itu, mereka adalah pengidentifikasi yang sama.


[#Constant_declarations]
===  Deklarasi konstan

Deklarasi konstan mengikat sejumlah pengidentifikasi (nama-nama dari konstan)
terhadap nilai dari daftar dari
<<Constant_expressions,ekspresi konstan>>.
Jumlah pengidentifikasi harus sama dengan jumlah ekspresi, dan
pengidentifikasi ke-_n_ di bagian kiri terikat ke nilai dari ekspresi ke-_n_
di bagian kanan.

----
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .
----

Jika tipe didefinisikan, semua konstan memakai tipe tersebut, dan ekspresi
nilai haruslah
<<Assignability,dapat di-assign>>
ke tipe tersebut.
Jika tipe diindahkan, maka konstan memiliki tipe berdasarkan ekspresi.
Jika nilai ekspresi adalah
<<Constants,konstan>>
tanpa tipe, maka konstan tetap tanpa tipe dan pengidentifikasi konstan
menyatakan nilai konstan.
Misalnya, jika ekspresi adalah literal _floating-point_, pengidentifikasi
konstan menyatakan sebuah konstan _floating-point_, bahkan bila bagian pecahan
adalah nol.

----
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // konstan floating-point tanpa tipe
const (
	size int64 = 1024
	eof        = -1  // konstan integer tanpa tipe
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", konstan integer dan
string tanpa tipe
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
----

Dalam deklarasi `const` dengan tanda kurung, daftar ekspresi bisa diindahkan
kecuali ConstSpec yang pertama.
Daftar kosong seperti ini sama saja dengan penggantian tekstual dari daftar
ekspresi pertama yang tidak kosong dan tipenya jika ada.
Mengindahkan daftar ekspresi maka sama saja dengan mengulang daftar
sebelumnya.
Jumlah pengidentifikasi harus sama dengan jumlah ekspresi pada daftar
sebelumnya.
Bersama dengan
<<Iota,`iota` konstan generator>>
mekanisme ini membolehkan deklarasi ringan dari nilai berurutan:

----
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // this constant is not exported
)
----

[#Iota]
===  Iota

Di dalam sebuah
<<Constant_declarations,deklarasi konstan>>,
pengidentifikasi `iota` merepresentasikan
<<Constants,konstan>>
integer tanpa-tipe beriringan.
Nilainya yaitu indeks dari
<<ConstSpec,ConstSpec>>
dalam deklarasi konstan tersebut, dimulai dari nol.
Ia bisa digunakan untuk membentuk sekumpulan konstan yang berhubungan:

----
const (
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 << iota  // a == 1  (iota == 0)
	b = 1 << iota  // b == 2  (iota == 1)
	c = 3          // c == 3  (iota == 2, tidak terpakai)
	d = 1 << iota  // d == 8  (iota == 3)
)

const (
	u         = iota * 42  // u == 0     (konstan integer tanpa tipe)
	v float64 = iota * 42  // v == 42.0  (konstan float64)
	w         = iota * 42  // w == 84    (konstan integer tanpa tipe)
)

const x = iota  // x == 0
const y = iota  // y == 0
----

Secara definisi, penggunaan `iota` berulang kali di dalam ConstSpec yang sama
memiliki nilai yang sama:

----
const (
	bit0, mask0 = 1 << iota, 1<<iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)
	bit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)
	_, _                                  //                        (iota == 2, tak terpakai)
	bit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3)
)
----

Contoh terakhir menggunakan
<<Constant_declarations,pengulangan implisit>>
dari daftar ekspresi yang tidak kosong.


[#Type_declarations]
===  Deklarasi tipe

Sebuah deklarasi tipe mengikat pengidentifikasi, _name tipe_, ke sebuah
<<Types,tipe>>
Deklarasi tipe ada dua bentuk: deklarasi alias dan definisi tipe.

----
TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec = AliasDecl | TypeDef .
----

====  Deklarasi alias

Deklarasi alias mengikat pengidentifikasi ke tipe yang diberikan.

----
AliasDecl = identifier "=" Type .
----

Dalam
<<Declarations_and_scope,skop>>
pengidentifikasi, ia berfungsi sebagai _alias_ dari tipe.

----
type (
	nodeList = []*Node  // nodeList dan []*Node adalah tipe yang identik
	Polar    = polar    // Polar dan polar menyatakan tipe yang identik
)
----

====  Definisi tipe

Sebuah definisi tipe membuat tipe yang baru dan berbeda dengan
<<Types,tipe dasar>>
dan operasi yang sama dengan tipe yang diberikan, dan mengikat
pengidentifikasi padanya.

----
TypeDef = identifier Type .
----

Tipe yang baru disebut _tipe terdefinisi_.
Ia
<<Type_identity,berbeda>>
dengan tipe lainnya, termasuk dari tipe yang membentuknya.

----
type (
	Point struct{ x, y float64 }  // Point dan struct{ x, y float64 }
	                              // adalah tipe yang berbeda.
	polar Point                   // polar dan Point menyatakan tipe yang
	                              // berbeda.
)

type TreeNode struct {
	left, right *TreeNode
	value *Comparable
}

type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
----

Tipe terdefinisi bisa memiliki
<<Method_declarations,method>>
yang berasosiasi dengannya.
Ia tidak mewariskan method apa pun dari tipe yang diikat, namun
<<Method_sets,kumpulan method>>
dari tipe interface atau elemen dari tipe komposit tidak berubah:

----
// Mutex adalah tipe data dengan dua method, Lock dan Unlock.
type Mutex struct         { /* field dari Mutex */ }
func (m *Mutex) Lock()    { /* implementasi Lock */ }
func (m *Mutex) Unlock()  { /* implementasi Unlock */ }

// NewMutex memiliki komposisi yang sama dengan Mutex namun set method-nya
// kosong.
type NewMutex Mutex

// Kumpulan method dari tipe dasar PtrMutex yaitu *Mutex tetap tidak berubah,
// namun kumpulan method dari PtrMutex adalah kosong.
type PtrMutex *Mutex

// Kumpulan method dari *PrintableMutex berisi method Lock dan Unlock terikat
// dari field tertanamnya Mutex.
type PrintableMutex struct {
	Mutex
}

// MyBlock yaitu tipe interface yang memiliki kumpulan method yang sama dengan
// Block.
type MyBlock Block
----

Definisi tipe bisa digunakan untuk mendefinisikan tipe boolean, numerik, atau
string yang berbeda dan mengasosiasikan method dengan tipe tersebut:

----
type TimeZone int

const (
	EST TimeZone = -(5 + iota)
	CST
	MST
	PST
)

func (tz TimeZone) String() string {
	return fmt.Sprintf("GMT%+dh", tz)
}
----


[#Variable_declarations]
===  Deklarasi variabel

Deklarasi variabel membuat satu atau lebih
<<Variables,variabel>>,
mengikat pengidentifikasi yang berkorespondensi kepadanya, dan memberikan
setiap tiap-tiapnya sebuah tipe dan nilai awal.

----
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
----

----
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // pencarian map; hanya tertarik pada "found"
----

Jika sebuah daftar ekspresi diberikan, maka variabel diinisiasi dengan
ekspresi mengikuti aturan-aturan
<<Assignments,penempatan>>.
Selain itu, setiap variabel diinisiasi dengan
<<The_zero_value,nilai kosong>>
nya.

Jika sebuah tipe diberikan, setiap variabel diberikan tipe tersebut.
Selain itu, setiap variabel diberikan tipe dari nilai inisiasi pada
penempatan.
Jika nilai tersebut sebuah konstan tak bertipe, maka pertama kali ia secara
implisit
<<Conversions,dikonversi>>
ke
<<Constants,tipe defaultnya>>;
misalnya, jika variabel adalah nilai boolean tanpa tipe, maka ia secara
implisit dikonversi ke tipe `bool`.
Nilai `nil` tidak bisa digunakan untuk menginisiasi sebuah variabel tanpa tipe
eksplisit.

----
var d = math.Sin(0.5)  // d adalah float64
var i = 42             // i adalah int
var t, ok = x.(T)      // t adalah T, ok adalah bool
var n = nil            // ilegal
----

Batasan implementasi: _Compiler_ bisa mengilegalkan deklarasi variabel di
dalam
<<Function_declarations,badan fungsi>>
jika variabel tersebut tidak pernah digunakan.


[##Short_variable_declarations]
===  Deklarasi variabel singkat

_Deklarasi variabel singkat_ menggunakan sintaks:

----
ShortVarDecl = IdentifierList ":=" ExpressionList .
----

Ia merupakan cara cepat
<<Variable_declarations,mendeklarasikan variabel>>
dengan ekspresi inisiasi tanpa tipe:

----
"var" IdentifierList = ExpressionList .
----

----
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w, _ := os.Pipe()  // os.Pipe() mengembalikan pasangan File dan error
_, y, _ := coord(p)   // coord() mengembalikan tiga nilai; yang diambil hanya koordinat y
----

Tidak seperti deklarasi variabel, deklarasi variabel singkat bisa
_mendeklarasi ulang_ variabel setelah ia dideklarasikan sebelumnya di dalam
blok yang sama (atau dari daftar parameter jika blok adalah badan fungsi)
dengan tipe yang sama, dan paling tidak salah satu dari variabel yang tidak
<<Blank_identifier,kosong>>
adalah variabel baru.
Akibatnya, deklarasi ulang hanya dapat muncul dalam sebuah deklarasi singkat
multi-variabel.
Deklarasi ulang tidak menyebabkan munculnya variabel baru; ia hanya
menempatkan nilai baru ke variabel aslinya.

----
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // deklarasi ulang pada offset
a, a := 1, 2                              // ilegal: deklarasi ganda dari a
                                          // atau tidak ada variabel baru bila
					  // a dideklarasikan sebelumnya.
----

Deklarasi variabel singkat hanya bisa muncul dalam fungsi.
Dalam beberapa konteks seperti inisiasi untuk perintah
<<If_statements,"if">>,
<<For_statements,"for">>, atau
<<Switch_statements,"switch">>,
mereka dapat digunakan untuk mendeklarasikan variabel lokal sementara.


[#Function_declarations]
===  Deklarasi fungsi

Deklarasi fungsi mengikat pengidentifikasi, _nama fungsi_, ke sebuah fungsi.

----
FunctionDecl = "func" FunctionName Signature [ FunctionBody ] .
FunctionName = identifier .
FunctionBody = Block .
----

Jika
<<Function_types,fungsi>>
mengembalikan nilai, daftar perintah pada badan fungsi harus berakhir dengan
<<Terminating_statements,perintah terminasi>>.

----
func IndexRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	// tidak valid: perintah return tidak ada.
}
----

Deklarasi fungsi bisa tanpa badan.
Deklarasi seperti ini menyediakan _signature_ untuk sebuah fungsi yang
diimplementasikan di luar Go, seperti rutin _assembly_.

----
func min(x int, y int) int {
	if x < y {
		return x
	}
	return y
}

func flushICache(begin, end uintptr)  // diimplementasikan di luar.
----


[#Method_declarations]
===  Deklarasi method

Sebuah method yaitu sebuah
<<Function_declarations,fungsi>>
dengan sebuah _receiver_ (penerima).
Deklarasi method mengikat pengidentifikasi, _nama method_, terhadap sebuah
method, dan mengasosiasikan method tersebut dengan _tipe dasar_ _receiver_.

----
MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .
Receiver   = Parameters .
----

Si _receiver_ dispesifikasikan lewat bagian parameter sebelum nama method.
Bagian parameter tersebut harus mendeklarasikan sebuah parameter tunggal, yang
disebut juga dengan _receiver_.
Tipe _receiver_ haruslah tipe
<<Type_definitions,terdefinisi>>
`T` atau sebuah pointer ke tipe terdefinisi `T`.
`T` disebut juga _tipe dasar receiver_.
Tipe dasar _receiver_ tidak bisa berupa tipe pointer atau interface dan ia
harus didefinisikan di dalam paket yang sama dengan method.
Method tersebut dikatakan _terikat_ dengan tipe dasar _receiver_ dan nama
method hanya dapat dipanggil oleh
<<Selectors,selector>>
untuk tipe `T` atau `*T`.

Pengidentifikasi _receiver_ haruslah
<<Uniqueness_of_identifiers,unik>>
dalam penanda method.
Jika nilai _receiver_ tidak dipakai di dalam badan method, maka
pengidentifikasinya bisa dihilangkan dalam deklarasi.
Hal yang sama berlaku secara umum terhadap parameter dari fungsi dan method.

Untuk tipe dasar yang sama, nama-nama dari method haruslah unik.
Jika tipe dasar adalah sebuah
<<Struct_types,tipe struct>>,
nama method dan field haruslah berbeda.

Diberikan sebuah tipe `Point`, deklarasi berikut

----
func (p *Point) Length() float64 {
	return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
	p.x *= factor
	p.y *= factor
}
----

mengikat method `Length()` dan `Scale()`, dengan _receiver_ bertipe `*Point`,
terhadap tipe dasar `Point`.

Tipe dari sebuah method yaitu tipe dari fungsi dengan _receiver_ sebagai
argumen yang pertama.
Misalnya, method `Scale()` bertipe

----
func(p *Point, factor float64)
----

Namun, fungsi yang dideklarasikan seperti di atas bukanlah sebuah method.


[#Expressions]
==  Ekspresi

Sebuah ekspresi menentukan komputasi dari sebuah nilai dengan menerapkan
operator dan fungsi terhadap operan.


#Operands
===  Operan-operan

Operan menyatakan nilai elementer dalam sebuah ekspresi.
Sebuah operan bisa jadi literal, sebuah pengindentifikasi bukan-
<<Blank_identifier,kosong>> (bisa saja
/ref/spec#Qualified_identifiers[terbatas])
yang menyatakan sebuah
<<Constant_declarations,konstan>>,
<<Variable_declarations,variabel>>,
atau
<<Function_declarations,fungsi>>,
atau ekspresi dalam tanda kurung.

<<Blank_identifier,Pengidentifikasi kosong>>
bisa muncul sebaga operan hanya pada bagian kiri dari sebuah
<<Assignments,penempatan>>.

----
Operand     = Literal | OperandName | "(" Expression ")" .
Literal     = BasicLit | CompositeLit | FunctionLit .
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
OperandName = identifier | QualifiedIdent.
----


[#Qualified_identifiers]
===  Pengidentifikasi terbatas

Sebuah pengidentifikasi terbatas yaitu sebuah pengidentifikasi yang dibatasi
oleh awalan nama paket.
Nama paket dan pengidentifikasi haruslah tidak
<<Blank_identifier,kosong>>.

----
QualifiedIdent = PackageName "." identifier .
----

Pengidentifikasi terbatas mengakses pengidentifikasi di paket yang berbeda,
yang harus
<<Import_declarations,diimpor>>.
Si pengidentifikasi haruslah
<<Exported_identifiers,diekspor>>
dan dideklarasikan dalam
<<Blocks,blok paket>>
dari paket tersebut.

----
math.Sin	// menyatakan fungsi Sin dalam paket math.
----

[#Composite_literals]
===  Literal komposit

Literal komposit membentuk nilai-nilai untuk struct, array, slice, dan map; dan
membuat sebuah nilai baru setiap kali ia dievaluasi.
Ia dibentuk dari tipe dari literal diikuti oleh daftar elemen yang dibatasi oleh
kurung kurawal.
Setiap elemen bisa diawali dengan kunci yang berkorespondensi.

----
CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName .
LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
ElementList   = KeyedElement { "," KeyedElement } .
KeyedElement  = [ Key ":" ] Element .
Key           = FieldName | Expression | LiteralValue .
FieldName     = identifier .
Element       = Expression | LiteralValue .
----

Tipe dasar dari LiteralType haruslah sebuah tipe struct, array, slice, atau
map (gramatika memaksa batasan ini kecuali bisa tipe diberikan sebagai sebuah
TypeName).
Tipe dari elemen dan kunci harus bisa
<<Assignability,ditempatkan>>
ke tipe field, elemen, dan kunci dari tipe literal yang bersangkutan;
tidak ada konversi tambahan.
Kunci diinterpretasikan sebagai sebuah nama field untuk literal struct, sebuah
indeks pada literal array dan slice, dan sebuah kunci untuk literal map.
Untuk literal map, semua elemen harus memiliki sebuah kunci.
Adalah sebuah kesalahan bila menspesifikasikan beragam lemen dengan nama field
yang sama atau nilai key menggunakan konstan.
Untuk kunci map yang tidak-konstan, lihat bagian pada
<<Order_of_evaluation,urutan evaluasi>>.

Untuk literal struct aturan-aturan berikut berlaku:

*  Sebuah kunci haruslah nama field yang dideklarasikan dalam tipe struct.
*  Daftar elemen yang tidak memiliki kunci haruslah mendaftarkan setiap elemen
   pada field struct dengan urutan sebagaimana ia dideklarasikan.
*  Jika elemen memiliki key, maka semua elemen haruslah memiliki key.
*  Daftar elemen yang mengandung kunci tidak harus memiliki elemen untuk
   setiap field struct.
   Field yang diindahkan akan mendapatkan nilai kosong untuk field tersebut.
*  Literal bisa mengindahkan daftar elemen; literal tersebut dievaluasi menjadi
   nilai kosong untuk tipenya.
*  Adalah sebuah kesalahan bila menspesifikasikan sebuah elemen untuk field
   yang tidak diekspor dari sebuah struct yang dimiliki oleh paket yang
   berbeda.

Diberikan deklarasi berikut

----
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
----

kita bisa menulis

----
origin := Point3D{}                            // nilai kosong untuk Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // nilai kosong untuk line.q.x
----

Untuk array dan slice, aturan-aturan berikut berlaku:

*  Setiap elemen memiliki indeks integer yang menandakan posisinya dalam
   array.
*  Sebuah elemen dengan sebuah kunci menggunakan kunci tersebut sebagai
   indeksnya.
   Kunci tersebut haruslah konstan bukan-negatif yang
   <<Representability,dapat direpresentasikan>>
   oleh nilai bertipe `int`; dan jika kunci tersebut bertipe maka harus
   bertipe integer.
*  Sebuah elemen tanpa kunci menggunakan indeks elemen sebelumnya ditambah
   satu.
   Jika elemen pertama tanpa kunci, indeksnya adalah nol.

<<Address_operators,Mengambil alamat>>
dari literal komposit menghasilkan sebuah pointer ke sebuah
<<Variables,variabel>>
unik yang diinisiasi dengan nilai literal.

----
var pointer *Point3D = &Point3D{y: 1000}
----

Ingatlah bahwa
<<The_zero_value,nilai kosong>> dari sebuah tipe
slice atau map tidak sama dengan slice atau yang map diinisiasi dengan nilai
kosong dari tipe yang sama.
Akibatnya, mengambil alamat dari literal komposit dari sebuah slice atau map
yang kosong tidak sama efeknya dengan mengalokasikan slice atau map yang baru
dengan
<<Allocation,new>>.

----
p1 := &[]int{}    // p1 menunjuk ke slice kosong yang diinisiasi dengan nilai
                  // []int{} dan panjang 0
p2 := new([]int)  // p2 menunjuk ke slice yang belum diinisiasi dengan nilai
                  // nil dan panjang 0.
----

Panjang dari literal array yaitu panjang yang dispesifikasikan pada literal
tipe.
Jika jumlah elemen yang diberikan kecil dari panjangnya, elemen-elemen yang
hilang di set dengan nilai kosong dari tipe elemen array.
Adalah sebuah kesalahan mengisi elemen dengan nilai indeks di luar rentang
indeks dari array.
Notasi ... menspesifikasikan panjang array yang sama dengan maksimum elemen
ditambah satu.

----
buffer := [10]string{}             // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6
days := [...]string{"Sat", "Sun"}  // len(days) == 2
----

Literal slice mendeskripsikan keseluruhan literal array di belakangnya.
Maka panjang dan kapasitas dari literal slice yaitu indeks elemen maksimum
ditambah satu.
Literal slice memiliki bentuk

----
[]T{x1, x2, … xn}
----

yang merupakan cara singkat untuk operasi slice yang diterapkan pada sebuah
array:

----
tmp := [n]T{x1, x2, … xn}
tmp[0 : n]
----

Dalam sebuah literal komposit dari array, slice, atau map bertipe T, elemen
atau kunci map yang juga literal komposit bisa mengindahkan literal tipe jika
ia identik dengan tipe elemen atau key dari T.
Hal yang sama, elemen atau kunci yang merupakan alamat dari literal komposit
bisa mengindahkan `&T` bila tipe elemen atau kunci adalah `*T`.

----
[...]Point{{1.5, -3.5}, {0, 0}}     // sama dengan [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}          // sama dengan [][]int{[]int{1, 2, 3}, []int{4, 5}}
[][]Point{{{0, 1}, {1, 2}}}         // sama dengan [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}
map[string]Point{"orig": {0, 0}}    // sama dengan map[string]Point{"orig": Point{0, 0}}
map[Point]string{{0, 0}: "orig"}    // sama dengan map[Point]string{Point{0, 0}: "orig"}

type PPoint *Point
[2]*Point{{1.5, -3.5}, {}}          // sama dengan [2]*Point{&Point{1.5, -3.5}, &Point{}}
[2]PPoint{{1.5, -3.5}, {}}          // sama dengan [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})}
----

Ambiguitas muncul saat literal komposit menggunakan bentuk TypeName dari
LiteralType muncul sebagai operan antara
<<Keywords,kata kunci>>
dan kurung buka dari blok perintah "if", "for", atau "switch", dan literal
komposit tidak ditutup dalam tanda kurung, kurung siku, atau kurung kurawal.
Dalam kasus langka ini, kurung buka dari literal dengan keliru dianggap
sebagai yang membuka perintah blok.
Untuk mengatasi kebingungan ini, literal komposit harus muncul dalam tanda
kurung.

----
if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }
----

Contoh literal array, slice, dan map yang valid:

----
// daftar bilangan prima
primes := []int{2, 3, 5, 7, 9, 2147483647}

// vowels[ch] adalah true jika ch adalah huruf vokal.
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// frekuensi dalam Hz untuk skala yang sama (A4 = 440Hz)
noteFrequency := map[string]float32{
	"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
	"G0": 24.50, "A0": 27.50, "B0": 30.87,
}
----


[#Function_literals]
===  Literal fungsi

Sebuah literal fungsi merepresentasikan sebuah
<<Function_declarations,fungsi>>
anonim.

----
FunctionLit = "func" Signature FunctionBody .
----

----
func(a, b int, z float64) bool { return a*b < int(z) }
----

Sebuah literal fungsi bisa ditempatkan ke sebuah variabel atau langsung
dipanggil.

----
f := func(x, y int) int { return x + y }
func(ch chan int) { ch <- ACK }(replyChan)
----

Literal fungsi adalah _closure_: fungsi yang bisa mengacu ke variabel-variabel
yang didefinisikan sebelum fungsi.
Variabel tersebut dapat diakses antara fungsi dan literal fungsi, dan variabel
tersebut bertahan selama mereka dapat diakses.


[#Primary_expressions]
===  Ekspresi dasar

Ekspresi dasar yaitu operan-operan untuk ekspresi _unary_ dan binari.

----
PrimaryExpr =
	Operand |
	Conversion |
	MethodExpr |
	PrimaryExpr Selector |
	PrimaryExpr Index |
	PrimaryExpr Slice |
	PrimaryExpr TypeAssertion |
	PrimaryExpr Arguments .

Selector       = "." identifier .
Index          = "[" Expression "]" .
Slice          = "[" [ Expression ] ":" [ Expression ] "]" |
                 "[" [ Expression ] ":" Expression ":" Expression "]" .
TypeAssertion  = "." "(" Type ")" .
Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
----

----
x
2
(s + ".txt")
f(3.1415, true)
Point{1, 2}
m["foo"]
s[i : j + 1]
obj.color
f.p[i].x()
----


[#Selectors]
===  Selector

Untuk sebuah
<<Primary_expressions,ekspresi dasar>>
`x` yang bukan sebuah
<<Package_clause,nama paket>>,
_ekspresi selektor_

----
x.f
----

menyatakan field atau method `f` dari nilai `x` (atau terkadang `*x`; lihat di
bawah).
Pengidentifikasi `f` disebut (field atau method) _selector_;
ia tidak boleh sebuah
<<Blank_identifier,pengidentifikasi kosong>>.
Tipe dari ekspresi _selector_ yaitu tipe dari `f`.
Jika `x` adalah sebuah nama paket, lihat bagian
<<Qualified_identifiers[pengidentifikasi
terbatas].

Sebuah _selector_ `f` bisa menyatakan sebuah field atau method `f` dari sebuah
tipe `T`, atau ia bisa mengacu pada sebuah field atau method `f` dari
<<Struct_types,field tertanam>>
dari `T`.
Jumlah field tertanam yang dijajaki sampai ke `f` disebut dengan _kedalaman_
dari `T`.
Kedalaman dari sebuah field atau method `f` yang dideklarasikan dalam `T`
adalah nol.
Kedalaman dari sebuah field atau method `f` yang dideklarasikan dalam field
`A` yang ditanam dalam `T` adalah kedalaman `f` dalam `A` ditambah satu.

Aturan-aturan berikut berlaku pada _selector_:

.  Untuk nilai `x` bertipe `T` atau `*T` yang mana `T` bukanlah sebuah tipe
   pointer atau interface, `x.f` menyatakan field atau method pada kedalaman
   paling dangkal dalam `T` yang mana `f` tersebut ada.
   Jika tidak ada
   <<Uniqueness_of_identifiers,satu f>>
   pada kedalaman terdangkal, ekspresi _selector_ tersebut adalah ilegal.
.  Untuk sebuah nilai `x` bertipe `I` yang mana `I` adalah sebuah tipe
   interface, `x.f` menyatakan method bernama `f` dari nilai dinamis `x`.
   Jika tidak ada method bernama `f` dalam
   <<Method_sets,kumpulan method>>
   dari `I`, ekspresi _selector_ tersebut adalah ilegal.
.  Sebagai pengecualian, jika tipe dari `x` merupakan tipe pointer
   <<Type_definitions,terdefinisi>>
   dan `(*x).f` adalah ekspresi _selector_ yang valid yang menyatakan sebuah
   field (bukan sebuah method), `x.f` adalah singkatan untuk `(*x).f`.
.  Pada kasus lainnya `x.f` adalah ilegal.
.  Jika `x` adalah tipe pointer dan bernilai `nil` dan `x.f` menyatakan sebuah
   field pada struct, mengisi atau mengambil nilai `x.f` mengakibatkan
   <<Run_time_panics,panik runtime>>.
.  Jika `x` bertipe interface dan bernilai `nil`,
   <<Calls,memanggil>>
   atau
   <<Method_values,mengevaluasi>>
   method `x.f` menyebakan
   <<Run_time_panics,panik runtime>>.

Sebagai contoh, dari deklarasi berikut:

----
type T0 struct {
	x int
}

func (*T0) M0()

type T1 struct {
	y int
}

func (T1) M1()

type T2 struct {
	z int
	T1
	*T0
}

func (*T2) M2()

type Q *T2

var t T2     // dengan t.T0 != nil
var p *T2    // dengan p != nil dan (*p).T0 != nil
var q Q = p
----

kita dapat menulis:

----
t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x

p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x

q.x          // (*(*q).T0).x        (*q).x adalah selector field yang valid

p.M0()       // ((*p).T0).M0()      M0 mendapatkan receiver *T0
p.M1()       // ((*p).T1).M1()      M1 mendapatkan receiver T1
p.M2()       // p.M2()              M2 mendapatkan receiver *T2
t.M2()       // (&t).M2()           M2 mendapatkan receiver *T2, lihat bagian tentang Pemanggilan
----

namun pernyataan berikut adalah invalid:

----
q.M0()       // (*q).M0 valid namun bukan sebuah selector field
----


[#Method_expressions]
===  Ekspresi method

Jika `M` ada dalam
<<Method_sets,kumpulan method>>
bertipe `T`, `T.M` adalah sebuah fungsi yang dapat dipanggil seperti fungsi
biasa dengan argumen yang sama dengan `M` yang diawali dengan argumen tambahan
yaitu _receiver_ dari method.

----
MethodExpr    = ReceiverType "." MethodName .
ReceiverType  = Type .
----

Misalkan sebuah struct bertipe `T` dengan dua method, `Mv`, dengan _receiver_
bertipe `T`; dan `Mp` dengan _receiver_ bertipe `*T`.

----
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // receiver berupa nilai
func (tp *T) Mp(f float32) float32 { return 1 }  // receiver berupa pointer

var t T
----

Ekspresi

----
T.Mv
----

menghasilkan sebuah fungsi yang sama dengan `Mv` namun dengan sebuah
_receiver_ eksplisit sebagai argumen pertama; dengan penanda

----
func(tv T, a int) int
----

Fungsi tersebut bisa dipanggil secara normal dengan _receiver_ eksplisit,
sehingga kelima pemanggilan berikut adalah sama:

----
t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f1 := T.Mv; f1(t, 7)
f2 := (T).Mv; f2(t, 7)
----

Hal yang sama, ekspresi berikut

----
(*T).Mp
----

menghasilkan sebuah nilai fungsi yang merepresentasikan `Mp` dengan penanda

----
func(tp *T, f float32) float32
----

Untuk sebuah method dengan _receiver_ nilai, kita dapat menurunkan sebuah
fungsi dengan _receiver_ pointer yang eksplisit, sehingga

----
(*T).Mv
----

menghasilkan sebuah nilai fungsi merepresentasikan `Mv` dengan penanda

----
func(tv *T, a int) int
----

Fungsi seperti ini secara tidak langsung lewat _receiver_ untuk membuat sebuah
nilai untuk dikirim sebagai _receiver_ pada method dibaliknya;
method tersebut tidak menimpa nilai yang alamatnya dikirim ke pemanggilan
fungsi.

Kasus terakhir, fungsi dengan _receiver_ berupa nilai untuk sebuah method
dengan _receiver_ berupa pointer, adalah ilegal karena method-method dengan
_receiver_ pointer tidak berada dalam kumpulan method dari tipe nilai.

Nilai-nilai fungsi yang diturunkan dari method dipanggil dengan sintaksis
pemanggilan fungsi biasa;
si _receiver_ diberikan sebagai argumen pertama pada pemanggilan.
Maka, diberikan `f := T.Mv`, `f` dipanggil dengan cara `f(t,7)` bukan
`t.f(7)`.
Untuk membentuk sebuah fungsi yang mengikat _receiver_, gunakan
<<Function_literals,literal fungsi>>
atau
<<Method_values,nilai method>>.

Adalah legal menurunkan sebuah nilai fungsi dari sebuah method bertipe
interface.
Hasil fungsinya menerima _receiver_ eksplisit dari tipe interface tersebut.


[#Method_values]
===   Nilai method

Jika ekspresi `x` memiliki tipe statis `T` dan `M` berada dalam
<<Method_sets,kumpulan method>>
dari tipe `T`, `x.M` disebut _nilai method_.
Nilai method `x.M` yaitu sebuah nilai fungsi yang dapat dipanggil dengan
argumen yang sama seperti memanggil method dari `x.M`.
Ekspresi `x` dievaluasi dan disimpan selama evaluasi dari nilai method;
salinan yang disimpan kemudian digunakan sebagai _receiver_ pada setiap
pemanggilan, yang bisa saja dieksekusi nantinya.

Tipe `T` bisa berupa tipe interface atau bukan interface.

Seperti yang telah didiskusikan dalam
<<Method_expressions,ekspresi method>>
di atas, misalnya ada sebuah struct bertipe `T` dengan dua method, `Mv`,
dengan _receiver_ bertipe `T`, dan `Mp`, dengan _receiver_ bertipe `*T`.

----
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T
var pt *T
func makeT() T
----

Ekspresi dari

----
t.Mv
----

menghasilkan sebuah nilai fungsi bertipe

----
func(int) int
----

Pemanggilan berikut adalah sama:

----
t.Mv(7)
f := t.Mv; f(7)
----

Hal yang sama, ekspresi berikut

----
pt.Mp
----

menghasilkan sebuah nilai fungsi bertip

----
func(float32) float32
----

Seperti halnya dengan
<<Selectors,selector>>,
sebuah referensi ke method yang bukan interface dengan _receiver_ nilai
menggunakan pointer akan secara otomatis membalikan pointer tersebut:
`pt.Mv` sama dengan `(*pt)Mv`.

Seperti halnya dengan
<<Calls,pemanggilan method>>,
sebuah referensi ke method yang bukan interface dengan _receiver_ pointer
menggunakan nilai beralamat akan secara otomatis mengambil alamat dari nilai
tersebut: `t.Mp` sama dengan `(&t).Mp`.

----
f := t.Mv; f(7)   // sama dengan t.Mv(7)
f := pt.Mp; f(7)  // sama dengan pt.Mp(7)
f := pt.Mv; f(7)  // sama dengan (*pt).Mv(7)
f := t.Mp; f(7)   // sama dengan (&t).Mp(7)
f := makeT().Mp   // tidak valid: hasil dari makeT() tidak beralamat.
----

Walaupun contoh di atas menggunakan tipe bukan interface, merupakan hal yang
legal untuk membuat sebuah nilai method dari nilai bertipe interface.

----
var i interface { M(int) } = myVal
f := i.M; f(7)  // sama dengan i.M(7)
----


[#Index_expressions]
===  Ekspresi indeks

Ekspresi dasar dari bentuk

----
a[x]
----

menyatakan elemen dari array, pointer ke array, slice, atau map `a` yang
diindeks oleh `x`.
Nilai `x` disebut dengan _indeks_ atau _map key_.
Aturan-aturan berikut berlaku:

Jika `a` bukan sebuah map:

*  indeks `x` haruslah bertipe integer atau konstanta tanpa tipe
*  indeks berupa konstanta haruslah tidak negatif dan
   <<Representability,dapat direpresentasikan>>
   oleh sebuah nilai bertipe `int`
*  indeks berupa konstanta yang tidak bertipe akan diberikan tipe `int`
*  indeks `x` berada _dalam rentang_ jika `0 <= x < len(a)`, selain itu _di
   luar rentang_

Untuk `a` dengan
<<Array_types,tipe Array>>
A:

*  sebuah indeks berupa
   <<Constants,konstanta>>
   haruslah dalam rentang
*  jika `x` di luar rentang pada saat _runtime_, sebuah
   <<Run_time_panics,panik runtime>>
   akan terjadi
*  `a[x]` adalah elemen array pada indeks `x` dan tipe dari `a[x]` yaitu
   elemen bertipe `A`

Untuk `a` sebagai
<<Pointer_types,pointer>>
ke tipe array:

*  `a[x]` adalah singkatan untuk `(*a)[x]`

Untuk `a` dengan
<<Slice_types,tipe slice>>
`S`:

*  jika `x` di luar rentang pada saat _runtime_,
   <<Run_time_panics,panik runtime>>
   akan terjadi
*  `a[x]` adalah elemen slice pada indeks `x` dan tipe dari `a[x]` yaitu
   elemen bertipe `S`

Untuk `a` dari
<<String_types,tipe string>>:

*  sebuah indeks berupa
   <<Constants,konstanta>>
   haruslah dalam rentang jika string `a` juga konstanta`
*  jika `x` di luar rentang pada saat _runtime_,
   <<Run_time_panics,panik runtime>>
   akan terjadi
*  `a[x]` adalah nilai byte bukan konstanta pada indeks `x` dan tipe dari
   `a[x]` adalah byte
*  `a[x]` tidak bisa ditimpa bila `a` adalah konstanta

Untuk `a` dari
<<Map_types,tipe map>>
`M`:

*  tipe `x` haruslah
   <<Assignability,bisa disimpan>>
   ke tipe key dari `M`
*  jika map berisi sebuah nilai dengan key `x`, `a[x]` adalah elemen map
   dengan key `x` dan tipe dari `a[x]` yaitu tipe elemen dari `M`
*  jika map adalah `nil` atau tidak mengandung nilai dengan key `x`, `a[x]`
   yaitu
   <<The_zero_value,nilai kosong>>
   dari tipe elemen dari `M`.

Selain itu `a[x]` adalah ilegal.

Ekspresi indeks dapat sebuah map bertipe `map[K]V` yang digunakan dalam sebuah
<<Assignments,penempatan>>
atau inisiasi dari bentuk khusus

----
v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]
----

menghasilkan sebuah nilai boolean tidak bertipe tambahan.
Nilai dari `ok` adalah `true` jika key `x` ada dalam map, dan `false` jika
tidak ada.

Menempatkan ke elemen map yang `nil` akan mengakibatkan
<<Run_time_panics,panik runtime>>.


[#Slice_expressions]
===  Ekspresi pemotongan

Ekspresi pemotongan membentuk sebuah substring atau slice dari sebuah string,
array, pointer ke array, atau slice.
Ada dua varian: bentuk sederhana yang menentukan batas bawah dan atas, dan
bentuk penuh yang juga menentukan batas dari kapasitas.


====   Ekspresi sederhana pemotongan

Untuk sebuah string, array, pointer ke array, atau slice `a`, ekspresi dasar

----
a[low : high]
----

membentuk sebuah substring atau slice.
Indeks `low` dan `high` memilih elemen mana dari operan `a` yang akan
dikembalikan.
Hasil kembaliannya akan memiliki indeks yang berawal dari 0 dan panjang sama
dengan `high - low`.
Setelah memotong array `a`

----
a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
----

slice `s` bertipe `[]int`, panjang 3, kapasitas 4, dan elemennya

----
s[0] == 2
s[1] == 3
s[2] == 4
----

Demi kemudahan, indeks-indeks tersebut bisa diindahkan.
Nilai indeks `low` yang diindahkan yaitu nol;
Nilai indeks `high` yang diindahkan yaitu panjang dari operan slice:

----
a[2:]  // sama dengan a[2 : len(a)]
a[:3]  // sama dengan a[0 : 3]
a[:]   // sama dengan a[0 : len(a)]
----

Jika `a` adalah pointer ke sebuah array, `a[low : high]` adalah singkatan
untuk `(*a)[low : high]`.

Untuk array atau string, indeks berada dalam rentang jika
`0 <= low <= high <= len(a)`, selain itu berarti _di luar rentang_.
Untuk slice, batas atas dari indeks yaitu kapasitas slice `cap(a)` bukan
panjangnya.
Indeks berupa
<<Constants,konstanta>>
haruslah tidak negatif dan
<<Representability,dapat direpresentasikan>>
oleh nilai bertipe `int`;
untuk array atau string konstanta, indeks dari konstanta haruslah berada dalam
rentang.
Jika kedua indeks adalah konstanta, keduanya haruslah memenuhi `low <= high`.
Jika indeks-indeks di luar rentang pada saat _runtime_,
<<Run_time_panics,panik runtime>>
terjadi.

Kecuali untuk
<<Constants,string tak bertipe>>,
jika operan pemotongan adalah sebuah string atau slice, hasil dari operasi
pemotongan adalah nilai non-konstanta bertipe `string`.
Jika opera pemotongan adalah sebuah array, maka harus dapat
<<Address_operators,memiliki alamat>>
dan hasil dari operasi pemotongan yaitu sebuah slice dengan tipe elemen yang
sama dengan array.

Jika operan slice dari sebuah ekspresi pemotongan yang valid adalah
sebuah slice yang `nil`, hasilnya yaitu sebuah slice `nil`.
Selain itu, jika hasilnya adalah sebuah slice, ia akan memiliki array dasar
yang sama dengan operan.

----
var a [10]int
s1 := a[3:7]   // array dasar dari s1 yaitu array a; &s1[2] == &a[5]
s2 := s1[1:4]  // array dasar dari s2 yaitu array dasar dari s1 yaitu array a;
               // &s2[1] == &a[5]
s2[1] = 42     // s2[1] == s1[2] == a[5] == 42; semuanya mengacu pada elemen
               // array dasar yang sama
----

====  Ekspresi pemotongan penuh

Untuk sebuah array, pointer ke array, atau slice `a` (tetapi bukan string),
ekspresi dasar

----
a[low : high : max]
----

membentuk sebuah slice dengan tipe yang sama, dan dengan panjang dan elemen
seperti pada ekspresi pemotongan sederhana `a[low : high]`.
Sebagai tambahan, ia mengontrol kapasitas slice kembalian dengan mensetnya
menjadi `max - low`.
Hanya indeks pertama yang boleh diindahkan;
yang bernilai dasar 0.
Setelah memotong array `a`

----
a := [5]int{1, 2, 3, 4, 5}
t := a[1:3:5]
----

slice `t` bertipe `[]int`, panjang 2, kapasitas 4, dan elemennya

----
t[0] == 2
t[1] == 3
----

Seperti pada ekspresi pemotongan sederhana, jika `a` adalah sebuah pointer ke
array, `a[low : high : max]` adalah singkatan dari `(*a)[low : high :max]`.
Jika operan pemotongan adalah sebuah array, maka haruslah
<<Address_operators,memiliki alamat>>.

Indeks-indeksnya berada _dalam rentang_ jika
`0 <= low <= high <= max <= cap(a)`,
selain itu adalah _di luar rentang_.
Indeks berupa
<<Constants,konstanta>>
haruslah tidak negatif dan
<<Representability,direpresentasikan>>
oleh sebuah nilai bertipe `int`;
untuk array, indeks konstanta haruslah juga berada dalam rentang.
Jika beberapa indeks adalah konstanta, konstanta tersebut haruslah dalam
rentang yang relatif terhadap satu sama lain.
Jika indeks-indeks di luar rentang pada saat _runtime_,
<<Run_time_panics,panik runtime>>
terjadi.


[#Type_assertions]
===  Asersi Tipe

Untuk sebuah ekspresi `x` dari
<<Interface_types,tipe interface>>
dan sebuah tipe `T`, ekspresi dasar berikut

----
x.(T)
----

menyatakan bahwa `x` tidak `nil` dan nilai yang tersimpan dalam `x` bertipe
`T`.
Notasi `x.(T)` disebut dengan _asersi tipe_.

Lebih tepatnya, jika `T` bukan bertipe interface, `x.(T)` menyatakan bahwa
tipe dinamis dari `x` adalah
<<Type_identity,identik>>
dengan tipe `T`.
Dalam kasus ini, `T` harus
<<Method_sets,mengimplementasikan>>
tipe (interface) dari `x`;
sebaliknya asersi tipe tidak valid karena tidak mungkin bagi `x` untuk
menyimpan nilai bertipe `T`.
Jika `T` adalah tipe interface, `x.(T)` menyatakan bahwa tipe dinamis dari `x`
mengimplementasikan interface `T`.

Jika asersi tipe berhasil, nilai dari ekspresi tersebut yaitu nilai yang
tersimpan dalam `x` dan tipenya yaitu `T`.
Jika asersi tipe gagal,
<<Run_time_panics,panik runtime>>
terjadi.
Dengan kata lain, walaupun tipe dinamis dari `x` diketahui pada saat
_runtime_, tipe dari `x.(T)` hanya diketahui sebagai `T` dalam program yang
benar.

----
var x interface{} = 7          // x bertipe dinamis int dan nilainya 7
i := x.(int)                   // i bertipe int dan bernilai 7

type I interface { m() }

func f(y I) {
	s := y.(string)        // ilegal: string tidak mengimplementasikan
	                       // I (method m tidak ada)
	r := y.(io.Reader)     // r bertipe io.Reader dan tipe dinamis dari y
	                       // harus mengimplementasikan I dan io.Reader
	…
}
----

Asersi tipe yang digunakan dalam
<<Assignments,penempatan>>
atau inisiasi dari bentuk khusus

----
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)
var v, ok T1 = x.(T)
----

menghasilkan nilai boolean tambahan.
Nilai dari `ok` adalah `true` jika asersi berhasil.
Sebaliknya ia akan `false` dan nilai dari `v` adalah
<<The_zero_value,nilai kosong>>
untuk tipe `T`.
Tidak ada
<<Run_time_panics,panik _runtime>>
yang akan terjadi dalam kasus ini.


[#Calls]
===  Pemanggilan

Diberikan sebuah ekspresi `f` dari tipe fungsi `F`,

----
f(a1, a2, … an)
----

akan memanggil `f` dengan argumen `a1, a2, ... an`.
Kecuali untuk kasus khusus, argumen-argumen haruslah ekspresi nilai-tunggal
yang dapat
<<Assignability,disimpan>>
ke tipe parameter dari `F` dan dievaluasi sebelum fungsi dipanggil.
Tipe dari ekspresi adalah tipe kembalian dari `F`.
Pemanggilan sebuah method mirip namun method itu sendiri ditentukan sebagai
sebuah _selector_ dari sebuah nilai dari tipe _receiver_ untuk method
tersebut.

----
math.Atan2(x, y)  // pemanggilan fungsi
var pt *Point
pt.Scale(3.5)     // pemanggilan method dengan receiver pt
----

Dalam pemanggilan sebuah fungsi, nilai fungsi dan argumennya dievaluasi dengan
<<Order_of_evaluation,urutan yang biasa>>.
Setelah mereka dievaluasi, parameter-parameter dari pemanggilan dikirim
dengan nilai ke dalam fungsi dan fungsi yang dipanggil tersebut mulai
dieksekusi.
Parameter kembalian dari fungsi dikirim dengan nilai ke pemanggil fungsi saat
fungsi berakhir.

Memanggil fungsi yang `nil` menyebabkan
<<Run_time_panics,panik runtime>>.

Kasus khusus, jika nilai kembalian dari sebuah fungsi atau method `g` sama
jumlahnya dan dapat ditempatkan pada parameter-parameter di fungsi atau method
`f`, maka pemanggilan `f(g(parameter_dari_g))` akan memanggil `f`
setelah nilai kembalian dari `g` diberikan sebagai parameter ke `f` secara
berurutan.
Pemanggilan dari `f` tidak boleh berisi parameter selain pemanggilan ke `g`,
dan `g` paling tidak harus mengembalikan satu nilai.
Jika `f` memiliki parameter akhir ..., ia akan diisi nilai kembalian dari `g`
yang tersisa setelah penempatan parameter biasa sebelumnya.

----
func Split(s string, pos int) (string, string) {
	return s[0:pos], s[pos:]
}

func Join(s, t string) string {
	return s + t
}

if Join(Split(value, len(value)/2)) != value {
	log.Panic("test fails")
}
----

Pemanggilan sebuah method `x.m()` valid jika
<<Method_sets,kumpulan method>>
dari (tipe) `x` memiliki `m` dan daftar argumen dapat diberikan ke daftar
parameter dari `m`.
Jika `x` adalah
<<Address_operators,alamat>>
dan kumpulan method `&x` memiliki `m`, `x.m()` adalah singkatan untuk
`(&x).m()`:

----
var p Point
p.Scale(3.5)
----

Tidak ada perbedaan tipe method dan tidak ada literal method.


[#Passing_arguments_to_..._parameters]
===  Mengirim argumen ke parameter ...

Jika `f` adalah
<<Function_types,variadic>>
dengan parameter terakhir bertipe `...T`, maka tipe dari `p` dalam `f` sama
dengan tipe `[]T`.
Jika `f` dipanggil tanpa argumen untuk `p`, maka nilai yang dikirim ke `p`
adalah `nil`.
Sebaliknya, nilai yang dikirim adalah slice baru bertipe `[]T` dengan array
dasar yang elemennya adalah argumen-argumen aslinya, yang semuanya harus dapat
<<Assignability,disimpan>>
ke `T`.
Panjang dan kapasitas slice yaitu jumlah argumen dan bisa berbeda untuk
setiap pemanggilan.

Diberikan fungsi dan pemanggilan

----
func Greeting(prefix string, who ...string)
Greeting("nobody")
Greeting("hello:", "Joe", "Anna", "Eileen")
----

dalam `Greeting`, `who` akan bernilai `nil` pada pemanggilan yang pertama, dan
`[]string{"Joe", "Anna", "Eileen"}`
pada pemanggilan kedua.

Jika argumen terakhir dapat disimpan ke slice bertipe `[]T`, maka akan dikirim
tanpa diubah sebagai nilai untuk parameter `...T` jika argumen diikuti oleh
`...`.
Dalam kasus ini tidak ada slice baru yang dibuat.

Diberikan sebuah slice `s` dan pemanggilan

----
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)
----

dalam `Greeting`, `who` akan bernilai sama dengan `s` dengan array dasar yang
sama.


[#Operators]
===  Operator-operator

Operator menggabungkan operan menjadi ekspresi.

----
Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = "||" | "&&" | rel_op | add_op | mul_op .
rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .

unary_op   = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .
----

Operator pembandingan didiskusikan
<<Comparison_operators,dibagian lain>>.
Untuk operator binari lainnya, tipe operan haruslah
<<Type_identity,identik>>
kecuali pada operasi _shift_ atau bila menggunakan
<<Constants,konstanta>>
tanpa tipe.
Untuk operasi yang mengikutkan konstanta saja, lihat bagian pada
<<Constant_expressions,ekspresi konstanta>>.

Kecuali untuk operasi _shift_, jika salah satu operan adalah
<<Constants,konstanta>>
dan operan lainnya bukan, konstanta tersebut secara implisit
<<Conversions,dikonversi>>
ke tipe operan lainnya.

Operan sebelah kanan dalam ekspresi _shift_ haruslah tipe integer atau
konstanta tak bertipe yang dapat
<<Representability,direpresentasikan>> oleh sebuah
nilai bertipe `uint`.
Jika operan sebelah kiri dari ekspresi _shift_ adalah konstanta tanpa tipe,
maka ia secara implisit dikonversi ke tipe yang diasumsikan jika ekspresi
_shift_ diganti oleh operan kiri.

----
var s uint = 33
var i = 1<<s                  // 1 bertipe int
var j int32 = 1<<s            // 1 bertipe int32; j == 0
var k = uint64(1<<s)          // 1 bertipe uint64; k == 1<<33
var m int = 1.0<<s            // 1.0 bertipe int; m == 0 jika int berukuran
                              // 32bit
var n = 1.0<<s == j           // 1.0 bertipe int32; n == true
var o = 1<<s == 2<<s          // 1 dan 2 bertipe int; o == true jika int
                              // berukuran 32bit
var p = 1<<s == 1<<33         // ilegal jika int berukuran 32bit: 1 bertipe
                              // int, namun 1<<33 int overflow
var u = 1.0<<s                // ilegal: 1.0 bertipe float64, tidak bisa shift
var u1 = 1.0<<s != 0          // ilegal: 1.0 bertipe float64, tidak bisa shift
var u2 = 1<<s != 1.0          // ilegal: 1 bertipe float64, tidak bisa shift
var v float32 = 1<<s          // ilegal: 1 bertipe float32, tidak bisa shift
var w int64 = 1.0<<33         // 1.0<<33 adalah ekspresi konstanta shift
var x = a[1.0<<s]             // 1.0 bertipe int; x == a,0>> jika int berukuran
                              // 32bit
var a = make([]byte, 1.0<<s)  // 1.0 bertipe int; len(a) == 0 jika int
                              // berukuran 32bit
----


====  Urutan operator

Operator _unary_ memiliki urutan tertinggi.
Secara operator `++` dan `--` membentuk perintah, bukan ekspresi, maka mereka
tidak berada dalam hierarki operator.
Akibatnya, perintah `*p++` sama dengan `(*p)++`.

Ada lima tingkat urutan untuk operator binari.
Operator perkalian yang paling tinggi, diikuti oleh operator penambahan,
operator pembandingan, `&&` (operasi logika AND), dan terakhir `||` (operator
logika OR):

----
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
----

Operator binari pada tingkat yang sama akan di proses berurutan dari kiri ke
kanan.
Misalnya, `x / y * z` sama dengan `(x / y) * z`.

----
+x
23 + 3*x[i]
x <= f()
^a >> b
f() || g()
x == y+1 && <-chanPtr > 0
----


[#Arithmetic_operators]
===  Operator aritmetika

Operator aritmetika dipakai pada nilai numerik dan menghasilkan nilai dengan
tipe yang sama dengan operan pertama.
Keempat operator standar aritmetika (+, -, *, /) berlaku pada tipe integer,
_floating-point_, dan complex;
`+` juga berlaku pada string.
Operator _shift_ dan logika _bitwise_ berlaku pada integer saja.

----
+    penjumlahan            integer, float, nilai complex, string
-    pengurangan            integer, float, nilai complex
*    perkalian              integer, float, nilai complex
/    pembagian              integer, float, nilai complex
%    sisa pembagian         integer

&    bitwise AND            integer
|    bitwise OR             integer
^    bitwise XOR            integer
&^   bit clear (AND NOT)    integer

<<   shift kiri             integer << unsigned integer
>>   shift kanan            integer >> unsigned integer
----


====  Operator integer

Untuk dua integer bernilai `x` dan `y`, persamaan integer `q = x / y` dan sisa
pembagian `r = x % y` memenuhi hubungan berikut:

----
x = q*y + r  dan  |r| < |y|
----

dengan `x / y` dibulatkan ke nol
https://en.wikipedia.org/wiki/Modulo_operation[(pembagian dibulatkan)].

----
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
----

Satu-satunya pengecualian dari aturan ini yaitu jika sisa pembagian `x`
adalah nilai negatif paling besar dari tipe `x`, persamaan `q = x / -1` sama
dengan `x` (dan `r = 0`) dikarenakan
<<Integer_overflow,integer overflow>>
dengan dua-komplemen:

----
			 x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808
----

Jika penyebut adalah sebuah
<<Constants,konstanta>>,
ia tidak boleh nol.
Jika penyebut adalah nol pada saat _runtime_,
<<Run_time_panics,panik runtime>>
terjadi.
Jika pembilang tidak negatif dan penyebut adalah sebuah konstanta kelipatan 2,
maka pembagian bisa diganti dengan _shift_ kanan, dan penghitungan sisa
pembagian bisa diganti dengan operasi _bitwise_ AND:

----
x     x / 4     x % 4     x >> 2     x & 3
 11      2         3         2          3
-11     -2        -3        -3          1
----

Operator _shift_ menggeser operan sebelah kiri sebanyak jumlah yang
disebutkan pada operan sebelah kanan, yang haruslah positif.
Jika bagian kanan operan _shift_ negatif pada saat _runtime_,
<<Run_time_panics,panik runtime>>
terjadi.
Operator _shift_ menerapkan penggeseran aritmetika jika operan kiri adalah
signed integer dan logika penggeseran jika ia adalah unsigned integer.
Tidak ada batas atas pada nilai penggeser.
Penggeseran berjalan seperti operan kiri digeser `n` kali dengan 1 untuk
jumlah penggeser `n`.
Hasilnya, `x << 1` sama dengan `x*2` dan `x >> 1` sama dengan `x/2` tetapi
dibulatkan ke nilai negatif tak terhingga.

Untuk operan integer, operator _unary_ `+`, `-`, dan `^` didefinisikan
sebagai berikut:

----
+x                        yaitu 0 + x
-x    negasi              yaitu 0 - x
^x    komplemen bitwise   yaitu m ^ x  dengan m = "semua bit diset ke 1" untuk unsigned x
                                       dan    m = -1 untuk signed x
----


====  Integer overflow

Untuk nilai unsigned integer, operasi `+`, `-`, `*`, dan `<<` dihitung
_modulo_ 2^n, yang mana `n` adalah lebar bit dari tipe
<<Numeric_types,unsigned integer>>.
Dengan kata lain, operasi unsigned integer menghilangkan bit paling tinggi
saat overflow terjadi.

Untuk signed integer, operasi `+`, `-`, `*`, `/` dan `<<` bisa saja
_overflow_ dan memiliki hasil yang secara deterministik didefinisikan oleh
representasi signed integer, operasi, dan operannya.
_Overflow_ tidak menyebabkan
<<Run_time_panics, panik runtime>>.
_Compiler_ bisa saja tidak mengoptimalkan sebuah kode dengan asumsi bahwa
_overflow_ tidak akan terjadi.
Misalnya, _compiler_ tidak mengasumsikan bahwa `x < x + 1` selalu bernilai
`true`.


====  Operator _floating-point_

Untuk bilangan _floating-point_ dan _complex_, `+x` sama dengan `x`, sementara
`-x` adalah negasi dari `x`.
Hasil pembagian dari _floating-point_ atau complex dengan nol tidak
dispesifikasikan oleh standar IEEE-754;
apakah
<<Run_time_panics, panik runtime>>
terjadi adalah spesifik pada implementasi.

Implementasi bisa menggabungkan beberapa operasi _floating-point_ menjadi
sebuah operasi gabungan, kemungkinan antara beberapa perintah, dan
menghasilkan nilai yang berbeda bila dieksekusi dan dibulatkan masing-masing.
<<Conversions, Konversi>>
tipe _floating-point_ secara eksplisit membulatkan ke presisi dari tipe
target, menghindari penggabungan yang menyebabkan pembulatan.

Misalnya, beberapa arsitektur menyediakan instruksi "fused multiply add" (FMA)
yang menghitung `x*y + z` tanpa pembulatan dari hasil `x*y`.
Contoh berikut memperlihatkan kapan implementasi Go menggunakan instruksi
tersebut:

----
// FMA dibolehkan menghitung r, karena x*y secara eksplisit tidak dibulatkan:
r  = x*y + z
r  = z;   r += x*y
t  = x*y; r = t + z
*p = x*y; r = *p + z
r  = x*y + float64(z)

// FMA tidak dibolehkan menghitung r, karena akan menghilangkan pembulatan
// dari x*y:
r  = float64(x*y) + z
r  = z; r += float64(x*y)
t  = float64(x*y); r = t + z
----


====  Penggabungan string

Beberapa string bisa digabungkan menggunakan operator `+` atau operator
penempatan `+=`:

----
s := "hi" + string(c)
s += " and good bye"
----

Penambahan string menghasilkan string yang baru dengan menggabungkan
operan-operannya.


[#Comparison_operators]
===  Operator pembandingan

Operator pembandingan membandingkan dua opera dan menghasilkan nilai boolean
tak bertipe.

----
==    equal
!=    not equal
<     less
<=    less or equal
>     greater
>=    greater or equal
----

Dalam setiap pembandingan, operan pertama haruslah
<<Assignability, dapat disimpan>>
ke tipe dari operan kedua, atau sebaliknya.

Operator persamaan `==` dan `!=` berlaku untuk operan-operan yang dapat
_dibandingkan_.
Operator pengurutan `<`, `<=`, `>`, dan `>=` berlaku untuk operan-operan yang
dapat _diurutkan_.
Berikut definisi aturan-aturan dan hasil dari pembandingan:

*  Nilai boolean dapat dibandingkan.
   Dua boolean adalah sama jika keduanya adalah `true` atau `false`.
*  Nilai integer dapat dibandingkan dan diurutkan, dengan cara yang biasa.
*  Nilai _floating-point_ dapat dibandingkan dan diurutkan, seperti yang
   didefinisikan oleh standar IEEE-754
*  Nilai complex dapat dibandingkan.
   Dua nilai complex `u` dan `v` adalah sama jika keduanya `real(u) ==
   real(v)` dan `imag(u) == imag(v)`.
*  Nilai string dapat dibandingkan dan diurutkan, secara leksikal per byte.
*  Nilai pointer dapat dibandingkan.
   Dua nilai pointer adalah sama jika ia menunjuk ke variabel yang sama atau
   jika keduanya bernilai `nil`.
   Pointer ke variabel dengan
   <<Size_and_alignment_guarantees, ukuran nol>>
   bisa jadi sama atau tidak.
*  Nilai channel dapat dibandingkan.
   Dua channel adalah sama jika keduanya dibuat oleh pemanggilan
   <<Making_slices_maps_and_channels, make>>
   yang sama atau jika keduanya bernilai `nil`.
*  Nilai interface dapat dibandingkan.
   Dua interface dikatakan sama jika keduanya memiliki tipe dinamis yang
   <<Type_identity, identik>>
   dan memiliki nilai dinamis yang sama atau jika keduanya bernilai `nil`.
*  Nilai `x` bertipe bukan interface `X` dan nilai `t` bertipe interface `T`
   dapat dibandingkan bila nilai dari tipe `X` dapat dibandingkan dan `X`
   mengimplementasikan `T`.
   Keduanya sama jika tipe dinamis `t` identik dengan `X` dan nilai dinamis
   `t` sama dengan `x`.
*  Nilai struct dapat dibandingkan jika semua field dapat dibandingkan.
   Dua nilai struct adalah sama jika setiap field yang bukan
   <<Blank_identifier, kosong>>
   adalah sama.
*  Nilai array dapat dibandingkan jika nilai dari tipe elemen array dapat
   dibandingkan.
   Dua nilai array adalah sama jika kedua elemen array adalah sama.

Pembandingan dua nilai interface dengan tipe dinamis yang identik menyebabkan
<<Run_time_panics,panik runtime>>
jika nilai dari tipe tersebut tidak bisa dibandingkan.
Perilaku ini berlaku tidak saja pada pembandingan nilai interface langsung
namun juga saat membandingkan array dari nilai interface atau struct dengan
field bernilai interface.

Nilai slice, map, dan fungsi tidak bisa dibandingkan.
Namun, sebagai kasus spesial, nilai slice, map, atau fungsi bisa jadi
dibandingkan dengan pengidentifikasi `nil`.
Pembandingan nilai pointer, channel, dan interface dengan `nil` juga
dibolehkan dan mengikuti aturan di atas.

----
const c = 3 < 4            // c adalah konstanta boolean tak bertipe true

type MyBool bool
var x, y int
var (
	// Hasil dari pembandingan a yaitu boolean tak bertipe.
	// Aturan penempatan biasa berlaku.
	b3        = x == y // b3 bertipe bool
	b4 bool   = x == y // b4 bertipe bool
	b5 MyBool = x == y // b5 bertipe MyBool
)
----


[#Logical_operators]
===  Operator logika

Operator logika berlaku untuk nilai
<<Boolean_types,boolean>>
dan menghasilkan tipe yang sama dengan operan.
Operan kanan dievaluasi berdasarkan kondisi.

----
&&    kondisi AND    p && q  yaitu  "jika p maka q selainnya false"
||    kondisi OR     p || q  yaitu  "jika p maka true selainnya q"
!     NOT                !p  yaitu  "bukan p"
----


[#Address_operators]
===  Operator alamat

Untuk sebuah operan `x` bertipe `T`, operasi alamat `&x` mengembalikan sebuah
pointer bertipe `*T` ke `x`.
Operan tersebut haruslah memiliki alamat, yaitu, sebuah variabel, pointer
ke pointer, atau operasi pengindeksan slice;
atau sebuah _selector_ field dari operan struct yang memiliki alamat;
atau sebuah operasi pengindeksan array dari array yang memiliki alamat;.
Salah satu pengecualian dari kebutuhan alamat ini yaitu `x` mungkin bisa
sebuah (dalam tanda kurung)
<<Composite_literals, literal komposit>>.
Jika evaluasi dari `x` menyebabkan
<<Run_time_panics,panik runtime>>,
maka evaluasi dari `&x` juga akan panik.

Untuk sebuah operan `x` berupa pointer bertipe `*T`, pointer ke pointer dari
`*x` menyatakan
<<Variables, variabel>>
bertipe `T` yang ditunjuk oleh `x`.
Jika `x` adalah `nil`, evaluasi dari `*x` akan menyebabkan
<<Run_time_panics,panik runtime>>.

----
&x
&a[f(2)]
&Point{2, 3}
*p
*pf(x)

var x *int = nil
*x   // menyebabkan panik runtime
&*x  // menyebabkan panik runtime
----


[#Receive_operator]
===  Operator terima

Untuk sebuah operan `ch` <<Channel_types, bertipe channel>>,  nilai dari
operasi terima `<-ch` adalah nilai yang diterima dari channel `ch`.
Arah dari channel haruslah membolehkan operasi terima, dan tipe kembalian dari
operasi terima yaitu tipe elemen dari channel.
Ekspresi dari `<-ch` akan diblok sampai sebuah nilai tersedia.
Operasi terima dari channel yang `nil` akan diblok selamanya.
Operasi terima dari channel yang telah <<Close, ditutup>> akan selalu
diproses langsung, menghasilkan <<The_zero_value, nilai kosong>> dari tipe
elemen setelah semua nilai yang sebelumnya dikirim ke channel telah diterima
semuanya.

----
v1 := <-ch
v2 = <-ch
f(<-ch)
<-strobe  // tunggu sampai waktu habis dan hiraukan nilai yang diterima
----

Ekspresi terima yang digunakan dalam <<Assignments, penempatan>> atau inisiasi
dari bentuk khusus

----
x, ok = <-ch
x, ok := <-ch
var x, ok = <-ch
var x, ok T = <-ch
----

menghasilkan nilai boolean yang melaporkan apakah komunikasi sukses atau
tidak.
Nilai dari `ok` adalah `true` jika nilai yang diterima dikirim oleh
sebuah operasi pengiriman ke channel yang sukses, atau `false` jika
nilainya adalah nilai kosong karena channel telah ditutup dan kosong.


[#Conversions]
===  Konversi

Sebuah konversi mengubah <<Types, tipe>> dari sebuah ekspresi ke tipe yang
ditentukan oleh konversi.
Sebuah konversi bisa muncul secara literal dalam sumber kode, atau ia bisa
diimplikasikan oleh konteks di mana ekspresi muncul.

Konversi eksplisit yaitu ekspresi dalam bentuk `T(x)` dengan `T` adalah sebuah
tipe dan `x` adalah sebuah ekspresi yang dapat dikonversi ke tipe `T`.

----
Conversion = Type "(" Expression [ "," ] ")" .
----

Jika tipe diawali dengan operator `*` atau `<-`, atau jika tipe dimulai dengan
kata kunci `func` dan tidak memiliki daftar kembalian, maka ia haruslah diberi
tanda kurung bila diperlukan untuk menghindari kebingungan:

----
*Point(p)        // sama dengan *(Point(p))
(*Point)(p)      // p dikonversi ke *Point
<-chan int(c)    // sama dengan <-(chan int(c))
(<-chan int)(c)  // c dikonversi ke <-chan int
func()(x)        // penanda fungsi func() x
(func())(x)      // x dikonversi ke func()
(func() int)(x)  // x dikonversi ke func() int
func() int(x)    // x dikonversi ke func() int (tidak ambigu)
----

Sebuah <<Constants, konstanta>> bernilai `x` dapat dikonversi ke tipe `T` jika
`x` dapat <<Representability, direpresentasikan>> oleh nilai dari `T`.
Untuk kasus khusus, nilai konstanta `x` dapat secara eksplisit dikonversi ke
sebuah <<String_types, tipe string>> menggunakan
<<Conversions_to_and_from_a_string_type, aturan yang sama>>
dengan nilai non-konstanta `x`.

Mengonversi sebuah konstanta menghasilkan konstanta bertipe.

----
uint(iota)               // nilai iota bertipe uint
float32(2.718281828)     // 2.718281828 dengan tipe float32
complex128(1)            // 1.0 + 0.0i bertipe complex128
float32(0.49999999)      // 0.5 bertipe float32
float64(-1e-1000)        // 0.0 bertipe float64
string('x')              // "x" bertipe string
string(0x266c)           // "♬" bertipe string
MyString("foo" + "bar")  // "foobar" bertipe MyString
string([]byte{'a'})      // bukan konstanta: []byte{'a'} bukan konstanta
(*int)(nil)              // bukan konstanta: nil bukan konstanta, *int bukan
                         // sebuah tipe boolean, numerik, atau string
int(1.2)                 // ilegal: 1.2 tidak dapat direpresentasikan sebagai int
string(65.0)             // ilegal: 65.0 bukan konstanta integer
----

Sebuah nilai yang bukan konstanta `x` dapat dikonversi ke tipe `T` dalam
kasus-kasus berikut:

*  `x` dapat <<Assignability, disimpan>> ke `T`
*  mengindahkan tag dari struct (lihat bagian bawah), tipe `x` dan `T`
   memiliki <<Types, tipe dasar>> yang <<Type_identity, identik>>..
*  mengindahkan tag dari struct (lihat bagian bawah), tipe `x` dan `T` adalah
   tipe pointer yang bukan <<Type_definitions, tipe terdefinisi>>, dan tipe
   dasar pointer keduanya memiliki tipe dasar yang identik.
*  tipe `x` dan `T` adalah tipe integer atau _floating point_.
*  tipe `x` dan `T` adalah tipe complex.
*  `x` adalah integer atau slice byte atau rune dan `T` bertipe string
*  `x` adalah string dan `T` adalah sebuah slice byte atau rune.

<<Struct_types, tag dari struct>> diindahkan saat membanding tipe struct untuk
identitas untuk tujuan konversi:

----
type Person struct {
	Name    string
	Address *struct {
		Street string
		City   string
	}
}

var data *struct {
	Name    string `json:"name"`
	Address *struct {
		Street string `json:"street"`
		City   string `json:"city"`
	} `json:"address"`
}

var person = (*Person)(data)  // mengindahkan tag, tipe dasarnya identik
----

Aturan-aturan spesifik berlaku untuk konversi (non-konstanta) antara tipe
numerik atau dari dan ke tipe string.
Konversi ini bisa mengubah representasi dari `x` dan membutuhkan biaya pada
saat _runtime_.
Konversi yang lainnya hanya mengubah tipe tetapi tidak representasi dari `x`.

Tidak ada mekanisme linguistik untuk mengonversi antara pointer dan integer.
Paket
<<Package_unsafe, unsafe>>
mengimplementasikan fungsionalitas tersebut dengan batasan-batasan tertentu.

====  Konversi antara tipe numerik

Untuk konversi nilai numerik yang bukan konstanta, aturan-aturan berikut
berlaku:

1. Saat mengonversi antara tipe integer, jika nilai adalah signed integer,
   maka _sign_ -nya diperpanjang menjadi presisi tanpa batas;
   selain dari itu dinolkan.
   Nilainya kemudian dipotong untuk sesuai dengan ukuran tipe tujuan.
   Sebagai contohnya, jika `v := uint16(0x10F0)`, maka `uint32(int8(v)) ==
   0xFFFFFFF0`.
   Konversi selalu menghasilkan nilai yang valid;
   tidak ada indikasi _overflow_.
2. Saat mengonversi bilangan _floating point_ ke sebuah integer, maka
   pecahannya diindahkan (dibulatkan ke nol).
3. Saat mengonversi sebuah bilangan integer atau _floating-point_ ke tipe
   _floating-point_, atau sebuah bilangan complex ke tipe complex lainnya,
   nilai akhirnya dibulatkan ke presisi yang ditentukan oleh tipe tujuan.
   Misalnya, nilai variabel `x` bertipe `float32` disimpan menggunakan
   presisi tambahan diluar bilangan IEEE-754 32-bit, namun `float32(x)`
   merepresentasikan hasil dari pembulatan nilai `x` ke presisi 32-bit.
   Hal yang sama, `x + 0.1` bisa memakai presisi lebih dari 32 bit, namun
   `float32(x + 0.1)` tidak.

Dalam semua konversi non-konstanta yang mengikutkan nilai _floating-point_
atau complex, jika tipe tujuan tidak dapat merepresentasikan nilai maka
konversi akan sukses namun nilai akhirnya bergantung pada implementasi.

[#Conversions_to_and_from_a_string_type]
====  Konversi ke dan dari tipe string

(1) Mengonversi nilai signed atau unsigned integer ke tipe string menghasilkan
sebuah string yang berisi representasi UTF-8 dari integer.
Nilai di luar rentang kode Unicode yang valid dikonversi ke "\uFFFD".

----
string('a')       // "a"
string(-1)        // "\ufffd" == "\xef\xbf\xbd"
string(0xf8)      // "\u00f8" == "ø" == "\xc3\xb8"
type MyString string
MyString(0x65e5)  // "\u65e5" == "日" == "\xe6\x97\xa5"
----

(2) Mengonversi sebuah slice byte ke tipe string menghasilkan sebuah string
yang setiap rangkaian byte adalah elemen dari slice.

----
string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})   // "hellø"
string([]byte{})                                     // ""
string([]byte(nil))                                  // ""

type MyBytes []byteConstant_expressions
string(MyBytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"
----

(3) Mengonversi sebuah slice rune ke tipe string menghasilkan sebuah string
yang merupakan penggabungan dari setiap nilai rune yang dikonversi ke
string.

----
string([]rune{0x767d, 0x9d6c, 0x7fd4})   // "\u767d\u9d6c\u7fd4" == "白鵬翔"
string([]rune{})                         // ""
string([]rune(nil))                      // ""

type MyRunes []rune
string(MyRunes{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"
----

(4) Mengonversi sebuah nilai bertipe string ke slice byte menghasilkan sebuah
slice yang rangkaian elemen-elemennya adalah byte dari string.

----
[]byte("hellø")   // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
[]byte("")        // []byte{}

MyBytes("hellø")  // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
----

(5)  Mengonversi nilai bertipe string ke slice rune menghasilkan sebuah slice
yang berisi setiap individu kode point Unicode dari string.

----
[]rune(MyString("白鵬翔"))  // []rune{0x767d, 0x9d6c, 0x7fd4}
[]rune("")                 // []rune{}

MyRunes("白鵬翔")           // []rune{0x767d, 0x9d6c, 0x7fd4}
----


[#Constant_expressions]
===  Ekspresi konstanta

Ekspresi konstanta bisa berisi hanya operan-operan
<<Constants, konstanta>>
dan dievaluasi saat di-_compile_.

Konstanta tanpa tipe dari boolean, numerik, dan string bisa digunakan sebagai
operan di mana pun selama legal menggunakan operan bertipe boolean, numerik,
atau string.

<<Comparison_operators, Pembandingan>>
konstanta selalu menghasilkan konstanta boolean tak bertipe.
Jika operan kiri dari
<<Operators, ekspresi shift>>
adalah konstanta tak bertipe, hasilnya adalah konstanta integer;
sebaliknya jika operan kiri yaitu konstanta bertipe maka hasilnya konstanta
dengan tipe yang sama dengan operan kiri, yang haruslah
<<Numeric_types, bertipe integer>>.

Operasi lain pada konstanta tanpa tipe menghasilkan konstanta tanpa tipe dari
jenis yang sama: yaitu konstanta boolean, integer, _floating-point_, complex,
atau string.
Jika operan dari operasi binari tidak bertipe (selain _shift_) memiliki jenis
yang berbeda, hasilnya yaitu jenis operan yang muncul terakhir dalam daftar:
integer, rune, floating-point, complex.
Misalnya, konstanta integer tanpa tipe dibagi dengan konstanta complex tanpa
tipe menghasilkan konstanta complex tanpa tipe.

----
const a = 2 + 3.0          // a == 5.0   (konstanta floating-point tanpa tipe)
const b = 15 / 4           // b == 3     (konstanta integer tanpa tipe)
const c = 15 / 4.0         // c == 3.75  (konstanta floating-point tanpa tipe)
const Θ float64 = 3/2      // Θ == 1.0   (tipe float64, 3/2 adalah pembagian integer)
const Π float64 = 3/2.     // Π == 1.5   (tipe float64, 3/2 adalah pembagian integer)
const d = 1 << 3.0         // d == 8     (konstanta integer tanpa tipe)
const e = 1.0 << 3         // e == 8     (konstanta integer tanpa tipe)
const f = int32(1) << 33   // illegal    (konstanta 8589934592 overflow int32)
const g = float64(2) >> 1  // illegal    (float64(2) adalah konstanta bertipe floating-point)
const h = "foo" > "bar"    // h == true  (konstanta boolean tanpa tipe)
const j = true             // j == true  (konstanta boolean tanpa tipe)
const k = 'w' + 1          // k == 'x'   (konstanta rune tanpa tipe)
const l = "hi"             // l == "hi"  (konstanta string tanpa tipe)
const m = string(k)        // m == "x"   (tipe string)
const Σ = 1 - 0.707i       //            (konstanta complex tanpa tipe)
const Δ = Σ + 2.0e-4       //            (konstanta complex tanpa tipe)
const Φ = iota*1i - 1/1i   //            (konstanta complex tanpa tipe)
----

Menerapkan fungsi bawaan `complex` ke konstanta integer, rune, atau
floating-point tanpa tipe menghasilkan konstanta complex tanpa tipe.

----
const ic = complex(0, c)   // ic == 3.75i  (konstanta complex tak bertipe)
const iΘ = complex(0, Θ)   // iΘ == 1i     (tipe complex128)
----

Ekspresi konstanta selalu dievaluasi seperti yang tertulis;
Nilai sementara dan konstanta itu sendiri bisa membutuhkan presisi yang lebih
besar dari tipe yang didukung dalam bahasa.
Berikut ini deklarasi yang legal:

----
const Huge = 1 << 100         // Huge == 1267650600228229401496703205376  (konstanta integer tak bertipe)
const Four int8 = Huge >> 98  // Four == 4                                (tipe int8)
----

Penyebut dari pembagian sebuah konstanta atau operasi penyisaan haruslah nol:

----
3.14 / 0.0   // ilegal: pembagian dengan nol
----

Nilai dari konstanta bertipe haruslah selalu secara akurat
<<Representability, direpresentasikan>>
oleh nilai dari tipe konstanta.
Ekspresi konstanta berikut adalah ilegal:

----
uint(-1)     // -1 tidak dapat direpresentasikan sebagai uint
int(3.14)    // 3.14 tidak dapat direpresentasikan sebagai int
int64(Huge)  // 1267650600228229401496703205376 tidak dapat direpresentasikan sebagaiint64
Four * 300   // operan 300 tidak dapat direpresentasikan sebagai int8 (tipe Four)
Four * 100   // hasil 400 tidak dapat direpresentasikan sebagai int8 (tipe Four)
----

_Mask_ yang digunakan oleh operator komplemen _unary bitwise_ `^` cocok dengan
aturan untuk non-konstanta: semua mask adalah 1 untuk konstanta integer dan -1
untuk signed dan konstanta tak bertipe.

----
^1         // konstanta integer tak bertipe, sama dengan -2
uint8(^1)  // ilegal: sama dengan uint8(-2), -2 tidak dapat direpresentasikan sebagai uint8
^uint8(1)  // konstanta uint8 bertipe, sama dengan 0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)   // sama dengan int8(-2)
^int8(1)   // sama dengan -1 ^ int8(1) = -2
----

Batasan implementasi: _compiler_ bisa melakukan pembulatan saat menghitung
ekspresi konstanta floating-point atau complex yang tak bertipe;
lihat batasan implementasi dalam bagian <<Constants, konstanta>>.
Pembulatan ini bisa menyebabkan ekspresi konstanta floating-point menjadi
tidak valid dalam konteks integer, walaupun menjadi integral saat dihitung
menggunakan presisi tanpa batas, dan sebaliknya.


[#Order_of_evaluation]
===  Urutan evaluasi

Pada tingkat paket,
<<Packet_initialization, inisiasi kebergantungan>>
menentukan urutan evaluasi dari
ekspresi inisiasi individu dalam
<<Variable_declarations, deklarasi variabel>>.
Sebaliknya, saat mengevaluasi
<<Operands, operan>>
dari sebuah ekspresi, penempatan, atau
<<Return_statements, perintah kembalian>>,
semua pemanggilan fungsi, pemanggilan method, dan operasi
komunikasi dievaluasi secara leksikal terurut dari kiri-ke-kanan.

Contohnya, pada penempatan

----
y[f()], ok = g(h(), i()+x[j()], <-c), k()
----

pemanggilan fungsi dan komunikasi terjadi dengan urutan f(), h(), i(), j(),
`<-c`, dan `k()`.
Namun, urutan dari even-even tersebut dibandingkan dengan evaluasi dan
pengindeksan dari `x` dan evaluasi dari `y` tidak dispesifikasikan.

----
a := 1
f := func() int { a++; return a }
x := []int{a, f()}            // x bisa jadi [1, 2] atau [2, 2]: urutan
                              // evaluasi antara a dan f() tidak ditentukan.
m := map[int]int{a: 1, a: 2}  // m bisa jadi {2: 1} atau {2: 2}: urutan
                              // evaluasi antara kunci dan nilai tidak ditentukan.
n := map[int]int{a: f()}      // n bisa jadi {2: 3} atau {3: 3}: urutan
                              // evaluasi antara kunci dan nilai tidak ditentukan.
----

Pada tingkat paket, inisiasi dependensi menimpa aturan kiri-ke-kanan untuk
ekspresi inisiasi individu, tetapi tidak untuk operan-operan dalam setiap
ekspresi:

----
var a, b, c = f() + v(), g(), sqr(u()) + v()

func f() int        { return c }
func g() int        { return a }
func sqr(x int) int { return x*x }

// fungsi u dan v independen terhadap semua variabel dan fungsi lainnya.
----

Pemanggilan fungsi terjadi dengan urutan `u()`, `sqr()`, `v()`, `f()`, `v()`,
dan `g()`.

Operasi _floating-point_ dalam sebuah ekspresi dievaluasi menurut asosiatif
dari operator.
Tanda kurung secara eksplisit mempengaruhi evaluasi dengan menimpa asosiatif
baku.
Dalam ekspresi `x+(y+z)` penambahan `y+z` dilakukan sebelum menambahkan
dengan `x`.
